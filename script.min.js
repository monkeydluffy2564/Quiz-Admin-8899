import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // โค้ดที่แก้ไขแล้ว
import { getFirestore, doc, getDoc, setDoc, addDoc, updateDoc, collection, query, where, getDocs, onSnapshot, deleteDoc, deleteField, writeBatch, runTransaction, serverTimestamp, increment, arrayUnion, arrayRemove, getCountFromServer } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
		
		// --- [ เพิ่มโค้ดส่วนนี้ทั้งหมดเข้าไป ] ---
const ANONYMOUS_NAMES = [
  "นักล่าฝัน", "บักแตงโม", "เทพทรู", "เหมียวขี้เซา", "นกฮูกกลางวัน", "เต่าสายฟ้า", "โลมาบิน", "สิงโตยิ้ม", "เพนกวินไฟ", "จิงโจ้สโลว์ไลฟ์",
  "ผู้พิชิตดาว", "มือปราบสายรุ้ง", "เงาปริศนา", "สายลมแห่งโชคชะตา", "อัศวินรัตติกาล", "จอมเวทย์ขนมหวาน", "นินจาชาเขียว", "ซามูไรสายเดี่ยว", "โจรสลัดอวกาศ", "มังกรกินจุ",
  "หมีขั้วโลกใต้", "แมวเก้าชีวิต", "ปลาทูคะนอง", "ไก่ฟ้าพญาลอ", "กุ้งเต้นแร้งกา", "หมาป่าเดียวดาย", "กระต่ายตื่นตูม", "เสือซ่อนเล็บ", "ม้าดีดกะโหลก", "หนอนหนังสือ",
  "ยอดนักสืบ", "สายลับจับบ้านเล็ก", "คนดีศรีสยาม", "ดาวTikTok", "ยูทูปเบอร์ฝึกหัด", "CEOพันล้าน", "เศรษฐีดูไบ", "อินฟลูเอนเซอร์", "เน็ตไอดอล", "ดาวสภา",
  "กาแฟขม", "ชาไข่มุก", "ส้มตำปูปลาร้า", "พิซซ่าหน้าทุเรียน", "ไอติมทอด", "ข้าวมันไก่พิเศษ", "หมูกระทะจะเยียวยาทุกสิ่ง", "ครัวซองต์", "ชีสเค้ก", "ลาเต้ไม่หวาน",
  "สายตาสั้น", "ปวดหลัง", "ออฟฟิศซินโดรม", "นอนไม่พอ", "ติดซีรีส์", "แบตหมด", "เน็ตช้า", "โหลดนาน", "404 Not Found", "กองดอง",
  "จันทร์เจ้า", "ตะวันฉาย", "สายหมอก", "ก้อนเมฆ", "ดวงดาว", "ท้องฟ้า", "ทะเล", "ภูเขา", "ป่าไม้", "แม่น้ำ",
  "นักเดินทาง", "ช่างภาพ", "เกมเมอร์", "ศิลปิน", "นักดนตรี", "นักเขียน", "นักวิทยาศาสตร์", "นักประดิษฐ์", "นักกีฬา", "ครูใหญ่",
  "พลังคลื่นเต่า", "ปล่อยพลัง", "แปลงร่าง", "ตัวแทนแห่งดวงจันทร์", "ดาบพิฆาตอสูร", "คาถาแยกเงาพันร่าง", "ธอร์ค้อนบิน", "ไอรอนแมน", "กัปตัน", "ฮัลค์",
  "รักแรกพบ", "คนโสด", "แอบชอบ", "อกหัก", "เพื่อนสนิท", "คู่จิ้น", "แฟนทิพย์", "คนคุย", "สถานะไม่ชัดเจน", "มูเตลู"
];
let lastSeenQuestionIndex = -1;
let orderedPlayerSelection = []; // ตัวแปรสำหรับเก็บรายชื่อตามลำดับที่กดเลือก
let clientSideHiddenOptions = {};
let blueprintShortcuts = [];
let shortcutTabs = [];         // NEW: สำหรับเก็บข้อมูลแท็บทั้งหมด
let shortcutOrder = {};        // NEW: สำหรับเก็บลำดับการจัดเรียงของแต่ละแท็บ
let activeShortcutTabId = 'all'; // NEW: ID ของแท็บที่กำลังถูกเลือก
let fileShortcutTabs = [];
let fileShortcutOrder = {};
let activeFileShortcutTabId = 'all';
let parallelShortcutTabs = [];
let parallelShortcutOrder = {};
let activeParallelShortcutTabId = 'all';
let fileShortcuts = [];
let parallelTestShortcuts = [];
let cameFromBlueprint = false;
let wakeLock = null;
let localGroupQuestionIndex = 0;

let blueprintPageSettings = null; // สำหรับเก็บค่า setting ชั่วคราวในหน้านี้

let extractedBlueprintData = null; // เก็บข้อมูลหัวข้อที่วิเคราะห์ได้ชั่วคราว
let currentBlueprintProjectId = null; // เก็บ ID ของ Project ที่กำลังดูอยู่

// ฟังก์ชันสำหรับ "ขอ" ให้เบราว์เซอร์เปิดการล็อกหน้าจอ
const requestWakeLock = async () => {
  // ตรวจสอบก่อนว่าเบราว์เซอร์นี้รองรับ Wake Lock หรือไม่
  if ('wakeLock' in navigator) {
    try {
      // ส่งคำขอและเก็บ object wakeLock ไว้ในตัวแปร
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake Lock ทำงานแล้ว: หน้าจอจะไม่ดับเอง');

      // เพิ่ม Event Listener เผื่อกรณีที่การล็อกหลุดไปเอง (เช่น แบตใกล้หมด)
      wakeLock.addEventListener('release', () => {
        console.log('Wake Lock ถูกปิดใช้งานแล้ว');
      });

    } catch (err) {
      // กรณีที่คำขอล้มเหลว (เช่น ผู้ใช้ตั้งค่าเบราว์เซอร์ไม่อนุญาต)
      console.error(`เกิดข้อผิดพลาดในการเปิด Wake Lock: ${err.name}, ${err.message}`);
    }
  } else {
    console.warn('เบราว์เซอร์นี้ไม่รองรับ Wake Lock API');
  }
};

// ฟังก์ชันสำหรับ "ปล่อย" หรือปิดการล็อกหน้าจอ
const releaseWakeLock = async () => {
  // ตรวจสอบว่า wakeLock กำลังทำงานอยู่หรือไม่
  if (wakeLock !== null) {
    await wakeLock.release(); // สั่งปิด
    wakeLock = null; // เคลียร์ค่าในตัวแปร
    console.log('Wake Lock ถูกปิดใช้งานแล้ว: หน้าจอกลับสู่โหมดปกติ');
  }
};
// --- [ สิ้นสุดส่วนที่เพิ่ม ] ---

let dimTimer = null; // ตัวแปรสำหรับเก็บ timer
const inactivityTime = 60000; // 60 วินาที (60000 มิลลิวินาที)

// ฟังก์ชันสำหรับรีเซ็ต Timer และทำให้จอ "สว่าง"
function resetDimTimer() {
    // เราจะรีเซ็ตตัวนับเวลา ก็ต่อเมื่อหน้าจอยังไม่หรี่เท่านั้น
    // ถ้าหน้าจอหรี่ไปแล้ว การขยับเมาส์(ที่ไม่ได้อยู่บน Overlay) จะไม่ปลุกจอ
    if (!document.body.classList.contains('dimmed')) {
        if (dimTimer) clearTimeout(dimTimer);
        
        dimTimer = setTimeout(() => {
            // เมื่อครบ 1 นาที ให้หรี่จอ (เหมือนเดิม)
            document.body.classList.add('dimmed');
            console.log('หน้าจอหรี่แสงลงเนื่องจากไม่ใช้งาน');
        }, inactivityTime);
    }
}

function wakeUpScreen(event) {
    if (event) {
        event.stopPropagation(); // <--- คำสั่งสำคัญ: หยุดไม่ให้คลิกทะลุ
        event.preventDefault();
    }
    
    // 1. สั่งให้ Overlay หายไป
    document.body.classList.remove('dimmed'); 
    
    // 2. หลังจากปลุกจอแล้ว ให้เริ่มนับเวลาพักหน้าจอใหม่
    if (dimTimer) clearTimeout(dimTimer);
    dimTimer = setTimeout(() => {
        document.body.classList.add('dimmed');
    }, inactivityTime);
}

// ฟังก์ชันสำหรับหยุดระบบจับเวลาทั้งหมด
function stopDimTimer() {
    if (dimTimer) clearTimeout(dimTimer);
    document.body.classList.remove('dimmed');
    window.removeEventListener('mousemove', resetDimTimer);
    window.removeEventListener('mousedown', resetDimTimer);
    window.removeEventListener('touchstart', resetDimTimer);
    window.removeEventListener('keydown', resetDimTimer);
    console.log('หยุดระบบจับเวลาหรี่หน้าจอ');
}

        // --- Global State & Config ---
		
		// =====================================================================
// === [เพิ่ม] ตัวแปร Global ใหม่สำหรับ Team Quiz ===
// =====================================================================
// วางไว้ใกล้ๆ กับตัวแปร Global อื่นๆ ด้านบนของ Script
let currentTeamQuizId = null;
let unsubscribeTeamQuizListener = null;
let localTeamPlayers = []; // เก็บชื่อผู้เล่นที่เลือกในเครื่องนี้
let localPlayerTurnIndex = 0; // ลำดับผู้เล่นในเครื่องนี้
let localQuestionIndex = 0;   // [เพิ่ม] ตัวแปรสำหรับนับข้อปัจจุบัน
let localPlayerIndex = 0;     // [เพิ่ม] ตัวแปรสำหรับนับผู้เล่นในข้อนั้นๆ
let currentApplicationData = [];

// =====================================================================
// === [เพิ่ม] ฟังก์ชันใหม่ทั้งหมดสำหรับ Team Quiz (ฝั่ง Admin) ===
// =====================================================================
/**
 * เริ่ม Team Quiz Session ใหม่ (Admin)
 */
async function handleStartTeamQuiz(quizId, shouldSave = false) {
    const quiz = allQuizzes.find(q => q.id === quizId) || allQuizzesGlobal.find(q => q.id === quizId);
    if (!quiz) {
        showMessage("ไม่พบข้อมูลแบบทดสอบ");
        return;
    }

    // สลับข้อ/ตัวเลือก ตามการตั้งค่า
    currentQuizData = getShuffledQuiz(quiz);

    const teamPin = Math.floor(1000 + Math.random() * 9000).toString();

    try {
        const teamQuizRef = await addDoc(collection(db, `artifacts/${appId}/public/data/teamQuizzes`), {
            quizId: quiz.id,
            projectId: quiz.projectId,
            status: "lobby", // สถานะ: รอผู้เล่น
            pin: teamPin,
            createdAt: serverTimestamp(),
            currentQuestionIndex: 0,
            responses: {}, // เก็บคำตอบทั้งหมด
			shuffledQuiz: currentQuizData, // เพิ่ม field นี้เข้าไปด้วย
            shouldSaveResults: shouldSave // <-- เพิ่มบรรทัดนี้
        });

        currentTeamQuizId = teamQuizRef.id;
        showView('live-game'); // ใช้ live-game-view เดิมเป็น container
        renderAdminTeamQuizDashboard(teamPin, quiz.topic);
        listenForTeamQuizUpdates();

    } catch (err) {
        console.error("Error starting team quiz:", err);
        showMessage("เกิดข้อผิดพลาดในการสร้างห้อง Team Quiz");
    }
}

function renderAdminTeamQuizDashboard(pin, topic, mode = 'team') { // 1. เพิ่มพารามิเตอร์ mode
    // 2. เพิ่มเงื่อนไขเพื่อเลือกหัวข้อ
    const modeTitle = (mode === 'group') ? 'Group Mode' : 'Team Quiz';

    liveGameView.innerHTML = `
        <div class="bg-cyan-600 text-white rounded-lg p-8 flex flex-col h-full items-center">
            <h2 class="text-2xl font-bold mb-2">${modeTitle}: ${topic}</h2>
            <p class="text-lg mb-4">ให้นักเรียนเข้าร่วมด้วยรหัสนี้:</p>
            <div class="bg-white text-gray-800 rounded-lg p-4 mb-4">
                <p class="text-6xl font-bold tracking-widest">${pin}</p>
            </div>
            <div class="w-full max-w-2xl bg-white/20 p-4 rounded-lg mt-4 flex-grow overflow-y-auto">
                <h3 class="text-xl font-semibold mb-2 text-center">สถานะผู้เล่น</h3>
                <div id="team-player-status-grid" class="space-y-2">
                    <p class="text-center text-cyan-200">ยังไม่มีผู้เล่นเข้าร่วม...</p>
                </div>
            </div>
             <button id="end-team-quiz-btn" class="mt-6 bg-red-600 text-white py-2 px-6 rounded-lg hover:bg-red-700">
                <i class="fas fa-times-circle mr-2"></i>จบกิจกรรม
            </button>
        </div>
    `;

    document.getElementById('end-team-quiz-btn').addEventListener('click', async () => {
        showConfirmation("คุณแน่ใจหรือไม่ว่าต้องการจบกิจกรรมนี้?", async () => {
            if(unsubscribeTeamQuizListener) unsubscribeTeamQuizListener();
            await deleteDoc(doc(db, `artifacts/${appId}/public/data/teamQuizzes`, currentTeamQuizId));
            showView('project-detail');
        });
    });
}

// --- วางทับฟังก์ชัน listenForTeamQuizUpdates เดิมทั้งหมด ---
function listenForTeamQuizUpdates() {
    if (unsubscribeTeamQuizListener) unsubscribeTeamQuizListener();

    const teamQuizRef = doc(db, `artifacts/${appId}/public/data/teamQuizzes`, currentTeamQuizId);
    unsubscribeTeamQuizListener = onSnapshot(teamQuizRef, (docSnap) => {
        if (!docSnap.exists()) {
            // --- [START] นี่คือส่วนที่แก้ไขทั้งหมด ---
            sessionStorage.removeItem('activeGameSession');
            if (unsubscribeTeamQuizListener) unsubscribeTeamQuizListener();
            showMessage("กิจกรรมสิ้นสุดลงแล้ว");
            
            if (cameFromBlueprint && currentBlueprintProjectId) {
                // ถ้ามาจาก Blueprint ให้กลับไปหน้า Blueprint Manager
                displayBlueprintProjectManager(currentBlueprintProjectId);
                cameFromBlueprint = false; // ล้างความจำ
            } else if (currentMode === 'admin') {
                // ถ้าเป็น admin แต่ไม่ได้มาจาก Blueprint ให้กลับไปหน้า Project Detail
                showView('project-detail');
            } else {
                // ถ้าเป็น student ให้กลับหน้าแรก
                showView('student');
            }
            // --- [END] สิ้นสุดส่วนที่แก้ไข ---
            return;
        }

        const gameData = docSnap.data();

        if (currentMode === 'admin') {
            if (gameData.mode === 'group' && gameData.status !== 'podium' && gameData.status !== 'finished') {
                const groups = Object.values(gameData.groups || {});
                if (groups.length > 0) {
                    const allFinished = groups.every(g => g.isFinished === true);
                    if (allFinished) {
                        endGroupModeGame(currentTeamQuizId);
                    }
                }
            }
            updateAdminTeamDashboard(gameData);
        } else {
            if (gameData.status === 'podium' || gameData.status === 'finished') {
                if (unsubscribeTeamQuizListener) unsubscribeTeamQuizListener();
                displayTeamQuizFinalResults();
            } else if (gameData.mode === 'group') {
                const myGroup = gameData.groups[userId];
                if (!myGroup || !myGroup.isFinished) {
                     renderTeamQuizQuestion();
                }
            }
        }
    });
}

/**
 * [Helper Function] สั่งจบเกมสำหรับ Group Mode (Admin only)
 */
async function endGroupModeGame(gameId) {
    console.log("All groups have finished. Ending game.");
    const gameRef = doc(db, `artifacts/${appId}/public/data/teamQuizzes`, gameId);
    try {
	
	        const gameSnap = await getDoc(gameRef);
        if (gameSnap.exists()) {
            const finalGameData = gameSnap.data();
            if (finalGameData.shouldSaveResults) {
                await saveGameResultsAsSubmissions(finalGameData);
            }
        }
        // เปลี่ยนสถานะเป็น podium เพื่อให้ทุกคนเห็นหน้าสรุปผล
        await updateDoc(gameRef, { status: 'podium' });
    } catch (error) {
        console.error("Failed to end group mode game:", error);
    }
}

// ▼▼▼ วางทับฟังก์ชัน updateAdminTeamDashboard เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
function updateAdminTeamDashboard(gameData) {
    const container = document.getElementById('team-player-status-grid');
    if (!container) return;

    const mode = gameData.mode || 'team';
    const totalQuestions = currentQuizData.questions.length;

    if (mode === 'group') {
        const groups = Object.values(gameData.groups || {});
        if (groups.length === 0) {
            container.innerHTML = '<p class="text-center text-cyan-200">ยังไม่มีกลุ่มเข้าร่วม...</p>';
            return;
        }

        // --- [START] ส่วนแก้ไขสำหรับ Group Mode ---
        const sortedGroups = [...groups].sort((a, b) => b.score - a.score);
        const groupScoresHtml = sortedGroups.map((g, index) => {
            // 1. นับจำนวนข้อที่กลุ่มนี้ตอบไปแล้ว
            const questionsAnswered = g.answers?.length || 0;
            
            // 2. สร้าง HTML พร้อมแสดงความคืบหน้า
            return `
                <div class="bg-black/20 p-3 rounded-md transition-all hover:bg-black/40">
                    <div class="flex justify-between items-center">
                        <div>
                            <span class="font-bold">${index + 1}. กลุ่ม: </span>
                            <span class="text-cyan-200">${g.members.join(', ')}</span>
                            <span class="text-xs text-gray-300 ml-2">(${questionsAnswered}/${totalQuestions} ข้อ)</span>
                        </div>
                        <span class="font-bold text-white">${g.score} คะแนน</span>
                    </div>
                </div>
            `;
        }).join('');
        // --- [END] สิ้นสุดส่วนแก้ไข ---

        const questionSummaryHtml = currentQuizData.questions.map((q, index) => {
            let correctGroupCount = 0, answeredGroupCount = 0;
            groups.forEach(group => {
                const answerForThisQ = group.answers?.find(ans => ans.questionIndex === index);
                if (answerForThisQ) {
                    answeredGroupCount++;
                    if (answerForThisQ.isCorrect) correctGroupCount++;
                }
            });
            const isComplete = answeredGroupCount > 0 && answeredGroupCount === groups.length;
            const cardClass = isComplete ? 'bg-green-200 text-green-900 font-bold' : 'bg-black/10';
            const statusIcon = isComplete ? '<i class="fas fa-check-circle text-green-700 ml-1"></i>' : '';
            return `<div class="p-2 rounded-md ${cardClass}"><p class="font-semibold text-sm flex items-center justify-between"><span>ข้อ ${index + 1}:</span><span>${statusIcon}</span></p><p class="text-xs">ตอบถูก ${correctGroupCount}/${groups.length} กลุ่ม</p></div>`;
        }).join('');
        container.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><h4 class="font-bold mb-2">สรุปคะแนนกลุ่ม</h4><div class="space-y-2 text-lg">${groupScoresHtml}</div></div><div><h4 class="font-bold mb-2">สรุปรายข้อ</h4><div class="grid grid-cols-2 lg:grid-cols-3 gap-2">${questionSummaryHtml}</div></div></div>`;
        return;
    }
    
    // --- Logic for Team Mode (ไม่มีการเปลี่ยนแปลง) ---
    const responses = gameData.responses || {};
    const players = Object.keys(responses);
    if (players.length === 0) {
        container.innerHTML = '<p class="text-center text-cyan-200">ยังไม่มีผู้เล่นเข้าร่วม...</p>';
        return;
    }
    const playerScores = players.map(name => ({ name, score: responses[name].score || 0 })).sort((a, b) => b.score - a.score);
    const playerScoresHtml = playerScores.map(p => {
        const turnsTaken = responses[p.name]?.answers?.length || 0;
        const totalTurnsForPlayer = Math.ceil(totalQuestions / players.length);
        return `<div class="flex justify-between items-center bg-black/20 p-2 rounded-md"><span>${p.name} <span class="text-xs text-gray-300">(${turnsTaken}/${totalTurnsForPlayer} ตา)</span></span><span class="font-bold">${p.score} คะแนน</span></div>`;
    }).join('');
    const totalAnswersSubmitted = players.reduce((sum, name) => sum + (responses[name].answers?.length || 0), 0);
    const questionSummaryHtml = currentQuizData.questions.map((q, index) => {
        let answerData = null, playerName = null;
        for (const name of players) {
            const foundAnswer = responses[name].answers?.find(a => a.questionIndex === index);
            if (foundAnswer) {
                answerData = foundAnswer;
                playerName = name;
                break;
            }
        }
        const isAnswered = !!answerData;
        const isCorrect = isAnswered && answerData.isCorrect;
        const roundEndIndex = (Math.floor(index / players.length) + 1) * players.length;
        const isComplete = totalAnswersSubmitted >= roundEndIndex;
        const cardClass = isComplete ? 'bg-green-200 text-green-900' : 'bg-black/10';
        const statusIcon = isComplete ? '<i class="fas fa-check-circle text-green-700 ml-1"></i>' : '';
        let summaryText = 'รอ...';
        if (isAnswered) {
            summaryText = `${playerName} ตอบ${isCorrect ? 'ถูก' : 'ผิด'}`;
        }
        return `<div class="p-2 rounded-md ${cardClass}"><p class="font-semibold text-sm flex items-center justify-between"><span>ข้อ ${index + 1}:</span><span>${statusIcon}</span></p><p class="text-xs font-normal">${summaryText}</p></div>`;
    }).join('');
    container.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div><h4 class="font-bold mb-2">สรุปคะแนนรวม (รายบุคคล)</h4><div class="space-y-1 text-lg">${playerScoresHtml}</div></div><div><h4 class="font-bold mb-2">สรุปรายข้อ</h4><div class="grid grid-cols-2 md:grid-cols-3 gap-2">${questionSummaryHtml}</div></div></div>`;
}


// =====================================================================
// === [เพิ่ม] ฟังก์ชันใหม่ทั้งหมดสำหรับ Team Quiz (ฝั่ง Student) ===
// =====================================================================
/**
 * เริ่มกระบวนการเข้าร่วม Team Quiz (Student)
 */
async function handleJoinTeamQuiz() {
    const pin = prompt("กรุณาป้อนรหัส Team Quiz (4 หลัก):");
    if (!pin || pin.trim().length !== 4) {
        showMessage("รหัสไม่ถูกต้อง");
        return;
    }

    try {
        const quizzesRef = collection(db, `artifacts/${appId}/public/data/teamQuizzes`);
        const q = query(quizzesRef, where("pin", "==", pin.trim()), where("status", "==", "lobby"));
        const snapshot = await getDocs(q);

        if (snapshot.empty) {
            showMessage("ไม่พบ Team Quiz ด้วยรหัสนี้ หรือกิจกรรมได้เริ่มไปแล้ว");
            return;
        }

        const gameDoc = snapshot.docs[0];
        currentTeamQuizId = gameDoc.id;
        const gameData = gameDoc.data();

        // ดึงข้อมูล Project และ Quiz ที่เกี่ยวข้อง
        const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, gameData.projectId);
        const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, gameData.quizId);
        const [projectSnap, quizSnap] = await Promise.all([getDoc(projectRef), getDoc(quizRef)]);

        if (!projectSnap.exists() || !quizSnap.exists()) {
            throw new Error("ไม่พบข้อมูลโปรเจคหรือแบบทดสอบ");
        }

        currentQuizData = getShuffledQuiz({ id: quizSnap.id, ...quizSnap.data() });
        const projectData = projectSnap.data();

        // แสดงหน้าจอเลือกผู้เล่น
        showTeamPlayerSelection(projectData.students, currentQuizData.topic);

    } catch (error) {
        console.error("Error joining team quiz:", error);
        showMessage("เกิดข้อผิดพลาด: " + error.message);
    }
}

// ตัวแปรสำหรับเก็บค่า PIN ที่กำลังกรอก
let currentInputPin = "";

// ฟังก์ชันเปิด Modal แทนการใช้ prompt
function handleJoinGroupActivity() {
    currentInputPin = ""; // รีเซ็ตค่า
    updatePinDisplay(); // เคลียร์หน้าจอ
    document.getElementById('pin-entry-modal').classList.remove('hidden');
}

// ฟังก์ชันอัปเดตหน้าจอ PIN (จุดๆ หรือ ตัวเลข)
function updatePinDisplay() {
    const boxes = document.querySelectorAll('.pin-digit-box');
    boxes.forEach((box, index) => {
        if (index < currentInputPin.length) {
            box.textContent = currentInputPin[index];
            box.classList.add('border-indigo-500', 'bg-white');
            box.classList.remove('border-gray-300', 'bg-gray-50');
        } else {
            box.textContent = "";
            box.classList.remove('border-indigo-500', 'bg-white');
            box.classList.add('border-gray-300', 'bg-gray-50');
        }
    });
}

// ฟังก์ชันเมื่อกดปุ่มตัวเลข
async function handlePinKeyPress(key) {
    if (key === 'backspace') {
        currentInputPin = currentInputPin.slice(0, -1);
    } else if (currentInputPin.length < 4) {
        currentInputPin += key;
    }

    updatePinDisplay();

    // ถ้ากรอกครบ 4 หลัก ให้ส่งทันที (Auto-submit)
    if (currentInputPin.length === 4) {
        // หน่วงเวลานิดนึงเพื่อให้ผู้ใช้เห็นเลขตัวสุดท้ายก่อน
        setTimeout(async () => {
            document.getElementById('pin-entry-modal').classList.add('hidden');
            await processJoinWithPin(currentInputPin);
            currentInputPin = ""; // รีเซ็ต
            updatePinDisplay();
        }, 300);
    }
}

// ฟังก์ชันใหม่สำหรับประมวลผลการเข้าร่วม (ย้าย Logic เดิมมาไว้ที่นี่)
async function processJoinWithPin(pin) {
    const trimmedPin = pin.trim();
    showMessage("กำลังค้นหากิจกรรม...");

    try {
        // 1. ค้นหาใน Team Quizzes
        const teamQuizzesRef = collection(db, `artifacts/${appId}/public/data/teamQuizzes`);
        const teamQuery = query(teamQuizzesRef, where("pin", "==", trimmedPin), where("status", "==", "lobby"));
        const teamSnapshot = await getDocs(teamQuery);

        if (!teamSnapshot.empty) {
            console.log("พบ Team Quiz!");
            await proceedWithTeamQuizJoin(teamSnapshot.docs[0]);
            return; 
        }

        // 2. ค้นหาใน Sync Games
        const syncGamesRef = collection(db, `artifacts/${appId}/public/data/syncGames`);
        const syncQuery = query(syncGamesRef, where("pin", "==", trimmedPin), where("status", "in", ["lobby", "question", "summary", "results"]));
        const syncSnapshot = await getDocs(syncQuery);

        if (!syncSnapshot.empty) {
            console.log("พบ Sync Game!");
            await proceedWithSyncQuizJoin(syncSnapshot.docs[0]);
            return; 
        }
        
        // 3. ถ้าไม่เจอ
        showMessage("ไม่พบกิจกรรมด้วยรหัสนี้ หรือกิจกรรมอาจเริ่มไปแล้ว");

    } catch (error) {
        console.error("Error joining activity:", error);
        showMessage("เกิดข้อผิดพลาดในการเชื่อมต่อ: " + error.message);
    }
}

async function proceedWithTeamQuizJoin(gameDoc) {
    currentTeamQuizId = gameDoc.id;
    const gameData = gameDoc.data();
    const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, gameData.projectId);
    const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, gameData.quizId);
    const [projectSnap, quizSnap] = await Promise.all([getDoc(projectRef), getDoc(quizRef)]);

    if (!projectSnap.exists() || !quizSnap.exists()) {
        throw new Error("ไม่พบข้อมูลโปรเจคหรือแบบทดสอบ");
    }
    currentQuizData = getShuffledQuiz({ id: quizSnap.id, ...quizSnap.data() });
    showTeamPlayerSelection(projectSnap.data().students, currentQuizData.topic, gameData.mode || 'team'); // ส่ง mode เข้าไปด้วย
    messageModal.classList.add('hidden');
}

async function proceedWithSyncQuizJoin(gameDoc) {
    currentLiveGameId = gameDoc.id;
    const gameData = gameDoc.data();
    const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, gameData.quizId);
    const quizSnap = await getDoc(quizRef);
    if (!quizSnap.exists()) throw new Error("ไม่พบข้อมูลแบบทดสอบ");
    
    const quizData = quizSnap.data();
    const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, quizData.projectId);
    const projectSnap = await getDoc(projectRef);
    if (!projectSnap.exists()) throw new Error("ไม่พบข้อมูลโปรเจค");
    
    currentQuizData = gameData.shuffledQuiz;
    
    showView('student-team-join');
    showTeamPlayerSelection(projectSnap.data().students, quizData.topic, 'sync'); // ส่ง mode 'sync' เข้าไป
    
    // --- [ START: นี่คือส่วนที่แก้ไข Bug Listener ทับซ้อน ] ---
    
    // 1. ค้นหาปุ่มเดิม
    const oldBtn = document.getElementById('confirm-team-players-btn');
    
    // 2. โคลนปุ่ม (การโคลนจะลบ Event Listeners ทั้งหมดที่ติดมากับปุ่มเก่า)
    const newBtn = oldBtn.cloneNode(true);
    
    // 3. นำปุ่มใหม่ (ที่สะอาดแล้ว) ไปแทนที่ปุ่มเก่าในหน้าเว็บ
    oldBtn.parentNode.replaceChild(newBtn, oldBtn);
    
    // 4. ผูก Event Listener ที่ถูกต้อง (เพียงอันเดียว) ให้กับปุ่มใหม่
    newBtn.onclick = confirmAndJoinSyncGame; 
    
    // --- [ END: สิ้นสุดการแก้ไข ] ---

    messageModal.classList.add('hidden'); // ซ่อน pop-up "กำลังค้นหา"
}

function getCleanApplicationHTML() {
    const applicationContainer = document.getElementById('applicationContent');
    if (!applicationContainer) return '';

    // สร้างสำเนาของ Element ขึ้นมาในหน่วยความจำ เพื่อไม่ให้กระทบหน้าจอที่ผู้ใช้เห็นอยู่
    const clone = applicationContainer.cloneNode(true);

    // ค้นหาปุ่มตัวเลือกทั้งหมดในสำเนา แล้วล้างสถานะออก
    clone.querySelectorAll('.application-options button').forEach(button => {
        button.classList.remove('correct', 'incorrect');
        button.disabled = false;
    });

    // คืนค่าเป็น HTML ที่สะอาดแล้ว
    return clone.innerHTML;
}

function showTeamPlayerSelection(students, topic, mode = 'team') {
    studentInitialView.classList.add('hidden');
    studentJoinGameView.classList.add('hidden');
    document.getElementById('student-team-selection-view').classList.remove('hidden');

    // รีเซ็ตลำดับการเลือกทุกครั้งที่เปิดหน้านี้
    orderedPlayerSelection = [];

    let modeTitle = 'Team Quiz'; 
    if (mode === 'group') {
        modeTitle = 'Group Mode';
    } else if (mode === 'sync') {
        modeTitle = 'Sync Mode';
    }
    document.getElementById('team-quiz-topic').textContent = `${modeTitle}: ${topic}`;

    const listContainer = document.getElementById('team-student-list');
    if (!students || students.length === 0) {
        listContainer.innerHTML = '<p class="text-gray-500">โปรเจคนี้ยังไม่มีนักเรียน</p>';
        document.getElementById('confirm-team-players-btn').disabled = true;
        return;
    }

    // สร้างรายการพร้อม Badge สำหรับแสดงเลขลำดับ (ซ่อนไว้ก่อน)
    listContainer.innerHTML = students.map(name => `
        <label class="flex items-center justify-between p-3 rounded-md hover:bg-gray-100 cursor-pointer border border-transparent hover:border-gray-200 transition-all select-none">
            <div class="flex items-center">
                <input type="checkbox" name="team_player" value="${name}" class="h-5 w-5 rounded border-gray-300 text-cyan-600 focus:ring-cyan-500 mr-3">
                <span class="text-lg text-gray-700">${name}</span>
            </div>
            <span class="order-badge bg-indigo-600 text-white text-xs font-bold px-2 py-1 rounded-full hidden shadow-sm"></span>
        </label>
    `).join('');
    
    document.getElementById('confirm-team-players-btn').disabled = false;

    // เพิ่ม Event Listener ให้กับ Checkbox ทุกตัว
    const checkboxes = listContainer.querySelectorAll('input[name="team_player"]');
    checkboxes.forEach(cb => {
        cb.addEventListener('change', (e) => {
            const val = e.target.value;
            if (e.target.checked) {
                // ถ้าเลือก -> เพิ่มต่อท้ายในอาเรย์
                if (!orderedPlayerSelection.includes(val)) {
                    orderedPlayerSelection.push(val);
                }
            } else {
                // ถ้าเอาออก -> ลบออกจากอาเรย์
                orderedPlayerSelection = orderedPlayerSelection.filter(p => p !== val);
            }
            // อัปเดตตัวเลขลำดับบนหน้าจอ
            updateSelectionOrderVisuals(listContainer);
        });
    });
}

// ฟังก์ชันช่วยแสดงตัวเลขลำดับ
function updateSelectionOrderVisuals(container) {
    const checkboxes = container.querySelectorAll('input[name="team_player"]');
    checkboxes.forEach(cb => {
        const label = cb.closest('label');
        const badge = label.querySelector('.order-badge');
        
        if (cb.checked) {
            // หาว่าชื่อนี้อยู่อันดับที่เท่าไหร่ในอาเรย์
            const index = orderedPlayerSelection.indexOf(cb.value);
            if (index !== -1) {
                badge.textContent = `คนที่ ${index + 1}`;
                badge.classList.remove('hidden');
                // เปลี่ยนสีพื้นหลัง label ให้ดู active
                label.classList.add('bg-indigo-50', 'border-indigo-200');
            }
        } else {
            badge.classList.add('hidden');
            label.classList.remove('bg-indigo-50', 'border-indigo-200');
        }
    });
}

async function confirmAndStartTeamQuiz() {
    // ใช้รายชื่อจากตัวแปรที่เรียงลำดับไว้แล้ว
    const selectedPlayers = [...orderedPlayerSelection];

    if (selectedPlayers.length === 0) {
        showMessage("กรุณาเลือกผู้เล่นอย่างน้อย 1 คน");
        return;
    }
    
    // รีเซ็ตตัวนับทั้งหมด
    localTeamPlayers = selectedPlayers; // ลำดับในนี้จะกำหนดลำดับการเล่น
    localQuestionIndex = 0;
    localPlayerIndex = 0;
	
    const teamQuizRef = doc(db, `artifacts/${appId}/public/data/teamQuizzes`, currentTeamQuizId);
    try {
        const gameSnap = await getDoc(teamQuizRef);
        if (!gameSnap.exists()) throw new Error("ไม่พบข้อมูลเกม");
        const gameData = gameSnap.data();

        if (gameData.mode === 'group') {
            const groupPayload = { [`groups.${userId}`]: { members: localTeamPlayers, score: 0, answers: [] } };
            await updateDoc(teamQuizRef, groupPayload);
        } else {
            const initialResponses = gameData.responses || {};
            localTeamPlayers.forEach(name => {
                if (!initialResponses[name]) {
                    initialResponses[name] = { score: 0, answers: [] };
                }
            });
            await updateDoc(teamQuizRef, { responses: initialResponses });
        }
        
        document.getElementById('student-team-selection-view').classList.add('hidden');
        renderTeamQuizQuestion();
        
        const gameState = { gameId: currentTeamQuizId, mode: gameData.mode || 'team', players: localTeamPlayers, turnIndex: 0 };
        sessionStorage.setItem('activeGameSession', JSON.stringify(gameState));
        listenForTeamQuizUpdates();

    } catch (error) {
        console.error("Error confirming players:", error);
        showMessage("เกิดข้อผิดพลาดในการยืนยันผู้เล่น");
    }
}

// ▼▼▼ วางทับฟังก์ชัน renderTeamQuizQuestion ทั้งหมด ▼▼▼
async function renderTeamQuizQuestion() {
    // [แก้ไข] ตรวจสอบว่าทำครบทุกข้อหรือยัง
    if (localQuestionIndex >= currentQuizData.questions.length) {
        displayTeamQuizFinalResults();
        return;
    }
    
    // [แก้ไข] ดึงข้อมูลคำถามและผู้เล่นตามรอบปัจจุบัน
    const q = currentQuizData.questions[localQuestionIndex];
    const currentPlayerName = localTeamPlayers[localPlayerIndex];
    const questionType = q.questionType || currentQuizData.quizType;
    let questionTextHTML = q.stem || q.questionText;
    let optionsHTML = '';

    // (ส่วน switch case สำหรับสร้าง options เหมือนเดิม)
    switch (questionType) {
        case 'multiple_choice': case 'fill_in_with_choices':
            optionsHTML = q.options.map((opt, i) => `<div><input type="radio" id="team_opt${i}" name="team_answer" value="${i}" class="mr-2 accent-cyan-600" required><label for="team_opt${i}">${opt}</label></div>`).join('');
            break;
        case 'true_false':
            optionsHTML = `<div><input type="radio" id="team_opt_true" name="team_answer" value="true" class="mr-2 accent-cyan-600" required><label for="team_opt_true">ใช่ / ถูก</label></div><div><input type="radio" id="team_opt_false" name="team_answer" value="false" class="mr-2 accent-cyan-600" required><label for="team_opt_false">ไม่ใช่ / ผิด</label></div>`;
            break;
        case 'short_answer': case 'fill_in_no_choices':
            optionsHTML = `<textarea name="team_answer" class="w-full p-2 border border-gray-300 rounded-lg" rows="3" required placeholder="พิมพ์คำตอบของคุณ..."></textarea>`;
            break;
        case 'matching_item':
            optionsHTML = `<select name="team_answer" class="w-full p-2 border border-gray-300 rounded-lg" required><option value="">-- เลือกคำตอบที่คู่กัน --</option>${q.allResponses.map(resp => `<option value="${resp}">${resp}</option>`).join('')}</select>`;
            break;
        default:
            optionsHTML = '<p class="text-red-500">ไม่รู้จักประเภทของคำถามนี้</p>';
            break;
    }

    studentQuizArea.innerHTML = `
        <div class="p-4 fade-in">
            <p class="text-sm text-gray-500 text-center">ข้อที่ ${localQuestionIndex + 1} / ${currentQuizData.questions.length}</p>
            <p class="text-2xl font-bold text-center text-cyan-700 my-2">ตาของ: ${currentPlayerName}</p>
            <div class="my-4 p-4 border rounded-lg bg-gray-50">
                <div class="font-semibold mb-3">
                    <p>${localQuestionIndex + 1}. ${questionTextHTML}</p>
                    ${q.imageCode ? `<div class="my-4 flex justify-center">${q.imageCode}</div>` : ''}
                </div>
                <div class="space-y-2 text-lg">${optionsHTML}</div>
            </div>
            <button id="submit-team-answer-btn" class="w-full bg-cyan-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-cyan-700">ส่งคำตอบ</button>
        </div>
    `;
    studentQuizArea.classList.remove('hidden');
    if (window.MathJax) MathJax.typesetPromise([studentQuizArea]);
    
    // เราจะใช้ handleTeamAnswerSubmit สำหรับทั้ง Team และ Group Mode เพราะ Group Mode มี Logic แยกอยู่ข้างในแล้ว
    document.getElementById('submit-team-answer-btn').addEventListener('click', handleTeamAnswerSubmit);
}

// ▼▼▼ วางทับฟังก์ชัน handleGroupAnswerSubmit ทั้งหมด ▼▼▼
async function handleGroupAnswerSubmit() {
    const q = currentQuizData.questions[localQuestionIndex];
    const questionType = q.questionType || currentQuizData.quizType;
    let userAnswer = null;
    let isCorrect = false;

    if (questionType === 'short_answer' || questionType === 'fill_in_no_choices') {
        const textarea = document.querySelector('textarea[name="team_answer"]');
        if (!textarea || !textarea.value.trim()) { showMessage("กรุณาพิมพ์คำตอบของกลุ่ม"); return; }
        userAnswer = textarea.value.trim();
        isCorrect = await gradeShortAnswer(userAnswer, q);
    } else {
        const selectedInput = document.querySelector('[name="team_answer"]:checked, select[name="team_answer"]');
        if (!selectedInput || selectedInput.value === "") { showMessage("กรุณาเลือกคำตอบของกลุ่ม"); return; }
        userAnswer = selectedInput.value;
        switch(questionType) {
            case 'true_false': isCorrect = ((userAnswer === 'true') === q.correctAnswer); break;
            case 'matching_item': isCorrect = (userAnswer === q.correctResponse); break;
            default: isCorrect = (parseInt(userAnswer) === q.correctAnswerIndex); break;
        }
    }

    const answerRecord = { questionIndex: localQuestionIndex, isCorrect: isCorrect };
    const groupId = userId;
    const updatePayload = {
        [`groups.${groupId}.answers`]: arrayUnion(answerRecord)
    };
    if (isCorrect) {
        updatePayload[`groups.${groupId}.score`] = increment(1);
    }
    
    try {
        await updateDoc(doc(db, `artifacts/${appId}/public/data/teamQuizzes`, currentTeamQuizId), updatePayload);
        
        // [แก้ไข] เปลี่ยนไปใช้ตัวแปรกลาง และเรียกฟังก์ชันที่ถูกต้อง
        localQuestionIndex++;
        
        if (localQuestionIndex >= currentQuizData.questions.length) {
            displayTeamQuizFinalResults();
        } else {
            renderGroupModeQuestion(); // เรียกฟังก์ชันแสดงผลสำหรับ Group Mode โดยเฉพาะ
        }
        
    } catch(error) {
        console.error("Error submitting group answer:", error);
        showMessage("เกิดข้อผิดพลาดในการส่งคำตอบ");
    }
}


// ▼▼▼ วางทับฟังก์ชัน handleTeamAnswerSubmit ทั้งหมด ▼▼▼
async function handleTeamAnswerSubmit() {
    const gameSnap = await getDoc(doc(db, `artifacts/${appId}/public/data/teamQuizzes`, currentTeamQuizId));
    if (!gameSnap.exists()) return;
    const gameData = gameSnap.data();

    // ถ้าเป็น Group Mode ให้ไปใช้ Logic เดิมของ Group Mode
    if (gameData.mode === 'group') {
        handleGroupAnswerSubmit();
        return;
    }

    // --- Logic ใหม่สำหรับ Team Mode (ทุกคนตอบทุกข้อ) ---
    const currentPlayerName = localTeamPlayers[localPlayerIndex];
    const q = currentQuizData.questions[localQuestionIndex];
    const questionType = q.questionType || currentQuizData.quizType;
    let userAnswer = null;
    let isCorrect = false;

    // (ส่วนตรวจคำตอบเหมือนเดิม)
    if (questionType === 'short_answer' || questionType === 'fill_in_no_choices') {
        const textarea = document.querySelector('textarea[name="team_answer"]');
        if (!textarea || !textarea.value.trim()) { showMessage("กรุณาพิมพ์คำตอบ"); return; }
        userAnswer = textarea.value.trim();
        isCorrect = await gradeShortAnswer(userAnswer, q); 
    } else {
        const selectedInput = document.querySelector('[name="team_answer"]:checked, select[name="team_answer"]');
        if (!selectedInput || selectedInput.value === "") { showMessage("กรุณาเลือกคำตอบ"); return; }
        userAnswer = selectedInput.value;
        switch(questionType) {
            case 'true_false': isCorrect = ((userAnswer === 'true') === q.correctAnswer); break;
            case 'matching_item': isCorrect = (userAnswer === q.correctResponse); break;
            default: isCorrect = (parseInt(userAnswer) === q.correctAnswerIndex); break;
        }
    }

    const answerRecord = { questionIndex: localQuestionIndex, isCorrect: isCorrect, answerValue: userAnswer };
    const updatePayload = { [`responses.${currentPlayerName}.answers`]: arrayUnion(answerRecord) };
    if (isCorrect) {
        updatePayload[`responses.${currentPlayerName}.score`] = increment(1);
    }
    
    try {
        await updateDoc(doc(db, `artifacts/${appId}/public/data/teamQuizzes`, currentTeamQuizId), updatePayload);
        
        // [แก้ไข] เลื่อนไปยังผู้เล่นคนถัดไป
        localPlayerIndex++;

        if (localPlayerIndex >= localTeamPlayers.length) {
            // เมื่อทุกคนตอบข้อนี้ครบแล้ว ให้ขึ้นข้อใหม่ และรีเซ็ตคนตอบเป็นคนแรก
            localQuestionIndex++;
            localPlayerIndex = 0;
        }
        
        renderTeamQuizQuestion(); // แสดงผลใหม่ (อาจจะเป็นคนถัดไปในข้อเดิม หรือคนแรกในข้อใหม่)

    } catch(error) {
        console.error("Error submitting team answer:", error);
        showMessage("เกิดข้อผิดพลาดในการส่งคำตอบ");
    }
}

// ▼▼▼ วางทับฟังก์ชัน displayTeamQuizFinalResults เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
/**
 * แสดงหน้าสรุปผลสุดท้าย (เวอร์ชันแก้ไข: Group Mode แสดงผลเฉพาะกลุ่มตัวเอง)
 */
async function displayTeamQuizFinalResults() {
    studentQuizArea.classList.add('hidden');
    studentResultArea.classList.remove('hidden');

    const teamQuizRef = doc(db, `artifacts/${appId}/public/data/teamQuizzes`, currentTeamQuizId);
    const docSnap = await getDoc(teamQuizRef);
    if (!docSnap.exists()) {
        studentResultArea.innerHTML = `<p class="p-4 text-center text-red-500">ไม่พบข้อมูลเกม อาจสิ้นสุดไปแล้ว</p>`;
        return;
    }
    const gameData = docSnap.data();

    let finalScores = [];
    const mode = gameData.mode || 'team';

    // --- [START] ส่วนที่แก้ไข ---
    if (mode === 'group') {
        // Logic for Group Mode: แสดงผลเฉพาะคะแนนของกลุ่มตัวเอง
        const myGroupData = gameData.groups[userId]; // userId คือ ID ของเครื่องนี้
        if (myGroupData) {
            finalScores = [{
                name: `กลุ่ม: ${localTeamPlayers.join(', ')}`, // ใช้ localTeamPlayers ที่เก็บชื่อผู้เล่นในเครื่องนี้
                score: myGroupData.score || 0
            }];
        } else {
            // กรณีฉุกเฉิน หากหาข้อมูลกลุ่มตัวเองไม่เจอ
            finalScores = [{ name: 'กลุ่มของคุณ', score: 'N/A' }];
        }
    } else {
        // Logic for Team Mode (ของเดิม)
        finalScores = localTeamPlayers.map(name => ({
            name: name,
            score: gameData.responses[name]?.score || 0
        })).sort((a, b) => b.score - a.score);
    }
    // --- [END] สิ้นสุดส่วนที่แก้ไข ---
    
    studentResultArea.innerHTML = `
        <div class="text-center p-8 bg-cyan-100 rounded-lg">
            <h3 class="text-2xl font-bold text-cyan-800">จบกิจกรรมแล้ว!</h3>
            <p class="mt-4">สรุปคะแนน:</p>
            <div class="space-y-2 mt-2 max-w-sm mx-auto">
                ${finalScores.map(res => `
                    <div class="flex justify-between text-lg p-2 bg-white/50 rounded-md">
                        <strong>${res.name}</strong>
                        <span>${res.score} คะแนน</span>
                    </div>
                `).join('')}
            </div>
            <button onclick="window.location.reload()" class="mt-6 bg-blue-600 text-white py-2 px-5 rounded-lg">กลับหน้าแรก</button>
        </div>
    `;
    
	sessionStorage.removeItem('activeGameSession');

    if (currentMode === 'admin' && currentTeamQuizId) {
        setTimeout(() => {
            deleteDoc(doc(db, `artifacts/${appId}/public/data/teamQuizzes`, currentTeamQuizId));
        }, 300000);
    }
}
		
		let history = [];
let historyStep = -1;
		let modalConfirmAction = null; // ตัวแปรสำหรับเก็บ "คำสั่งพิเศษ" ที่จะให้ปุ่ม "ตกลง" ทำงาน
		let cheatAttempts = 0;
		let cheatDetectionTimeout = null;
const maxCheatAttempts = 3; // กำหนดจำนวนครั้งที่อนุญาตให้ออกจากจอ (ปรับแก้ได้)
let isQuizActive = false; // ตัวแปรสำหรับเช็คว่ากำลังทำข้อสอบอยู่หรือไม่
		
		let globalDashboardSettings = {
    projectSort: 'date_desc', // ค่าเริ่มต้น
    pinnedProjects: [],      // ค่าเริ่มต้น
	projectView: 'grid' // <-- เพิ่มบรรทัดนี้
};
		
		// =====================================================================
// === โค้ดสำหรับจัดการ Dropdown เจาะจงหัวข้อคณิตศาสตร์ ===
// =====================================================================

// 1. โครงสร้างข้อมูลหัวข้อทั้งหมด
const allMathTopics = [
    // จำนวนและการดำเนินการ
    { category: 'จำนวนและการดำเนินการ', name: 'การนับ' },
    { category: 'จำนวนและการดำเนินการ', name: 'ระบบเลขและค่าประจำหลัก' },
    { category: 'จำนวนและการดำเนินการ', name: 'การปัดเศษและประมาณค่า' },
    { category: 'จำนวนและการดำเนินการ', name: 'ลำดับการดำเนินการ (PEMDAS)' },
    { category: 'จำนวนและการดำเนินการ', name: 'การบวก' },
    { category: 'จำนวนและการดำเนินการ', name: 'การลบ' },
    { category: 'จำนวนและการดำเนินการ', name: 'การคูณ' },
    { category: 'จำนวนและการดำเนินการ', name: 'การหาร' },
    { category: 'จำนวนและการดำเนินการ', name: 'จำนวนเต็มบวก' },
    { category: 'จำนวนและการดำเนินการ', name: 'จำนวนเต็มลบ' },
    { category: 'จำนวนและการดำเนินการ', name: 'ศูนย์' },
    { category: 'จำนวนและการดำเนินการ', name: 'ค่าสัมบูรณ์' },
    { category: 'จำนวนและการดำเนินการ', name: 'เส้นจำนวน' },
    { category: 'จำนวนและการดำเนินการ', name: 'ตัวประกอบและตัวประกอบเฉพาะ' },
    { category: 'จำนวนและการดำเนินการ', name: 'ห.ร.ม. (GCD)' },
    { category: 'จำนวนและการดำเนินการ', name: 'ค.ร.น. (LCM)' },
    { category: 'จำนวนและการดำเนินการ', name: 'อัตราส่วนและสัดส่วน' },
    { category: 'จำนวนและการดำเนินการ', name: 'อัตราและอัตราหน่วย' },
    { category: 'จำนวนและการดำเนินการ', name: 'เศษส่วน (ย่อ/ขยาย)' },
    { category: 'จำนวนและการดำเนินการ', name: 'การบวกเศษส่วน' },
    { category: 'จำนวนและการดำเนินการ', name: 'การลบเศษส่วน' },
    { category: 'จำนวนและการดำเนินการ', name: 'การคูณเศษส่วน' },
    { category: 'จำนวนและการดำเนินการ', name: 'การหารเศษส่วน' },
    { category: 'จำนวนและการดำเนินการ', name: 'จำนวนคละ' },
    { category: 'จำนวนและการดำเนินการ', name: 'ทศนิยม (ค่าประจำหลัก)' },
    { category: 'จำนวนและการดำเนินการ', name: 'การบวกทศนิยม' },
    { category: 'จำนวนและการดำเนินการ', name: 'การลบทศนิยม' },
    { category: 'จำนวนและการดำเนินการ', name: 'การคูณทศนิยม' },
    { category: 'จำนวนและการดำเนินการ', name: 'การหารทศนิยม' },
    { category: 'จำนวนและการดำเนินการ', name: 'แปลง เศษส่วน↔ทศนิยม↔ร้อยละ' },
    { category: 'จำนวนและการดำเนินการ', name: 'ร้อยละพื้นฐาน' },
    { category: 'จำนวนและการดำเนินการ', name: 'ปรับเพิ่ม/ลดเป็นร้อยละ' },
    { category: 'จำนวนและการดำเนินการ', name: 'ส่วนลด ภาษี กำไร ขาดทุน' },
    { category: 'จำนวนและการดำเนินการ', name: 'เลขยกกำลัง (กฎ/ศูนย์/ลบ)' },
    { category: 'จำนวนและการดำเนินการ', name: 'รากที่สองและที่สาม' },
    { category: 'จำนวนและการดำเนินการ', name: 'รูปสแควร์รูท (surd)' },
    { category: 'จำนวนและการดำเนินการ', name: 'สัญกรณ์วิทยาศาสตร์' },
    // การวัด
    { category: 'การวัด', name: 'หน่วยความยาวและการแปลง' },
    { category: 'การวัด', name: 'หน่วยมวล/น้ำหนักและการแปลง' },
    { category: 'การวัด', name: 'หน่วยเวลาและการคำนวณเวลา' },
    { category: 'การวัด', name: 'ปริมาตร/ความจุและการแปลง' },
    { category: 'การวัด', name: 'อุณหภูมิและการแปลง' },
    { category: 'การวัด', name: 'เส้นรอบรูป' },
    { category: 'การวัด', name: 'พื้นที่สี่เหลี่ยม' },
    { category: 'การวัด', name: 'พื้นที่สามเหลี่ยม' },
    { category: 'การวัด', name: 'พื้นที่วงกลม/ส่วนของวงกลม' },
    { category: 'การวัด', name: 'พื้นที่ผิวรูปทรงสามมิติ' },
    { category: 'การวัด', name: 'ปริมาตรรูปทรงสามมิติ' },
    { category: 'การวัด', name: 'มุมและการวัดมุม' },
    { category: 'การวัด', name: 'สเกลและแผนที่' },
    { category: 'การวัด', name: 'ค่าคลาดเคลื่อนของการวัด' },
    // เรขาคณิต
    { category: 'เรขาคณิต', name: 'จุด เส้น ระนาบ' },
    { category: 'เรขาคณิต', name: 'ความสัมพันธ์ของมุม' },
    { category: 'เรขาคณิต', name: 'สามเหลี่ยม (ชนิด/สมบัติ)' },
    { category: 'เรขาคณิต', name: 'พื้นที่สามเหลี่ยม' },
    { category: 'เรขาคณิต', name: 'ความเท่ากันทุกประการของสามเหลี่ยม' },
    { category: 'เรขาคณิต', name: 'ความคล้ายของรูป' },
    { category: 'เรขาคณิต', name: 'รูปสี่เหลี่ยมและสมบัติ' },
    { category: 'เรขาคณิต', name: 'รูปหลายเหลี่ยมและมุมภายใน' },
    { category: 'เรขาคณิต', name: 'วงกลม: คอร์ดและเส้นสัมผัส' },
    { category: 'เรขาคณิต', name: 'วงกลม: มุมที่ศูนย์กลาง/บนวงกลม' },
    { category: 'เรขาคณิต', name: 'วงกลม: ส่วนโค้ง เซกเตอร์ เซกเมนต์' },
    { category: 'เรขาคณิต', name: 'การแปลงทางเรขาคณิต (เลื่อน/หมุน/สะท้อน/ขยาย)' },
    { category: 'เรขาคณิต', name: 'สมมาตร (แกน/จุด)' },
    { category: 'เรขาคณิต', name: 'การสร้างรูปด้วยวงเวียน–สันตรง' },
    { category: 'เรขาคณิต', name: 'ทฤษฎีบทพีทาโกรัสและการประยุกต์' },
    // พีชคณิตและฟังก์ชัน
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ตัวแปรและนิพจน์' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'การกระจายและการจัดหมู่' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'พหุนาม (บวก/ลบ/คูณ/หาร)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'การแยกตัวประกอบ' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'สมการเชิงเส้นตัวแปรเดียว' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ระบบสมการเชิงเส้นสองตัวแปร' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'สมการกำลังสอง (ทำให้เป็นกำลังสองสมบูรณ์)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'สมการกำลังสอง (ใช้สูตรกำลังสอง)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'สมการค่าสัมบูรณ์' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'สมการเหตุผล (rational)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'สมการราก (radical)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'สมการยกกำลัง' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'สมการลอการิทึม' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'อสมการเชิงเส้น' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'อสมการค่าสัมบูรณ์' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ระบบอสมการ' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชัน: แนวคิดและสัญกรณ์' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'โดเมนและเรนจ์' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'องค์ประกอบของฟังก์ชัน' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันผกผัน' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'การแปลงกราฟ (เลื่อน/ยืด/สะท้อน)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันเชิงเส้นและกราฟ' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันกำลังสองและกราฟ' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันพหุนาม' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันสัมพัทธ์ (rational)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันราก (root)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันค่าสัมบูรณ์' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันแบบชิ้นส่วน' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันยกกำลัง' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ฟังก์ชันลอการิทึม' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ลำดับเลขคณิต (AP)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ลำดับเรขาคณิต (GP)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ผลรวมอนุกรม (Σ)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'ทฤษฎีทวินาม (เบื้องต้น)' },
    { category: 'พีชคณิตและฟังก์ชัน', name: 'จำนวนเชิงซ้อน (เสริม)' },
    // เรขาคณิตวิเคราะห์
    { category: 'เรขาคณิตวิเคราะห์', name: 'ระยะทางและจุดกึ่งกลาง' },
    { category: 'เรขาคณิตวิเคราะห์', name: 'ความชันและเส้นตรง' },
    { category: 'เรขาคณิตวิเคราะห์', name: 'เส้นตรง: รูปแบบสมการ' },
    { category: 'เรขาคณิตวิเคราะห์', name: 'เส้นตรง: ขนาน/ตั้งฉาก' },
    { category: 'เรขาคณิตวิเคราะห์', name: 'ระยะจากจุดถึงเส้นตรง' },
    { category: 'เรขาคณิตวิเคราะห์', name: 'วงกลม: สมการและสมบัติ' },
    { category: 'เรขาคณิตวิเคราะห์', name: 'พาราโบลา' },
    { category: 'เรขาคณิตวิเคราะห์', name: 'วงรี' },
    { category: 'เรขาคณิตวิเคราะห์', name: 'ไฮเพอร์โบลา' },
    // ตรีโกณมิติ
    { category: 'ตรีโกณมิติ', name: 'อัตราส่วนตรีโกณมิติในสามเหลี่ยมมุมฉาก' },
    { category: 'ตรีโกณมิติ', name: 'มุมพิเศษ 30°-60°-90°' },
    { category: 'ตรีโกณมิติ', name: 'มุมพิเศษ 45°-45°-90°' },
    { category: 'ตรีโกณมิติ', name: 'เรเดียนและการแปลงหน่วย' },
    { category: 'ตรีโกณมิติ', name: 'กฎของไซน์' },
    { category: 'ตรีโกณมิติ', name: 'กฎของโคไซน์' },
    { category: 'ตรีโกณมิติ', name: 'อัตลักษณ์ตรีโกณมิติ (พื้นฐาน)' },
    { category: 'ตรีโกณมิติ', name: 'การแปลงรูปอัตลักษณ์' },
    { category: 'ตรีโกณมิติ', name: 'สมการตรีโกณมิติ' },
    { category: 'ตรีโกณมิติ', name: 'กราฟฟังก์ชันตรีโกณ' },
    { category: 'ตรีโกณมิติ', name: 'ฟังก์ชันตรีโกณผกผัน (พื้นฐาน)' },
    // สถิติและความน่าจะเป็น
    { category: 'สถิติและความน่าจะเป็น', name: 'ชนิดของข้อมูลและการเก็บข้อมูล' },
    { category: 'สถิติและความน่าจะเป็น', name: 'การจัดกลุ่มข้อมูล' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ตารางความถี่' },
    { category: 'สถิติและความน่าจะเป็น', name: 'กราฟแท่ง กราฟเส้น' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ฮิสโตแกรม' },
    { category: 'สถิติและความน่าจะเป็น', name: 'แผนภาพกล่อง (box plot)' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ค่าเฉลี่ย' },
    { category: 'สถิติและความน่าจะเป็น', name: 'มัธยฐาน' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ฐานนิยม' },
    { category: 'สถิติและความน่าจะเป็น', name: 'พิสัย' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ส่วนเบี่ยงเบนเฉลี่ย' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ความแปรปรวน' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ส่วนเบี่ยงเบนมาตรฐาน' },
    { category: 'สถิติและความน่าจะเป็น', name: 'การแจกแจงปกติและ z-score' },
    { category: 'สถิติและความน่าจะเป็น', name: 'สหสัมพันธ์และเส้นถดถอยเชิงเส้น' },
    { category: 'สถิติและความน่าจะเป็น', name: 'การทดลองสุ่ม/พื้นที่ตัวอย่าง/เหตุการณ์' },
    { category: 'สถิติและความน่าจะเป็น', name: 'กฎบวกและกฎคูณ' },
    { category: 'สถิติและความน่าจะเป็น', name: 'แผนภาพเวนน์' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ความน่าจะเป็นแบบมีเงื่อนไข' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ความเป็นอิสระของเหตุการณ์' },
    { category: 'สถิติและความน่าจะเป็น', name: 'การเรียงสับเปลี่ยน (Permutation)' },
    { category: 'สถิติและความน่าจะเป็น', name: 'การจัดหมู่ (Combination)' },
    { category: 'สถิติและความน่าจะเป็น', name: 'การแจกแจงทวินาม (พื้นฐาน)' },
    { category: 'สถิติและความน่าจะเป็น', name: 'ความคาดหมาย (Expected value)' },
    // แคลคูลัสเบื้องต้น
    { category: 'แคลคูลัสเบื้องต้น', name: 'ลิมิต' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'ความต่อเนื่อง' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'อนุพันธ์: กฎพื้นฐาน' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'อนุพันธ์: กฎลูกโซ่' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'อนุพันธ์: ผลคูณ/ผลหาร' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'อนุพันธ์ของ exp/log/trig (พื้นฐาน)' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'ความชันเส้นสัมผัส' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'อัตราการเปลี่ยนแปลงทันที' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'Optimization (ค่าสูงสุด–ต่ำสุด)' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'ปริพันธ์ไม่จำกัด' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'ปริพันธ์จำกัด' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'ทฤษฎีบทพื้นฐานของแคลคูลัส' },
    { category: 'แคลคูลัสเบื้องต้น', name: 'พื้นที่ใต้กราฟ/ระหว่างกราฟ' },
    // เวกเตอร์และเมทริกซ์ (เสริม)
    { category: 'เวกเตอร์และเมทริกซ์ (เสริม)', name: 'เวกเตอร์ 2 มิติ: บวก/คูณสเกลาร์' },
    { category: 'เวกเตอร์และเมทริกซ์ (เสริม)', name: 'ดอทโปรดักต์ (dot)' },
    { category: 'เวกเตอร์และเมทริกซ์ (เสริม)', name: 'การประยุกต์เวกเตอร์พื้นฐาน' },
    { category: 'เวกเตอร์และเมทริกซ์ (เสริม)', name: 'เมทริกซ์: บวก/คูณ' },
    { category: 'เวกเตอร์และเมทริกซ์ (เสริม)', name: 'อินเวอร์สของเมทริกซ์' },
    { category: 'เวกเตอร์และเมทริกซ์ (เสริม)', name: 'ดีเทอร์มิแนนต์' },
    { category: 'เวกเตอร์และเมทริกซ์ (เสริม)', name: 'แก้ระบบสมการด้วยเมทริกซ์' },
    // คณิตการเงิน/บูรณาการ
    { category: 'คณิตการเงิน/บูรณาการ', name: 'ดอกเบี้ยอย่างง่าย' },
    { category: 'คณิตการเงิน/บูรณาการ', name: 'ดอกเบี้ยทบต้น' },
    { category: 'คณิตการเงิน/บูรณาการ', name: 'เงินงวด (อนุกรมเงินงวด)' },
    { category: 'คณิตการเงิน/บูรณาการ', name: 'ค่าเสื่อมราคา' },
    { category: 'คณิตการเงิน/บูรณาการ', name: 'ร้อยละประยุกต์' },
    // ตรรกะ/ทักษะการพิสูจน์ (เสริม)
    { category: 'ตรรกะ/ทักษะการพิสูจน์ (เสริม)', name: 'ค่าความจริง/ตารางค่าความจริง' },
    { category: 'ตรรกะ/ทักษะการพิสูจน์ (เสริม)', name: 'รูปแบบการให้เหตุผล' },
    { category: 'ตรรกะ/ทักษะการพิสูจน์ (เสริม)', name: 'พิสูจน์เชิงตรง/อุปนัย (พื้นฐาน)' },
];

// 2. ฟังก์ชันสำหรับสร้าง Dropdown
// === แทนที่ฟังก์ชัน renderTopicRefineDropdown เดิมด้วยฟังก์ชันนี้ ===
// === แทนที่ฟังก์ชัน renderTopicCheckboxes เดิมด้วยฟังก์ชันนี้ ===
function renderTopicCheckboxes() {
    const container = document.getElementById('math-topics-checkbox-container');
    if (!container) return;

    const standardTopics = allMathTopics;
    const userCreatedTopics = customMathTopics.map(t => ({ id: t.id, category: 'หัวข้อที่สร้างเอง', name: t.name }));
    const combinedTopics = [...standardTopics, ...userCreatedTopics];
    
    const topicsByCategory = combinedTopics.reduce((acc, topic) => {
        if (!acc[topic.category]) {
            acc[topic.category] = [];
        }
        acc[topic.category].push(topic);
        return acc;
    }, {});

    let html = '';
    const categoryOrder = ['หัวข้อที่สร้างเอง', ...Object.keys(topicsByCategory).filter(c => c !== 'หัวข้อที่สร้างเอง')];

    for (const category of categoryOrder) {
        if (topicsByCategory[category]) {
            const isCustomCategory = category === 'หัวข้อที่สร้างเอง';
            const categoryIcon = isCustomCategory ? 'fas fa-user-edit' : 'fas fa-bookmark';
            const categoryColor = isCustomCategory ? 'text-blue-700' : 'text-indigo-700';

            html += `<div class="mb-3 topic-category">`; // ▼▼▼ แก้ไข: เพิ่ม class `topic-category` ▼▼▼
            html += `<p class="font-bold text-sm ${categoryColor} border-b mb-1 pb-1"><i class="${categoryIcon} mr-2"></i>${category}</p>`;

            topicsByCategory[category].forEach(topic => {
                // ▼▼▼ ส่วนที่แก้ไข: สร้างโครงสร้างที่เหมือนกันสำหรับทุกหัวข้อ ▼▼▼
                const isCustom = !!topic.id; // ตรวจสอบว่าเป็นหัวข้อที่สร้างเองหรือไม่

                const actionButtons = isCustom ? `
                    <div class="topic-actions-view flex items-center">
                        <button data-id="${topic.id}" class="edit-custom-topic-btn text-gray-400 hover:text-blue-600 p-1 rounded-full text-xs">
                            <i class="fas fa-pencil-alt pointer-events-none"></i>
                        </button>
                        <button data-id="${topic.id}" class="delete-custom-topic-btn text-gray-400 hover:text-red-600 p-1 rounded-full text-xs">
                            <i class="fas fa-trash-alt pointer-events-none"></i>
                        </button>
                    </div>
                    <div class="topic-actions-edit hidden flex items-center">
                        <button data-id="${topic.id}" class="save-custom-topic-btn text-gray-400 hover:text-green-600 p-1 rounded-full text-xs">
                            <i class="fas fa-check pointer-events-none"></i>
                        </button>
                        <button data-id="${topic.id}" class="cancel-edit-topic-btn text-gray-400 hover:text-gray-800 p-1 rounded-full text-xs">
                            <i class="fas fa-times pointer-events-none"></i>
                        </button>
                    </div>
                ` : '';

                html += `
                <div class="flex items-center justify-between p-1 hover:bg-gray-100 rounded-md group topic-row" data-topic-container-id="${topic.id || ''}">
                    <label class="flex items-center space-x-2 cursor-pointer flex-grow">
                        <input type="checkbox" name="math_topic" value="${topic.name}" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                        <span class="text-sm topic-name-display">${topic.name}</span>
                        ${isCustom ? `<input type="text" class="topic-name-input hidden w-full text-sm p-1 border rounded" value="${topic.name}">` : ''}
                    </label>
                    ${actionButtons}
                </div>
                `;
                // ▲▲▲ สิ้นสุดส่วนที่แก้ไข ▲▲▲
            });
            html += `</div>`;
        }
    }

    container.innerHTML = html || '<p class="text-gray-400">ยังไม่มีหัวข้อ</p>';
    container.removeEventListener('change', updateSelectedTopicsCount);
    container.addEventListener('change', updateSelectedTopicsCount);
}

/**
 * จัดการการอัปเดตชื่อหัวข้อที่ผู้ใช้สร้างเอง
 * @param {string} topicId - ID ของเอกสารหัวข้อใน Firestore
 * @param {string} newName - ชื่อใหม่ที่ต้องการบันทึก
 */
async function handleUpdateCustomTopic(topicId, newName) {
    if (!topicId || !newName.trim()) {
        showMessage("ชื่อหัวข้อห้ามว่าง");
        return;
    }

    try {
        const topicRef = doc(db, `artifacts/${appId}/public/data/customMathTopics`, topicId);
        await updateDoc(topicRef, { name: newName.trim() });
        showMessage("แก้ไขหัวข้อสำเร็จ");
        // onSnapshot จะ re-render ให้อัตโนมัติ ซึ่งจะทำให้ UI กลับเป็นโหมดปกติเอง
    } catch (error) {
        console.error("Error updating custom topic:", error);
        showMessage("เกิดข้อผิดพลาดในการแก้ไขหัวข้อ");
    }
}

/**
 * สลับ UI ระหว่างโหมดแสดงผลและโหมดแก้ไขสำหรับหัวข้อ
 * @param {HTMLElement} topicContainer - Element div หลักของหัวข้อที่ต้องการสลับ
 * @param {boolean} isEditing - true เพื่อเข้าโหมดแก้ไข, false เพื่อออกจากโหมดแก้ไข
 */
function toggleTopicEditMode(topicContainer, isEditing) {
    if (!topicContainer) return;

    const nameDisplay = topicContainer.querySelector('.topic-name-display');
    const nameInput = topicContainer.querySelector('.topic-name-input');
    const viewActions = topicContainer.querySelector('.topic-actions-view');
    const editActions = topicContainer.querySelector('.topic-actions-edit');

    nameDisplay.classList.toggle('hidden', isEditing);
    nameInput.classList.toggle('hidden', !isEditing);
    viewActions.classList.toggle('hidden', isEditing);
    editActions.classList.toggle('hidden', !isEditing);

    if (isEditing) {
        nameInput.focus();
        nameInput.select();
    }
}

async function handleStartLiveRace(quizId) {
    // 1) หา quiz จากหน้าปัจจุบันก่อน (กรณีอยู่ในหน้าโปรเจค)
    let quiz = allQuizzes.find(q => q.id === quizId);

    // 2) ถ้าไม่เจอ (เช่น กดจาก Dashboard) ให้ดึงเอกสาร quiz ตรงๆ
    if (!quiz) {
    const qref = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
    const qsnap = await getDoc(qref);
    if (!qsnap.exists()) {
        showMessage("ไม่พบข้อมูลแบบทดสอบ");
        return;
    }
    quiz = { id: qsnap.id, ...qsnap.data() };
    }

    // --- [START] ส่วนที่แก้ไขที่สำคัญที่สุด ---
    // 3. ทำการสลับข้อสอบ *เพียงครั้งเดียว* ที่นี่
    const shuffledQuizForGame = getShuffledQuiz(quiz);

    // 4. ตั้งค่า currentQuizData ของ Admin ทันที
    currentQuizData = shuffledQuizForGame;
    // --- [END] สิ้นสุดการแก้ไข ---

    // ใช้ projectId ของ quiz (ถ้ามี) เพื่อผูกข้อมูลให้ถูกโปรเจค
    const projectIdForGame = quiz.projectId || currentProjectId || null;

    // สร้างห้องเกม
    const gamePin = Math.floor(1000 + Math.random() * 9000).toString();
    currentLiveGamePin = gamePin;

    try {
    const gameRef = await addDoc(collection(db, `artifacts/${appId}/public/data/liveGames`), {
        quizId,
        projectId: projectIdForGame,
        status: "lobby",
        currentQuestionIndex: -1,
        players: {},
        gamePin,
        createdAt: serverTimestamp(),
        // 5. [เพิ่ม] บันทึกข้อสอบที่สลับแล้วทั้งชุดลงใน Document ของเกม
        shuffledQuiz: shuffledQuizForGame 
    });

    currentLiveGameId = gameRef.id;
    showAdminLobbyView(gamePin, quiz.topic);
    listenForLiveGameUpdates();
    } catch (err) {
    console.error("Error starting live race:", err);
    showMessage("เกิดข้อผิดพลาดในการสร้างห้องเกม");
    }
}

function updateSelectedTopicsCount() {
    const container = document.getElementById('math-topics-checkbox-container');
    const count = container.querySelectorAll('input[type="checkbox"]:checked').length;
    const countEl = document.getElementById('selected-topics-count');
    if (count > 0) {
        countEl.textContent = `(เลือกแล้ว ${count} หัวข้อ)`;
    } else {
        countEl.textContent = '';
    }
}
// =====================================================================
		
		const sarabunBase64 = '';
        let db, auth, userId;
		let customMathTopics = []; //  <-- เพิ่มบรรทัดนี้
        let currentMode = 'student'; // 'student', 'admin', or 'admin-testing'
        let currentProjectId = null;
        let currentProjectData = null;
        let currentQuizData = null;
        let currentDisplayedQuiz = null; // Holds the potentially shuffled quiz for the student
		let currentSubmissions = []; // สำหรับเก็บข้อมูลการส่งงานล่าสุด
let quizLeaderboardSortBy = 'bestScore'; // คอลัมน์ที่ใช้จัดเรียง (ค่าเริ่มต้น)
let quizLeaderboardSortOrder = 'desc'; // ทิศทางการจัดเรียง (ค่าเริ่มต้น)
        let currentStudentName = null;
        let currentStudentProjectData = null; 
        let currentPresentationSlide = 0;
        let allProjects = []; // Cache for projects
		let allQuizzesGlobal = [];        // แคชแบบทดสอบทุกโปรเจค (อ่านรวดเดียว)
		let selectedGlobalQuizId = null;  // id แบบทดสอบที่ผู้ใช้เลือกใน modal
        let allQuizzes = []; // Cache for quizzes in a project
		let starredQuizzes = []; // Cache for starred quizzes
        let chartInstances = {}; // To hold chart objects
        let unsubscribeProjectsListener = null;
        let unsubscribeStudentsListener = null;
        let unsubscribeQuizzesListener = null;
        let unsubscribeSubmissionsListener = null;
        let unsubscribeStudentProfilesListener = null; // For Leaderboard
        let confirmAction = null;
        let cancelAction = null; // <-- เพิ่มบรรทัดนี้
        let actionTargetId = null; // Used for rename/move/timer actions
		let selectedFile = null; //  <-- เพิ่มบรรทัดนี้เข้ามา
        let draggedSvgElement = null; // สำหรับเก็บ element ที่กำลังถูกลาก
        let svgOffset = { x: 0, y: 0 }; // สำหรับเก็บระยะห่างระหว่างเมาส์/นิ้วกับมุมของ element
        // Timer-related state
        let quizTimerInterval = null;
        let perQuestionTimerInterval = null;
        let quizStartTime = null; // For calculating duration
        let currentQuestionIndex = 0;
        let studentAnswersPerQuestion = [];
        // Live Game State
		let cachedOtherPlayersForQuestion = null;
		let cachedQuestionIndexForPlayers = -1;
        let currentLiveGameId = null;
        let currentLiveGamePin = null;
		let lockedFastestResponderName = null; 
		let lastLockedQuestionIndex = -1;
        let unsubscribeLiveGameListener = null;
		let syncQuestionTimerInterval = null;
		let lastRenderedAdminQuestionIndex = -1;
		 		 
// ▼▼▼ [START] วางทับโค้ดส่วน Scratchpad เดิมทั้งหมดด้วยโค้ดชุดใหม่นี้ ▼▼▼

// --- ตัวแปรสำหรับจัดการสถานะของกระดานทด ---
let isAnimatingTrail = false; // ตัวแปรเช็คว่า animation กำลังทำงานหรือไม่
const TRAIL_DURATION = 1500; // ระยะเวลาที่เส้นจะแสดงอยู่ (1500ms = 1.5 วินาที)
let scratchpadCtx = null;
let isDrawingOnScratchpad = false;
let scratchpadHighlighterColor = 'rgba(255, 255, 0, 0.5)'; // สีเหลืองโปร่งแสงเป็นค่าเริ่มต้น
let scratchpadHighlighterSize = 20; // ขนาดเริ่มต้นของไฮไลท์
let isPanning = false;
let isMousePanning = false;

// ตัวแปรสำหรับจัดการการแปลง (ย่อ/ขยาย/เลื่อน)
let scratchpadScale = 1;
let scratchpadOffset = { x: 0, y: 0 };
let panStart = { x: 0, y: 0 };
let initialPinchDistance = null;
const MIN_SCALE = 0.2;
const MAX_SCALE = 5;

// ตัวแปรสำหรับจัดการประวัติการวาด (เส้น)
let strokes = []; // เก็บเส้นที่วาดเสร็จแล้ว
let redoStrokes = []; // เก็บเส้นที่ undo ไป
let currentStroke = null; // เก็บเส้นที่กำลังวาดอยู่

// ตัวแปรสำหรับเครื่องมือ
let activeTool = 'pen'; // 'pen', 'eraser', or 'laser'
let scratchpadPenColor = '#000000';
let scratchpadPenSize = 5;
let scratchpadEraserSize = 40;

let laserFadeTimer = null; // ตัวแปรสำหรับเก็บ Inactivity Timer
const LASER_INACTIVITY_TIMEOUT = 1500; // 1.5 วินาที: เวลาที่ต้องหยุดวาดก่อนที่เส้นจะเริ่มหาย


// --- ฟังก์ชัน Helper ---
function getDistance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

function getMidpoint(p1, p2) {
    return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
}

// แปลงพิกัดบนจอ (Screen) ไปเป็นพิกัดบนกระดานจริง (World)
function getTransformedPoint(x, y) {
    return {
        x: (x - scratchpadOffset.x) / scratchpadScale,
        y: (y - scratchpadOffset.y) / scratchpadScale,
    };
}


function redrawScratchpad() {
    if (!scratchpadCtx) return;
    const canvas = scratchpadCtx.canvas;
    const dpr = window.devicePixelRatio || 1;

    // --- [ START: นี่คือส่วนที่เพิ่มเข้ามา ] ---
    // 1. หา Element ของ Header ที่แสดงโจทย์
    const headerEl = document.getElementById('scratchpad-header');

    // 2. สั่งให้ Header ใช้ CSS Transform ตามค่าการซูม/เลื่อนของ Canvas
    if (headerEl) {
        headerEl.style.transformOrigin = '0 0'; // กำหนดจุดหมุนที่มุมซ้ายบน
        headerEl.style.transform = `translate(${scratchpadOffset.x}px, ${scratchpadOffset.y}px) scale(${scratchpadScale})`;
    }
    // --- [ END: สิ้นสุดส่วนที่เพิ่มเข้ามา ] ---

    // 1. ล้าง Canvas (โค้ดส่วนนี้เหมือนเดิม)
    scratchpadCtx.save();
    scratchpadCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    scratchpadCtx.clearRect(0, 0, canvas.width, canvas.height);
    scratchpadCtx.restore();

    // 2. ตั้งค่า Transform (Scale และ Pan) (โค้ดส่วนนี้เหมือนเดิม)
    scratchpadCtx.save();
    scratchpadCtx.translate(scratchpadOffset.x, scratchpadOffset.y);
    scratchpadCtx.scale(scratchpadScale, scratchpadScale);

    // 3. วาดเส้นทั้งหมดที่บันทึกไว้ใน strokes (โค้ดส่วนนี้เหมือนเดิม)
    strokes.forEach(stroke => {
        drawStroke(stroke);
    });

    // 4. วาดเส้นที่กำลังวาดอยู่ (ถ้ามี) (โค้ดส่วนนี้เหมือนเดิม)
    if (currentStroke) {
        drawStroke(currentStroke);
    }

    // 5. คืนค่า Transform (โค้ดส่วนนี้เหมือนเดิม)
    scratchpadCtx.restore();
}

// ▼▼▼ เพิ่มฟังก์ชันใหม่นี้เข้าไปทั้งหมด ▼▼▼
function renderGroupModeQuestion() {
    if (localQuestionIndex >= currentQuizData.questions.length) {
        displayTeamQuizFinalResults();
        return;
    }

    const q = currentQuizData.questions[localQuestionIndex];
    const questionType = q.questionType || currentQuizData.quizType;
    let questionTextHTML = q.stem || q.questionText;
    let optionsHTML = '';

    switch (questionType) {
        case 'multiple_choice': case 'fill_in_with_choices':
            optionsHTML = q.options.map((opt, i) => `<div><input type="radio" id="team_opt${i}" name="team_answer" value="${i}" class="mr-2 accent-cyan-600" required><label for="team_opt${i}">${opt}</label></div>`).join('');
            break;
        case 'true_false':
            optionsHTML = `<div><input type="radio" id="team_opt_true" name="team_answer" value="true" class="mr-2 accent-cyan-600" required><label for="team_opt_true">ใช่ / ถูก</label></div><div><input type="radio" id="team_opt_false" name="team_answer" value="false" class="mr-2 accent-cyan-600" required><label for="team_opt_false">ไม่ใช่ / ผิด</label></div>`;
            break;
        case 'short_answer': case 'fill_in_no_choices':
            optionsHTML = `<textarea name="team_answer" class="w-full p-2 border border-gray-300 rounded-lg" rows="3" required placeholder="พิมพ์คำตอบของกลุ่ม..."></textarea>`;
            break;
        case 'matching_item':
            optionsHTML = `<select name="team_answer" class="w-full p-2 border border-gray-300 rounded-lg" required><option value="">-- เลือกคำตอบที่คู่กัน --</option>${q.allResponses.map(resp => `<option value="${resp}">${resp}</option>`).join('')}</select>`;
            break;
        default:
            optionsHTML = '<p class="text-red-500">ไม่รู้จักประเภทของคำถามนี้</p>';
            break;
    }

    studentQuizArea.innerHTML = `
        <div class="p-4 fade-in">
            <p class="text-sm text-gray-500 text-center">ข้อที่ ${localQuestionIndex + 1} / ${currentQuizData.questions.length}</p>
            <p class="text-2xl font-bold text-center text-cyan-700 my-2">กลุ่ม: ${localTeamPlayers.join(', ')}</p>
            <div class="my-4 p-4 border rounded-lg bg-gray-50">
                <div class="font-semibold mb-3">
                    <p>${localQuestionIndex + 1}. ${questionTextHTML}</p>
                    ${q.imageCode ? `<div class="my-4 flex justify-center">${q.imageCode}</div>` : ''}
                </div>
                <div class="space-y-2 text-lg">${optionsHTML}</div>
            </div>
            <button id="submit-group-answer-btn" class="w-full bg-cyan-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-cyan-700">ส่งคำตอบ</button>
        </div>
    `;
    studentQuizArea.classList.remove('hidden');
    if (window.MathJax) MathJax.typesetPromise([studentQuizArea]);

    document.getElementById('submit-group-answer-btn').addEventListener('click', handleGroupAnswerSubmit);
}

// ▼▼▼ วางทับฟังก์ชัน handleGenerateQuizFromBlueprintTopic เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
function handleGenerateQuizFromBlueprintTopic(topic, lessonText = null, projectId, blueprintTopicId = null, forceAppStyle = false, extraParts = null) {
    const quizGenerationArea = document.getElementById('quiz-generation-area');
    if (quizGenerationArea) {
        quizGenerationArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // ส่ง extraParts ที่ได้รับมาต่อไปยัง generateQuiz
    generateQuiz(topic, lessonText, null, extraParts, true, projectId, blueprintTopicId, forceAppStyle);
}

function handleGenerateAndShowLesson(topic, grade) {
    const modal = document.getElementById('lesson-view-modal');
    const titleEl = document.getElementById('lesson-view-title');
    const loaderEl = document.getElementById('lesson-loader');
    const contentContainer = document.getElementById('lesson-sections-container');
	
	    ['pointContent', 'memoryContent', 'applicationContent', 'summaryContent'].forEach(id => {
        const parentSection = document.getElementById(id).parentElement;
        if (parentSection) {
            parentSection.style.display = 'block';
        }
    });
    
    // 1. Reset และแสดง Modal พร้อม Loader
    titleEl.textContent = `กำลังสร้างบทเรียน: ${topic}`;
    contentContainer.classList.add('hidden');
    loaderEl.classList.remove('hidden');
    modal.classList.remove('hidden');
    
    // 2. เรียกฟังก์ชัน generateLesson ที่เราคัดลอกมา
    generateLesson(topic, grade).catch(err => {
        console.error("Failed to generate lesson:", err);
        showMessage("ขออภัย, ไม่สามารถสร้างบทเรียนสำหรับหัวข้อนี้ได้");
        modal.classList.add('hidden'); // ซ่อน Modal ถ้าเกิด Error
    });
}

function handlePointerDown(e) {
    e.preventDefault();
    const canvas = scratchpadCtx.canvas;
    const rect = canvas.getBoundingClientRect();
    const pointerType = e.pointerType || (e.touches ? 'touch' : 'mouse');
    
    if (pointerType === 'pen' || pointerType === 'mouse') {
        if (e.pointerType === 'mouse' && e.button !== 0) { 
            if (e.button === 1) { 
                isMousePanning = true;
                panStart = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
            }
            return; 
        }
		
		    if (activeTool === 'trail') {
        // ถ้ามี Timer นับถอยหลังอยู่ ให้ยกเลิกทันที
        // นี่คือส่วนที่ทำให้เส้นเก่ายังไม่หายไปเมื่อเราเริ่มวาดเส้นใหม่
        if (laserFadeTimer) {
            clearTimeout(laserFadeTimer);
        }
    }

        isDrawingOnScratchpad = true;
        redoStrokes = [];
        const transformedPoint = getTransformedPoint(e.clientX - rect.left, e.clientY - rect.top);
        
        // กำหนดคุณสมบัติของเส้นตามเครื่องมือที่เลือก
        let strokeProperties = {
            tool: activeTool,
            points: [transformedPoint]
        };

        if (activeTool === 'pen') {
            strokeProperties.color = scratchpadPenColor;
            strokeProperties.size = scratchpadPenSize;
        } else if (activeTool === 'eraser') {
            strokeProperties.color = scratchpadPenColor; // สีไม่สำคัญสำหรับยางลบ
            strokeProperties.size = scratchpadEraserSize; // <-- [แก้ไข] ใช้ตัวแปรใหม่
        } else if (activeTool === 'highlighter') {
            strokeProperties.color = scratchpadHighlighterColor;
            strokeProperties.size = scratchpadHighlighterSize; 
        } else if (activeTool === 'trail') {
            strokeProperties.color = scratchpadPenColor;
            strokeProperties.size = scratchpadPenSize; // Trail ยังคงใช้ขนาดของปากกา
        }

        currentStroke = strokeProperties;

    } else if (e.touches) {
        if (e.touches.length === 2) {
            isPanning = true;
            panStart = getMidpoint({ x: e.touches[0].clientX, y: e.touches[0].clientY }, { x: e.touches[1].clientX, y: e.touches[1].clientY });
            initialPinchDistance = getDistance({ x: e.touches[0].clientX, y: e.touches[0].clientY }, { x: e.touches[1].clientX, y: e.touches[1].clientY });
        }
    }
}

// ▼▼▼ วางทับฟังก์ชัน animateTrail เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
function animateTrail() {
    const now = Date.now();
    let hasActiveTrails = false;

    // วนลูปจากหลังมาหน้าเสมอ เมื่อมีการลบ item ใน array
    for (let i = strokes.length - 1; i >= 0; i--) {
        const stroke = strokes[i];

        // ตรวจสอบเฉพาะเส้นที่เป็น 'trail' และมีเวลา "เริ่มจางหาย" แล้วเท่านั้น
        if (stroke.tool === 'trail' && stroke.fadeStartTime) {
            const elapsedTime = now - stroke.fadeStartTime;

            if (elapsedTime >= TRAIL_DURATION) {
                // ถ้าหมดเวลาแล้ว ให้ลบเส้นนี้ทิ้งไปเลย
                strokes.splice(i, 1);
            } else {
                // ถ้ายังไม่หมดเวลา ให้คำนวณความโปร่งใส
                stroke.opacity = 1 - (elapsedTime / TRAIL_DURATION);
                hasActiveTrails = true; // บอกให้รู้ว่ายังต้องทำ animation ต่อ
            }
        }
    }
    
    // วาด Canvas ใหม่
    redrawScratchpad();

    // ถ้ายังมีเส้นที่ต้องทำ animation อยู่ ให้วน Loop ต่อไป
    if (hasActiveTrails) {
        requestAnimationFrame(animateTrail);
    } else {
        isAnimatingTrail = false; // หยุด animation
    }
}

function startTrailAnimation() {
    // ป้องกันการเรียก animation ซ้ำซ้อน
    if (!isAnimatingTrail) {
        isAnimatingTrail = true;
        requestAnimationFrame(animateTrail);
    }
}

function drawStroke(stroke) {
    if (!stroke || stroke.points.length < 1) return;

    scratchpadCtx.save();
    scratchpadCtx.lineJoin = 'round';
    scratchpadCtx.lineCap = 'round';

    if (stroke.tool === 'trail') {
        const adjustedSize = stroke.size / scratchpadScale;
        scratchpadCtx.globalAlpha = stroke.opacity ?? 1.0; 
        scratchpadCtx.shadowColor = 'rgba(239, 68, 68, 0.9)';
        scratchpadCtx.shadowBlur = adjustedSize * 3;
        scratchpadCtx.strokeStyle = 'rgba(239, 68, 68, 0.7)';
        scratchpadCtx.lineWidth = adjustedSize * 2.5;
        
        scratchpadCtx.beginPath();
        scratchpadCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length - 1; i++) {
            const midPoint = getMidpoint(stroke.points[i], stroke.points[i + 1]);
            scratchpadCtx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, midPoint.x, midPoint.y);
        }
        scratchpadCtx.stroke();
        
        scratchpadCtx.shadowColor = 'transparent';
        scratchpadCtx.shadowBlur = 0;
        scratchpadCtx.strokeStyle = '#FFFFFF';
        scratchpadCtx.lineWidth = adjustedSize;
        
        scratchpadCtx.stroke(); // Re-stroke the center line
        scratchpadCtx.closePath();

    } else if (stroke.tool === 'highlighter') {
        // ใช้ 'multiply' เพื่อให้สีซ้อนทับกันแล้วเข้มขึ้นเหมือนไฮไลท์จริง
        scratchpadCtx.globalCompositeOperation = 'multiply';
        scratchpadCtx.strokeStyle = stroke.color; // จะเป็นสีแบบ rgba(r, g, b, 0.5)
        scratchpadCtx.lineWidth = stroke.size;
        
        scratchpadCtx.beginPath();
        scratchpadCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length - 1; i++) {
            const midPoint = getMidpoint(stroke.points[i], stroke.points[i + 1]);
            scratchpadCtx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, midPoint.x, midPoint.y);
        }
        scratchpadCtx.stroke();
        scratchpadCtx.closePath();

    } else { // สำหรับ 'pen' และ 'eraser'
        scratchpadCtx.globalCompositeOperation = stroke.tool === 'eraser' ? 'destination-out' : 'source-over';
        scratchpadCtx.strokeStyle = stroke.color;
        scratchpadCtx.lineWidth = stroke.size;
        
        scratchpadCtx.beginPath();
        scratchpadCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length - 1; i++) {
            const midPoint = getMidpoint(stroke.points[i], stroke.points[i + 1]);
            scratchpadCtx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, midPoint.x, midPoint.y);
        }
        scratchpadCtx.stroke();
        scratchpadCtx.closePath();
    }
    
    scratchpadCtx.restore();
}

function handlePointerMove(e) {
    e.preventDefault();
    const canvas = scratchpadCtx.canvas;
    const rect = canvas.getBoundingClientRect();

    if (e.touches) { // Touch Events
        if (e.touches.length === 1 && isDrawingOnScratchpad) {
            const transformedPoint = getTransformedPoint(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
            currentStroke.points.push(transformedPoint);
            redrawScratchpad();
        } else if (e.touches.length === 2 && isPanning) {
            // (โค้ดส่วนนี้เหมือนเดิม)
            const currentPinchDistance = getDistance({ x: e.touches[0].clientX, y: e.touches[0].clientY }, { x: e.touches[1].clientX, y: e.touches[1].clientY });
            const midPoint = getMidpoint({ x: e.touches[0].clientX, y: e.touches[0].clientY }, { x: e.touches[1].clientX, y: e.touches[1].clientY });
            const scaleFactor = currentPinchDistance / initialPinchDistance;
            const newScale = Math.min(Math.max(scratchpadScale * scaleFactor, MIN_SCALE), MAX_SCALE);
            const dx = midPoint.x - panStart.x;
            const dy = midPoint.y - panStart.y;
            scratchpadOffset.x = midPoint.x - (midPoint.x - scratchpadOffset.x) * (newScale / scratchpadScale);
            scratchpadOffset.y = midPoint.y - (midPoint.y - scratchpadOffset.y) * (newScale / scratchpadScale);
            scratchpadOffset.x += dx;
            scratchpadOffset.y += dy;
            scratchpadScale = newScale;
            initialPinchDistance = currentPinchDistance;
            panStart = midPoint;
            redrawScratchpad();
        }
    } else { // Mouse Event
        // ▼▼▼--- แก้ไข/เพิ่มโค้ดในส่วนนี้ทั้งหมด ---▼▼▼
        if (isMousePanning) {
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            scratchpadOffset.x += dx;
            scratchpadOffset.y += dy;
            panStart = { x: e.clientX, y: e.clientY };
            redrawScratchpad();
        } else if (isDrawingOnScratchpad) {
            const transformedPoint = getTransformedPoint(e.clientX - rect.left, e.clientY - rect.top);
            currentStroke.points.push(transformedPoint);
            redrawScratchpad();
        }
        // ▲▲▲--- สิ้นสุดส่วนที่แก้ไข ---▲▲▲
    }
}

function handlePointerUp(e) {
    e.preventDefault();
    const canvas = scratchpadCtx.canvas; // <-- เพิ่มบรรทัดนี้

    // ▼▼▼--- เพิ่มโค้ดส่วนนี้ ---▼▼▼
    if (isMousePanning) {
        isMousePanning = false;
        canvas.style.cursor = 'default'; // เปลี่ยน cursor กลับเป็นปกติ
    }
    // ▲▲▲--- สิ้นสุดส่วนที่เพิ่ม ---▲▲▲

    isPanning = false;
    initialPinchDistance = null;

    if (isDrawingOnScratchpad) {
        isDrawingOnScratchpad = false;
        if (currentStroke && currentStroke.points.length > 1) {
            strokes.push(currentStroke);
            
            // ▼▼▼ เพิ่มโค้ดบล็อกนี้เข้าไป ▼▼▼
            // ถ้าเส้นที่เพิ่งวาดเสร็จเป็น trail ให้เริ่ม animation
if (currentStroke.tool === 'trail') {
    // ยกเลิก Timer เก่าที่อาจจะกำลังทำงาน (กรณีคลิกเร็วๆ)
    if (laserFadeTimer) {
        clearTimeout(laserFadeTimer);
    }
    
    // ตั้ง Timer ใหม่เพื่อนับถอยหลัง
    laserFadeTimer = setTimeout(() => {
        // เมื่อ Timer ทำงานจนครบ (หมายความว่าผู้ใช้หยุดวาดแล้ว)
        // 1. ค้นหาเส้น trail ทั้งหมดที่ยังไม่ถูกสั่งให้จางหาย
        const strokesToFade = strokes.filter(s => s.tool === 'trail' && !s.fadeStartTime);

        if (strokesToFade.length > 0) {
            const now = Date.now();
            // 2. สั่งให้ทุกเส้นเริ่มจางหาย ณ เวลาเดียวกัน
            strokesToFade.forEach(s => s.fadeStartTime = now);
            
            // 3. เริ่ม Animation การจางหาย
            startTrailAnimation();
        }

    }, LASER_INACTIVITY_TIMEOUT); // รอ 1.5 วินาทีก่อนเริ่มทำงาน
}
        }
        currentStroke = null;
        updateUndoRedoButtons();
    }
}

// จัดการการซูมด้วย Mouse Wheel
function handleWheel(e) {
    e.preventDefault();
    const scaleAmount = e.deltaY * -0.005;
    const newScale = Math.min(Math.max(scratchpadScale + scaleAmount, MIN_SCALE), MAX_SCALE);

    // Adjust offset to zoom towards the mouse pointer
    scratchpadOffset.x = e.clientX - (e.clientX - scratchpadOffset.x) * (newScale / scratchpadScale);
    scratchpadOffset.y = e.clientY - (e.clientY - scratchpadOffset.y) * (newScale / scratchpadScale);

    scratchpadScale = newScale;
    redrawScratchpad();
}

function undo() {
    if (strokes.length > 0) {
        redoStrokes.push(strokes.pop());
        updateUndoRedoButtons();
        redrawScratchpad();
    }
}

function redo() {
    if (redoStrokes.length > 0) {
        strokes.push(redoStrokes.pop());
        updateUndoRedoButtons();
        redrawScratchpad();
    }
}

function updateUndoRedoButtons() {
    document.getElementById('undo-btn').disabled = strokes.length === 0;
    document.getElementById('redo-btn').disabled = redoStrokes.length === 0;
}

function openScratchpad(question, options) {
    const modal = document.getElementById('scratchpad-modal');
    const questionEl = document.getElementById('scratchpad-question');
    const optionsEl = document.getElementById('scratchpad-options');
    const controlsContainer = document.getElementById('scratchpad-controls'); // บรรทัดนี้อาจยังอยู่ (ไม่เป็นไร)

    questionEl.innerHTML = question.stem || question.questionText;
    optionsEl.innerHTML = options.map((opt, index) => `<div>${String.fromCharCode(65 + index)}. ${opt}</div>`).join('');
    
    // โค้ดที่สร้าง innerHTML ของ controlsContainer ถูกลบไปแล้ว

    setupScratchpadControls(); // เรียกใช้ฟังก์ชันนี้เพื่อสร้าง Toolbar ที่ถูกต้อง
    
    // รีเซ็ตสถานะทั้งหมดก่อนเปิด
    strokes = [];
    redoStrokes = [];
    currentStroke = null;
    scratchpadScale = 1;
    scratchpadOffset = { x: 0, y: 0 };
    
    modal.classList.remove('hidden');
    setTimeout(() => {
        initializeScratchpadCanvas();
        redrawScratchpad();
    }, 50);

    if (window.MathJax) MathJax.typesetPromise([questionEl, optionsEl]);
}

// ▼▼▼ เพิ่มฟังก์ชันใหม่นี้เข้าไปทั้งหมด ▼▼▼

/**
 * [ใหม่] เปิด Modal ตั้งค่าสำหรับหน้า Blueprint และจัดการการบันทึกชั่วคราว
 */
// ▼▼▼ วางทับฟังก์ชัน openBlueprintQuizSettings เดิมทั้งหมด ▼▼▼
/**
 * [ใหม่] เปิด Modal ตั้งค่าฉบับสมบูรณ์สำหรับหน้า Blueprint
 */
function openBlueprintQuizSettings() {
    const modal = document.getElementById('blueprint-settings-modal');

    // 1. กำหนดค่าเริ่มต้น: ใช้ค่าที่บันทึกไว้ชั่วคราว (ถ้ามี) หรือใช้ค่าจากโปรเจคหลัก
    const settings = blueprintPageSettings || (currentProjectData ? currentProjectData.settings : {}) || {};

    // 2. นำค่าไปใส่ในฟอร์มของ Modal (ใช้ ID ที่มี bp-modal- นำหน้า)
    document.getElementById('bp-modal-quiz-type-select').value = settings.quizType || document.getElementById('quiz-type-select').value;
    document.getElementById('bp-modal-difficulty-level-select').innerHTML = document.getElementById('difficulty-level-select').innerHTML;
    document.getElementById('bp-modal-difficulty-level-select').value = settings.difficultyValue || document.getElementById('difficulty-level-select').value;
    document.getElementById('bp-modal-question-complexity-select').innerHTML = document.getElementById('question-complexity-select').innerHTML;
    document.getElementById('bp-modal-question-complexity-select').value = settings.complexityValue || document.getElementById('question-complexity-select').value;
    document.getElementById('bp-modal-num-questions').value = settings.numQuestions || document.getElementById('num-questions').value;
    document.getElementById('bp-modal-passing-score-input').value = settings.passingScore || document.getElementById('passing-score-input').value;
    document.getElementById('bp-modal-num-choices').value = settings.numChoices || document.getElementById('num-choices').value;
    document.getElementById('bp-modal-shuffle-setting-select').value = settings.shuffle || document.getElementById('shuffle-setting-select').value;
    document.getElementById('bp-modal-include-images-checkbox').checked = settings.includeImages || document.getElementById('include-images-checkbox').checked;

    // 3. แสดง Modal
    modal.classList.remove('hidden');
}

// ▼▼▼ เพิ่มฟังก์ชันใหม่นี้เข้าไปใน <script> ▼▼▼
/**
 * [ใหม่] บันทึกการตั้งค่าจาก Modal ลงในตัวแปรชั่วคราว blueprintPageSettings
 */
function handleSaveBlueprintPageSettings() {
    blueprintPageSettings = {
        quizType: document.getElementById('bp-modal-quiz-type-select').value,
        difficultyValue: document.getElementById('bp-modal-difficulty-level-select').value,
        complexityValue: document.getElementById('bp-modal-question-complexity-select').value,
        numQuestions: document.getElementById('bp-modal-num-questions').value,
        passingScore: document.getElementById('bp-modal-passing-score-input').value,
        numChoices: document.getElementById('bp-modal-num-choices').value,
        shuffle: document.getElementById('bp-modal-shuffle-setting-select').value,
        includeImages: document.getElementById('bp-modal-include-images-checkbox').checked,
    };

    showMessage("บันทึกการตั้งค่าสำหรับสร้างแบบทดสอบในหน้านี้แล้ว");
    document.getElementById('blueprint-settings-modal').classList.add('hidden');
}

// ▼▼▼ START: วางโค้ดชุดฟังก์ชันใหม่นี้ทั้งหมดเข้าไปใน <script> ▼▼▼

/**
 * [Parallel Shortcuts] เริ่มฟังข้อมูลปุ่มลัดจาก Firestore
 */
function listenForParallelTestShortcuts() {
    const shortcutsRef = doc(db, "globalSettings", "parallelTestShortcutsConfig");

    onSnapshot(shortcutsRef, (docSnap) => {
        let shortcuts = [];
        let tabs = [];
        let order = {};

        if (docSnap.exists()) {
            const data = docSnap.data();
            shortcuts = data.shortcuts || [];
            tabs = data.parallelShortcutTabs || []; // <-- [แก้ไข]
            order = data.parallelShortcutOrder || {};   // <-- [แก้ไข]
        }

        if (!tabs.find(t => t.id === 'all')) {
            tabs.unshift({ id: 'all', name: 'ต้นฉบับทั้งหมด', isDefault: true });
        }

        if (!shortcuts.find(s => s.id === 'parallel-default-1')) {
            shortcuts.unshift({ id: 'parallel-default-1', name: 'ต้นฉบับ 1', url: '', isDefault: true });
        }
        if (!shortcuts.find(s => s.id === 'parallel-default-2')) {
            shortcuts.unshift({ id: 'parallel-default-2', name: 'ต้นฉบับ 2', url: '', isDefault: true });
        }

        parallelTestShortcuts = shortcuts;
        parallelShortcutTabs = tabs; // <-- [แก้ไข]
        parallelShortcutOrder = order; // <-- [แก้ไข]

        renderParallelTestShortcuts();

        if (!document.getElementById('additional-parallel-shortcuts-modal').classList.contains('hidden')) {
            renderAdditionalParallelShortcutsModal(); // <-- [แก้ไข]
        }
    });
}

// ▼▼▼ [ใหม่] เพิ่มชุดฟังก์ชันสำหรับจัดการ Parallel Test Shortcut Tabs ทั้งหมด ▼▼▼

async function saveParallelShortcutConfig() {
    const configRef = doc(db, "globalSettings", "parallelTestShortcutsConfig");
    try {
        await setDoc(configRef, { 
            parallelShortcutTabs: parallelShortcutTabs,
            parallelShortcutOrder: parallelShortcutOrder
        }, { merge: true });
    } catch (error) { console.error("Error saving parallel shortcut config:", error); }
}

function renderAdditionalParallelShortcutsModal() {
    const navContainer = document.getElementById('parallel-shortcut-tabs-nav');
    const listContainer = document.getElementById('additional-parallel-shortcuts-list');
    if (!navContainer || !listContainer) return;

    navContainer.innerHTML = parallelShortcutTabs.map(tab => {
        const isActive = tab.id === activeParallelShortcutTabId;
        return `<div class="relative group flex items-center">
                    <button data-tab-id="${tab.id}" class="parallel-shortcut-tab-btn whitespace-nowrap py-3 px-2 border-b-2 font-medium text-sm ${isActive ? 'border-indigo-500 text-indigo-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}">
                        <span class="tab-name-display pointer-events-none">${tab.name}</span>
                        <input type="text" value="${tab.name}" class="tab-name-input hidden bg-transparent border-b-2 border-indigo-500 text-sm w-32">
                    </button>
                    ${!tab.isDefault ? `<button data-tab-id="${tab.id}" class="delete-parallel-shortcut-tab-btn absolute -top-1 -right-1 text-red-400 hover:text-red-700 opacity-0 group-hover:opacity-100">&times;</button>` : ''}
                </div>`;
    }).join('');

    const activeTab = parallelShortcutTabs.find(t => t.id === activeParallelShortcutTabId);
    let shortcutsToShow = activeTab?.isDefault ? [...parallelTestShortcuts] : parallelTestShortcuts.filter(s => (activeTab?.shortcutIds || []).includes(s.id));
    
    const currentOrder = parallelShortcutOrder[activeParallelShortcutTabId] || [];
    shortcutsToShow.sort((a, b) => {
        const indexA = currentOrder.indexOf(a.id);
        const indexB = currentOrder.indexOf(b.id);
        return (indexA === -1 ? Infinity : indexA) - (indexB === -1 ? Infinity : indexB);
    });

    listContainer.innerHTML = shortcutsToShow.map(shortcut => {
        const icon = shortcut.url ? '🔁' : '🔗';
        const otherTabs = parallelShortcutTabs.filter(t => !t.isDefault);
        const moveDropdownHTML = activeTab.isDefault && otherTabs.length > 0 ? `
            <div class="relative inline-block text-left group/dropdown-parallel">
                <button class="move-parallel-shortcut-menu-btn text-gray-500 hover:text-blue-700 p-1 rounded-full text-sm"><i class="fas fa-ellipsis-v"></i></button>
                <div class="move-parallel-shortcut-dropdown origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden z-20">
                    <div class="py-1">
                        <p class="px-4 pt-1 pb-2 text-xs text-gray-400">เพิ่มไปยังแท็บ:</p>
                        ${otherTabs.map(tab => `<a href="#" class="move-parallel-shortcut-item block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" data-shortcut-id="${shortcut.id}" data-target-tab-id="${tab.id}">${tab.name}</a>`).join('')}
                    </div>
                </div>
            </div>` : '';

        return `<div class="shortcut-list-item p-3 border-b hover:bg-gray-50 flex items-center justify-between" data-shortcut-id="${shortcut.id}" draggable="true">
                    <div><p class="font-semibold text-teal-700">${icon} ${shortcut.name}</p></div>
                    <div class="flex items-center gap-2 shrink-0">
                        <button data-id="${shortcut.id}" class="use-hidden-parallel-shortcut-btn bg-teal-100 text-teal-700 text-sm py-1 px-3 rounded-md hover:bg-teal-200">สร้างเลย</button>
                        <button data-id="${shortcut.id}" class="edit-hidden-parallel-shortcut-btn bg-yellow-100 text-yellow-700 text-sm py-1 px-3 rounded-md hover:bg-yellow-200">แก้ไข</button>
                        ${!shortcut.isDefault ? `<button data-id="${shortcut.id}" class="delete-hidden-parallel-shortcut-btn bg-red-100 text-red-700 text-sm py-1 px-3 rounded-md hover:bg-red-200">ลบ</button>` : ''}
                        ${!activeTab.isDefault ? `<button data-shortcut-id="${shortcut.id}" class="remove-parallel-shortcut-from-tab-btn text-red-500 ml-2" title="นำออกจากแท็บนี้"><i class="fas fa-times-circle"></i></button>` : ''}
                        ${moveDropdownHTML}
                    </div>
                </div>`;
    }).join('') || '<p class="p-4 text-center text-gray-500">ไม่มีปุ่มลัดในแท็บนี้</p>';
    
    setupParallelShortcutModalEventListeners();
}

function setupParallelShortcutModalEventListeners() {
    document.querySelectorAll('.parallel-shortcut-tab-btn').forEach(btn => {
        btn.onclick = e => { activeParallelShortcutTabId = e.currentTarget.dataset.tabId; renderAdditionalParallelShortcutsModal(); };
        btn.ondblclick = e => {
            const input = e.currentTarget.querySelector('.tab-name-input');
            e.currentTarget.querySelector('.tab-name-display').classList.add('hidden');
            input.classList.remove('hidden'); input.focus(); input.select();
        };
    });
    document.querySelectorAll('#parallel-shortcut-tabs-nav .tab-name-input').forEach(input => {
        const save = () => {
            const tabId = input.closest('.parallel-shortcut-tab-btn').dataset.tabId;
            const tab = parallelShortcutTabs.find(t => t.id === tabId);
            if(tab) { tab.name = input.value.trim() || tab.name; saveParallelShortcutConfig(); }
        };
        input.onblur = save;
        input.onkeydown = e => { if (e.key === 'Enter') input.blur(); };
    });
    document.querySelectorAll('.delete-parallel-shortcut-tab-btn').forEach(btn => btn.onclick = e => {
        const tabId = e.currentTarget.dataset.tabId;
        showConfirmation("คุณแน่ใจว่าต้องการลบแท็บนี้?", () => {
            parallelShortcutTabs = parallelShortcutTabs.filter(t => t.id !== tabId);
            delete parallelShortcutOrder[tabId];
            if (activeParallelShortcutTabId === tabId) activeParallelShortcutTabId = 'all';
            saveParallelShortcutConfig();
        });
    });
    document.querySelectorAll('.move-parallel-shortcut-item').forEach(item => item.onclick = e => {
        e.preventDefault();
        const { shortcutId, targetTabId } = e.currentTarget.dataset;
        const tab = parallelShortcutTabs.find(t => t.id === targetTabId);
        if(tab && !tab.shortcutIds.includes(shortcutId)) { tab.shortcutIds.push(shortcutId); saveParallelShortcutConfig(); }
    });
    document.querySelectorAll('.remove-parallel-shortcut-from-tab-btn').forEach(btn => btn.onclick = e => {
        const shortcutId = e.currentTarget.dataset.shortcutId;
        const tab = parallelShortcutTabs.find(t => t.id === activeParallelShortcutTabId);
        if(tab && !tab.isDefault) { tab.shortcutIds = tab.shortcutIds.filter(id => id !== shortcutId); saveParallelShortcutConfig(); }
    });
    document.querySelectorAll('.move-parallel-shortcut-menu-btn').forEach(btn => btn.onclick = e => {
        e.stopPropagation();
        const dropdown = e.currentTarget.nextElementSibling;
        document.querySelectorAll('.move-parallel-shortcut-dropdown').forEach(d => d.classList.add('hidden'));
        dropdown.classList.remove('hidden');
    });
    const listContainer = document.getElementById('additional-parallel-shortcuts-list');
    let draggedItem = null;
    listContainer.ondragstart = e => {
        draggedItem = e.target.closest('.shortcut-list-item');
        if(draggedItem) setTimeout(() => draggedItem.classList.add('opacity-50'), 0);
    };
    listContainer.ondragend = () => { if(draggedItem) { draggedItem.classList.remove('opacity-50'); draggedItem = null; }};
    listContainer.ondragover = e => { e.preventDefault(); };
    listContainer.ondrop = e => {
        e.preventDefault();
        if (draggedItem) {
            const afterElement = [...listContainer.querySelectorAll('.shortcut-list-item:not(.opacity-50)')].reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = e.clientY - box.top - box.height / 2;
                return (offset < 0 && offset > closest.offset) ? { offset: offset, element: child } : closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
            if (afterElement == null) { listContainer.appendChild(draggedItem); } 
            else { listContainer.insertBefore(draggedItem, afterElement); }
            const newOrder = [...listContainer.querySelectorAll('.shortcut-list-item')].map(item => item.dataset.shortcutId);
            parallelShortcutOrder[activeParallelShortcutTabId] = newOrder;
            saveParallelShortcutConfig();
        }
    };
}

async function handleAddParallelShortcutTab() {
    const name = prompt("กรุณาตั้งชื่อแท็บใหม่:", "แท็บใหม่");
    if (name && name.trim()) {
        parallelShortcutTabs.push({ id: `tab_${Date.now()}`, name: name.trim(), shortcutIds: [] });
        await saveParallelShortcutConfig();
    }
}
// ▲▲▲ สิ้นสุดชุดฟังก์ชันใหม่ ▲▲▲

function renderParallelTestShortcuts() {
    const container = document.getElementById('parallel-shortcut-container');
    const additionalList = document.getElementById('additional-parallel-shortcuts-list');
    const loadingMsg = document.getElementById('parallel-shortcuts-loading-msg');

    if (loadingMsg) loadingMsg.classList.add('hidden');
    if (!container || !additionalList) return;

    const visibleShortcuts = parallelTestShortcuts.slice(0, 4);
    const hiddenShortcuts = parallelTestShortcuts.slice(4);

    container.innerHTML = visibleShortcuts.map(shortcut => {
        const hasUrl = shortcut.url && shortcut.url.trim() !== '';
        const bgColor = hasUrl ? 'bg-teal-500 hover:bg-teal-600 text-white' : 'bg-gray-200 hover:bg-gray-300 text-gray-700';
        const icon = hasUrl ? '🔁' : '🔗';

        const deleteBtnHtml = !shortcut.isDefault ? 
            `<button data-id="${shortcut.id}" class="delete-parallel-shortcut-btn absolute top-1 right-1 w-6 h-6 bg-red-500 text-white rounded-full text-xs opacity-0 group-hover:opacity-100 transition-opacity" title="ลบ">&times;</button>` : '';

        return `
            <div class="relative group">
                <div data-id="${shortcut.id}" class="parallel-shortcut-btn rounded-2xl shadow-lg p-4 flex items-center justify-center text-center font-semibold cursor-pointer transition transform hover:scale-105 h-24 ${bgColor}">
                    <span class="pointer-events-none">${icon} ${shortcut.name}</span>
                </div>
                <button data-id="${shortcut.id}" class="edit-parallel-shortcut-btn absolute bottom-1 right-1 w-6 h-6 bg-white/50 text-gray-800 rounded-full text-xs opacity-0 group-hover:opacity-100 transition-opacity" title="แก้ไข"><i class="fas fa-pen"></i></button>
                ${deleteBtnHtml}
            </div>
        `;
    }).join('');

    if (hiddenShortcuts.length > 0) {
        container.innerHTML += `
            <div id="open-additional-parallel-shortcuts-btn" class="rounded-2xl shadow-lg p-4 flex flex-col items-center justify-center text-center font-semibold cursor-pointer transition transform hover:scale-105 h-24 bg-gray-100 hover:bg-gray-200 text-gray-600">
                <i class="fas fa-ellipsis-h text-xl"></i>
                <span class="mt-2 text-sm">ปุ่มลัดเพิ่มเติม</span>
            </div>
        `;
    }

    if (hiddenShortcuts.length > 0) {
        additionalList.innerHTML = hiddenShortcuts.map(shortcut => `
            <div class="p-3 border-b hover:bg-gray-100 flex items-center justify-between">
                <p class="font-semibold text-teal-700">${shortcut.url ? '🔁' : '🔗'} ${shortcut.name}</p>
                <div class="flex items-center gap-2 shrink-0">
                    <button data-id="${shortcut.id}" class="use-hidden-parallel-shortcut-btn bg-teal-100 text-teal-700 text-sm py-1 px-3 rounded-md hover:bg-teal-200">สร้างเลย</button>
                    <button data-id="${shortcut.id}" class="edit-hidden-parallel-shortcut-btn bg-yellow-100 text-yellow-700 text-sm py-1 px-3 rounded-md hover:bg-yellow-200">แก้ไข</button>
                    ${!shortcut.isDefault ? `<button data-id="${shortcut.id}" class="delete-hidden-parallel-shortcut-btn bg-red-100 text-red-700 text-sm py-1 px-3 rounded-md hover:bg-red-200">ลบ</button>` : ''}
                </div>
            </div>
        `).join('');
    } else {
        additionalList.innerHTML = '<p class="p-4 text-center text-gray-500">ไม่มีปุ่มลัดเพิ่มเติม</p>';
    }
}

/**
 * [Parallel Shortcuts] เปิด Modal สำหรับแก้ไขหรือเพิ่มปุ่มลัดใหม่
 */
function openParallelTestShortcutEditor(shortcutId = null) {
    const modal = document.getElementById('parallel-shortcut-editor-modal');
    const title = document.getElementById('parallel-shortcut-modal-title');
    const idInput = document.getElementById('parallel-shortcut-id-input');
    const nameInput = document.getElementById('parallel-shortcut-name-input');
    const urlInput = document.getElementById('parallel-shortcut-url-input');

    if (shortcutId) {
        const shortcut = parallelTestShortcuts.find(s => s.id === shortcutId);
        if (!shortcut) return;
        title.textContent = 'แก้ไขปุ่มลัดข้อสอบต้นฉบับ';
        idInput.value = shortcut.id;
        nameInput.value = shortcut.name;
        urlInput.value = shortcut.url || '';
    } else {
        title.textContent = 'เพิ่มปุ่มลัดข้อสอบต้นฉบับ';
        idInput.value = ''; nameInput.value = ''; urlInput.value = '';
    }
    modal.classList.remove('hidden');
}

/**
 * [Parallel Shortcuts] บันทึกการเปลี่ยนแปลงจาก Modal ลง Firebase
 */
async function saveParallelTestShortcutChanges() {
    const id = document.getElementById('parallel-shortcut-id-input').value;
    const name = document.getElementById('parallel-shortcut-name-input').value.trim();
    const url = document.getElementById('parallel-shortcut-url-input').value.trim();

    if (!name) { showMessage("กรุณากรอก 'ชื่อปุ่มลัด'"); return; }

    const newShortcutData = {
        id: id || `parallel-shortcut_${Date.now()}`,
        name: name, url: url, isDefault: id.startsWith('parallel-default-')
    };

    let updatedShortcuts;
    if (id) {
        updatedShortcuts = parallelTestShortcuts.map(s => s.id === id ? newShortcutData : s);
    } else {
        updatedShortcuts = [...parallelTestShortcuts, newShortcutData];
    }

    try {
        const prefRef = doc(db, "globalSettings", "parallelTestShortcutsConfig");
        await setDoc(prefRef, { shortcuts: updatedShortcuts }, { merge: true });
        document.getElementById('parallel-shortcut-editor-modal').classList.add('hidden');
    } catch (error) {
        console.error("Error saving parallel shortcut:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึก");
    }
}

/**
 * [Parallel Shortcuts] ฟังก์ชันหลักเมื่อคลิกที่ปุ่มลัด: โหลดไฟล์และเริ่มสร้างทันที
 */
async function handleParallelTestShortcutClick(shortcutId) {
    const shortcut = parallelTestShortcuts.find(s => s.id === shortcutId);
    if (!shortcut) return;

    if (!shortcut.url || shortcut.url.trim() === '') {
        openParallelTestShortcutEditor(shortcutId);
        return;
    }
    
    // แสดงสถานะกำลังโหลดที่ส่วนกลาง
    const loader = document.getElementById('loader');
    const loaderText = document.getElementById('loader-text');
    document.getElementById('quiz-generation-area').classList.remove('hidden');
    document.getElementById('generated-quiz-container').innerHTML = '';
    loader.classList.remove('hidden');
    loaderText.textContent = 'กำลังดึงไฟล์จากลิงก์และสร้างข้อสอบคู่ขนาน...';

try {
        // --- [START] ส่วนที่แก้ไข ---
        // ตรวจสอบนามสกุลจาก URL โดยตรงและกำหนดชื่อไฟล์ให้ถูกต้อง
        let filename;
        if (shortcut.url.toLowerCase().includes('.txt')) {
            filename = "source_document.txt";
        } else {
            // กรณีอื่นๆ ทั้งหมดให้ถือว่าเป็น PDF (ซึ่งเป็นพฤติกรรมเดิมที่ทำงานได้ดีอยู่แล้ว)
            filename = "source_document.pdf";
        }
        
        const fileObject = await fetchFileFromUrl(shortcut.url, filename);
        
        // **จุดเชื่อมต่อที่สำคัญ:** เรียกใช้ฟังก์ชัน handleGenerateParallelTest โดยตรง
        // และส่ง File object ที่ได้เข้าไปเป็นพารามิเตอร์
        await handleGenerateParallelTest(fileObject);

    } catch (error) {
        console.error("Error processing parallel shortcut click:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
        loader.classList.add('hidden'); // ซ่อนสถานะโหลดถ้ามีปัญหา
    }
}
// ▲▲▲ END: สิ้นสุดชุดฟังก์ชันใหม่ ▲▲▲

function initializeScratchpadCanvas() {
    const canvas = document.getElementById('scratchpad-canvas');
    const container = document.querySelector('.scratchpad-content-wrapper');
    if (!canvas || !container) return;

    scratchpadCtx = canvas.getContext('2d', { willReadFrequently: true });
    
    const dpr = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = `${rect.width}px`;
    canvas.style.height = `${rect.height}px`;
    scratchpadCtx.scale(dpr, dpr);

    scratchpadCtx.lineJoin = 'round';
    scratchpadCtx.lineCap = 'round';

    // ลบ Event Listeners เก่าออกก่อน
    canvas.removeEventListener('pointerdown', handlePointerDown);
    canvas.removeEventListener('pointermove', handlePointerMove);
    canvas.removeEventListener('pointerup', handlePointerUp);
    canvas.removeEventListener('pointercancel', handlePointerUp);
    canvas.removeEventListener('wheel', handleWheel);
    canvas.removeEventListener('touchstart', handlePointerDown);
    canvas.removeEventListener('touchmove', handlePointerMove);
    canvas.removeEventListener('touchend', handlePointerUp);

    // เพิ่ม Event Listeners ชุดใหม่
    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointermove', handlePointerMove);
    canvas.addEventListener('pointerup', handlePointerUp);
    canvas.addEventListener('pointercancel', handlePointerUp);
    canvas.addEventListener('wheel', handleWheel, { passive: false });
    // สำหรับ Touch (Safari/iOS)
    canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
    canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
    canvas.addEventListener('touchend', handlePointerUp, { passive: false });
}

function setupScratchpadControls() {
    const modal = document.getElementById('scratchpad-modal');
    const controlsContainer = document.getElementById('scratchpad-controls');
    
    // UI ของปุ่มควบคุมทั้งหมด (รวมปุ่มไฮไลท์, กลุ่มสี, และ Slider)
    controlsContainer.innerHTML = `
        <div class="tool-group">
            <button id="scratchpad-close-btn" class="bg-red-500 text-white w-8 h-8 rounded-md flex items-center justify-center text-base hover:bg-red-600" title="ปิดกระดานทดเลข"><i class="fas fa-times"></i></button>
        </div>
        <div class="separator"></div>
        <div class="tool-group">
            <button id="reset-view-btn" class="w-8 h-8 rounded-md flex items-center justify-center text-base border-2" title="รีเซ็ตมุมมอง"><i class="fas fa-expand-arrows-alt"></i></button>
        </div>
        <div class="separator"></div>
        <div class="tool-group">
            <button id="undo-btn" class="w-8 h-8 rounded-md flex items-center justify-center text-base border-2 disabled:opacity-50" title="ย้อนกลับ" disabled><i class="fas fa-undo"></i></button>
            <button id="redo-btn" class="w-8 h-8 rounded-md flex items-center justify-center text-base border-2 disabled:opacity-50" title="ทำซ้ำ" disabled><i class="fas fa-redo"></i></button>
        </div>
        <div class="separator"></div>
        <div class="tool-group">
            <button id="pen-tool-btn" class="tool-btn active w-8 h-8 rounded-md flex items-center justify-center text-base border-2" title="ปากกา"><i class="fas fa-pencil-alt"></i></button>
            <button id="highlighter-tool-btn" class="tool-btn w-8 h-8 rounded-md flex items-center justify-center text-base border-2" title="ปากกาไฮไลท์"><i class="fas fa-highlighter"></i></button>
            <button id="eraser-tool-btn" class="tool-btn w-8 h-8 rounded-md flex items-center justify-center text-base border-2" title="ยางลบ"><i class="fas fa-eraser"></i></button>
            <button id="trail-tool-btn" class="tool-btn w-8 h-8 rounded-md flex items-center justify-center text-base border-2" title="ปากกา Trail (จางหาย)"><i class="fas fa-signature"></i></button>
        </div>
        <div class="separator"></div>
		
		<div id="eraser-tools-group" class="tool-group hidden items-center gap-2">
            <button class="eraser-size-btn w-8 h-8 rounded-md flex items-center justify-center border-2" data-size="20" title="ยางลบขนาดเล็ก (20)">
                <div class="w-2 h-2 bg-gray-600 rounded-full pointer-events-none"></div>
            </button>
            <button class="eraser-size-btn active w-8 h-8 rounded-md flex items-center justify-center border-2" data-size="40" title="ยางลบขนาดกลาง (40)">
                <div class="w-3 h-3 bg-gray-600 rounded-full pointer-events-none"></div>
            </button>
            <button class="eraser-size-btn w-8 h-8 rounded-md flex items-center justify-center border-2" data-size="80" title="ยางลบขนาดใหญ่ (80)">
                <div class="w-4 h-4 bg-gray-600 rounded-full pointer-events-none"></div>
            </button>
        </div>

        <div id="pen-tools-group" class="tool-group items-center gap-2">
             <button class="pen-size-btn w-8 h-8 rounded-md flex items-center justify-center text-xs font-bold border-2" data-size="2" title="ขนาดเล็ก">S</button>
            <button class="pen-size-btn active w-8 h-8 rounded-md flex items-center justify-center text-sm font-bold border-2" data-size="5" title="ขนาดกลาง">M</button>
            <button class="pen-size-btn w-8 h-8 rounded-md flex items-center justify-center text-base font-bold border-2" data-size="10" title="ขนาดใหญ่">L</button>
            <div class="separator mx-1"></div>
            <button class="pen-color-btn active w-7 h-7 rounded-full border-2" data-color="#000000" style="background-color: #000000;" title="สีดำ"></button>
            <button class="pen-color-btn w-7 h-7 rounded-full border-2" data-color="#EF4444" style="background-color: #EF4444;" title="สีแดง"></button>
            <button class="pen-color-btn w-7 h-7 rounded-full border-2" data-color="#3B82F6" style="background-color: #3B82F6;" title="สีน้ำเงิน"></button>
        </div>

        <div id="highlighter-tools-group" class="tool-group hidden items-center gap-3">
            <button class="highlighter-color-btn active w-7 h-7 rounded-full border-2" data-color="rgba(255, 255, 0, 0.5)" style="background-color: yellow;" title="สีเหลือง"></button>
            <button class="highlighter-color-btn w-7 h-7 rounded-full border-2" data-color="rgba(59, 130, 246, 0.5)" style="background-color: #3B82F6;" title="สีน้ำเงิน"></button>
            <button class="highlighter-color-btn w-7 h-7 rounded-full border-2" data-color="rgba(236, 72, 153, 0.5)" style="background-color: #EC4899;" title="สีชมพู"></button>
            <button class="highlighter-color-btn w-7 h-7 rounded-full border-2" data-color="rgba(34, 197, 94, 0.5)" style="background-color: #22C55E;" title="สีเขียว"></button>
            <button class="highlighter-color-btn w-7 h-7 rounded-full border-2" data-color="rgba(249, 115, 22, 0.5)" style="background-color: #F97316;" title="สีส้ม"></button>
            <button class="highlighter-color-btn w-7 h-7 rounded-full border-2" data-color="rgba(168, 85, 247, 0.5)" style="background-color: #A855F7;" title="สีม่วง"></button>
            
            <div class="separator mx-1"></div>
            
            <i class="fas fa-text-height"></i>
            <input id="highlighter-size-slider" type="range" min="5" max="50" value="20" class="w-24 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
            <span id="highlighter-size-value" class="text-sm font-mono w-8 text-center">${scratchpadHighlighterSize}</span>
        </div>

        <div class="separator"></div>
        <div class="tool-group ml-auto">
            <button id="scratchpad-clear-btn" class="bg-yellow-500 text-white w-8 h-8 rounded-md flex items-center justify-center text-base hover:bg-yellow-600" title="ลบทั้งหมด"><i class="fas fa-trash-alt"></i></button>
        </div>
    `;
// --- ส่วนจัดการ Event Listeners ---
    const penToolBtn = document.getElementById('pen-tool-btn');
    const eraserToolBtn = document.getElementById('eraser-tool-btn');
    const trailToolBtn = document.getElementById('trail-tool-btn');
    const highlighterToolBtn = document.getElementById('highlighter-tool-btn');
    
    const penToolsGroup = document.getElementById('pen-tools-group');
    const highlighterToolsGroup = document.getElementById('highlighter-tools-group');
	const eraserToolsGroup = document.getElementById('eraser-tools-group');

    const allToolButtons = [penToolBtn, eraserToolBtn, trailToolBtn, highlighterToolBtn];

    document.getElementById('scratchpad-close-btn').addEventListener('click', () => modal.classList.add('hidden'));
    document.getElementById('reset-view-btn').addEventListener('click', () => {
        scratchpadScale = 1;
        scratchpadOffset = { x: 0, y: 0 };
        redrawScratchpad();
    });
    document.getElementById('scratchpad-clear-btn').addEventListener('click', () => {
        strokes = [];
        redoStrokes = [];
        redrawScratchpad();
        updateUndoRedoButtons();
    });
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('redo-btn').addEventListener('click', redo);

    // ฟังก์ชัน Helper สำหรับสลับโหมด
    const setActiveToolUI = (activeBtn) => {
         allToolButtons.forEach(btn => btn.classList.remove('active'));
         activeBtn.classList.add('active');
         
         // ซ่อนทุกกลุ่มเครื่องมือ
         penToolsGroup.classList.add('hidden');
         highlighterToolsGroup.classList.add('hidden');
         eraserToolsGroup.classList.add('hidden'); // <-- [เพิ่ม] ซ่อนยางลบ

         // แสดงเฉพาะกลุ่มที่เกี่ยวข้อง
         if (activeTool === 'pen' || activeTool === 'trail') {
             penToolsGroup.classList.remove('hidden');
         } else if (activeTool === 'highlighter') {
             highlighterToolsGroup.classList.remove('hidden');
         } else if (activeTool === 'eraser') {
             eraserToolsGroup.classList.remove('hidden'); // <-- [เพิ่ม] แสดงยางลบ
         }
     };

    // Event Listener สำหรับปุ่มเลือกเครื่องมือ
    penToolBtn.addEventListener('click', () => { activeTool = 'pen'; setActiveToolUI(penToolBtn); });
    eraserToolBtn.addEventListener('click', () => { activeTool = 'eraser'; setActiveToolUI(eraserToolBtn); });
    trailToolBtn.addEventListener('click', () => { activeTool = 'trail'; setActiveToolUI(trailToolBtn); });
    highlighterToolBtn.addEventListener('click', () => { activeTool = 'highlighter'; setActiveToolUI(highlighterToolBtn); });
    
    // Event Listener สำหรับเครื่องมือปากกา
    penToolsGroup.querySelectorAll('.pen-size-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            scratchpadPenSize = parseInt(e.target.dataset.size, 10);
            penToolsGroup.querySelectorAll('.pen-size-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });
    });
	
	eraserToolsGroup.querySelectorAll('.eraser-size-btn').forEach(btn => {
         btn.addEventListener('click', (e) => {
             // ใช้ currentTarget เพื่อให้แน่ใจว่าคลิกที่ปุ่ม ไม่ใช่ที่วงกลมด้านใน
             const targetBtn = e.currentTarget;
             scratchpadEraserSize = parseInt(targetBtn.dataset.size, 10);
             eraserToolsGroup.querySelectorAll('.eraser-size-btn').forEach(b => b.classList.remove('active'));
             targetBtn.classList.add('active');
         });
     });
	
    penToolsGroup.querySelectorAll('.pen-color-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            scratchpadPenColor = e.target.dataset.color;
            penToolsGroup.querySelectorAll('.pen-color-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });
    });
    
    // Event Listener สำหรับเครื่องมือไฮไลท์
    highlighterToolsGroup.querySelectorAll('.highlighter-color-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            scratchpadHighlighterColor = e.target.dataset.color;
            highlighterToolsGroup.querySelectorAll('.highlighter-color-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });
    });
    
    const highlighterSlider = document.getElementById('highlighter-size-slider');
    const highlighterSizeValue = document.getElementById('highlighter-size-value');
    highlighterSlider.addEventListener('input', (e) => {
        const newSize = parseInt(e.target.value, 10);
        scratchpadHighlighterSize = newSize; // อัปเดตตัวแปร
        highlighterSizeValue.textContent = newSize; // แสดงค่าบน UI
    });

    window.addEventListener('resize', () => {
        if (!modal.classList.contains('hidden')) {
            initializeScratchpadCanvas();
            redrawScratchpad();
        }
    });
} // <-- ปิดฟังก์ชัน setupScratchpadControls    

        // Gamification Constants
        const BADGES = {
            PERFECT_SCORE: { id: 'perfect_score', name: 'คะแนนเต็ม', description: 'ตอบถูกทุกข้อในแบบทดสอบนี้', icon: 'fa-crown text-yellow-500' },
            QUICK_THINKER: { id: 'quick_thinker', name: 'เซียนสมองไว', description: 'ทำแบบทดสอบเสร็จเร็วกว่าครึ่งของเวลาที่กำหนด', icon: 'fa-bolt text-blue-500' },
            ON_FIRE: { id: 'on_fire', name: 'ท็อปฟอร์ม', description: 'ตอบถูก 3 ข้อติดต่อกัน', icon: 'fa-fire text-orange-500' },
            FIRST_TRY_ACE: { id: 'first_try_ace', name: 'ผ่านฉลุย', description: 'ทำคะแนนเต็มในการทำครั้งแรก', icon: 'fa-rocket text-purple-500' },
            COMEBACK_KING: { id: 'comeback_king', name: 'ราชาคัมแบ็ก', description: 'สอบตกในครั้งแรก แต่กลับมาสอบผ่านได้', icon: 'fa-shield-alt text-gray-600' },
            SPECIALIST: { id: 'specialist', name: 'ผู้เชี่ยวชาญ', description: 'ได้คะแนนเต็มในทุกแบบทดสอบของโปรเจค', icon: 'fa-user-astronaut text-blue-700' },
            PERSEVERANCE: { id: 'perseverance', name: 'ผู้ไม่ยอมแพ้', description: 'ทำแบบทดสอบเดียวกันครบ 5 ครั้ง', icon: 'fa-dumbbell text-gray-700' }
        };

        // Use the config provided by the environment, with a fallback for local development
const firebaseConfig = {
  apiKey: "AIzaSyCQlVzy_LBImNp5TJNwRuepFzvxWm8AyZk",
  authDomain: "ai-quiz-app-aefee.firebaseapp.com",
  projectId: "ai-quiz-app-aefee",
  storageBucket: "ai-quiz-app-aefee.firebasestorage.app",
  messagingSenderId: "274192258111",
  appId: "1:274192258111:web:4120c9118229b5644dd48a",
  measurementId: "G-V90KRM0L63"
};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'ai-quiz-generator-v3';

        // --- DOM Elements ---
        const adminView = document.getElementById('admin-view');
        const studentView = document.getElementById('student-view');
        const projectDashboardView = document.getElementById('project-dashboard-view');
        const projectDetailView = document.getElementById('project-detail-view');
        const quizResultsView = document.getElementById('quiz-results-view');
        const projectList = document.getElementById('project-list');
        const noProjectsMsg = document.getElementById('no-projects-msg');
        const projectTitle = document.getElementById('project-title');
        const projectIdDisplay = document.getElementById('project-id-display');
        const studentList = document.getElementById('student-list');
        const messageModal = document.getElementById('message-modal');
        const modalMessage = document.getElementById('modal-message');
        const createProjectModal = document.getElementById('create-project-modal');
        const adminPasswordModal = document.getElementById('admin-password-modal');
        const confirmationModal = document.getElementById('confirmation-modal');
        const userIdDisplay = document.getElementById('user-id-display');
        const topicTab = document.getElementById('topic-tab');
        const textTab = document.getElementById('text-tab');
        const topicInputArea = document.getElementById('topic-input-area');
        const textInputArea = document.getElementById('text-input-area');
        const manageTab = document.getElementById('manage-tab');
        const resultsTab = document.getElementById('results-tab');
        const leaderboardTab = document.getElementById('leaderboard-tab');
        const manageTabContent = document.getElementById('manage-tab-content');
        const resultsTabContent = document.getElementById('results-tab-content');
        const leaderboardTabContent = document.getElementById('leaderboard-tab-content');
        const projectQuizzesList = document.getElementById('project-quizzes-list');
        const fileTab = document.getElementById('file-tab');
        const fileInputArea = document.getElementById('file-input-area');
        const fileUploadInput = document.getElementById('file-upload-input');
        const worksheetTab = document.getElementById('worksheet-tab');
        
        const worksheetInputArea = document.getElementById('worksheet-input-area');
        const generateWorksheetBtn = document.getElementById('generate-worksheet-btn');
        // Student view elements
        const studentInitialView = document.getElementById('student-initial-view');
        const studentNameSelectionView = document.getElementById('student-name-selection-view');
        const studentQuizArea = document.getElementById('student-quiz-area');
        const studentResultArea = document.getElementById('student-result-area');
        const studentReadingArea = document.getElementById('student-reading-area');
        const loadQuizBtn = document.getElementById('load-quiz-btn');
        const startQuizBtn = document.getElementById('start-quiz-btn');
        const studentJoinGameView = document.getElementById('student-join-game-view');
        
        // Presentation Mode elements
        const presentationModal = document.getElementById('presentation-modal');

        // Modals
        const renameQuizModal = document.getElementById('rename-quiz-modal');
        const moveQuizModal = document.getElementById('move-quiz-modal');
        const quizSettingsModal = document.getElementById('quiz-settings-modal');
        const quizStatusModal = document.getElementById('quiz-status-modal');

        // Live Game View
        const liveGameView = document.getElementById('live-game-view');

/**
 * ฟังก์ชันสำหรับสแกนและแก้ไขโค้ด LaTeX ที่ผิดพลาดโดยอัตโนมัติ
 * (เวอร์ชันสำหรับหน้าต่างบทเรียนโดยเฉพาะ)
 */
function handleFixLessonLatex() {
  // 1. กำหนดเป้าหมายไปที่ Element ที่ครอบเนื้อหาบทเรียนทั้งหมด
  const root = document.getElementById('lesson-view-content');
  if (!root) {
      showMessage('ไม่พบเนื้อหาบทเรียนที่จะแก้ไข');
      return;
  }

  // 2. ค้นหา Element ที่มีโอกาส содержатьข้อความคณิตศาสตร์ภายในบทเรียน
  const nodes = root.querySelectorAll([
    '.ai-content p',
    '.ai-content li',
    '.ai-content blockquote',
    '.ai-content td',
    '.ai-content h3'
  ].join(','));

  let totalChanges = 0;

  // ---------- ฟังก์ชัน Helper (นำมาจาก handleAutoFixLatex เดิม) ----------
  const getText = el => el.textContent || '';
  const setText = (el, s) => {
    // ป้องกันการเขียนทับ Element ที่ MathJax แปลงไปแล้ว
    if (el.querySelector && el.querySelector('mjx-container')) return;
    el.textContent = s;
  };

  const normalize = s =>
    s.replace(/\u00A0/g, ' ')
     .replace(/\u200B/g, '')
     .replace(/\r\n?/g, '\n');

  // Regex สำหรับตรวจสอบว่าข้อความมีแนวโน้มเป็นคณิตศาสตร์หรือไม่
  const latexTokenLike =
    /[\^_\\]|\b(?:frac|dfrac|tfrac|sqrt|text|times|cdot|div|leq|geq|le|ge|neq|pm|approx|sin|cos|tan|log|ln|sum|prod|binom|overline|underline|left|right|ext|circ|deg)\b|[°×÷≤≥≠±·√∑]/;

  // ฟังก์ชันสำหรับแก้ไขโค้ด LaTeX ภายในเครื่องหมาย $...$
  const fixLatexContent = (content) => {
    let t = content.trim();
    const macros = [
      'frac','dfrac','tfrac','sqrt','text','times','cdot','div','leq','geq','le','ge',
      'neq','pm','approx','sin','cos','tan','log','ln','sum','prod','binom',
      'left','right','overline','underline','circ','deg'
    ];
    macros.forEach(m => {
      t = t.replace(new RegExp(`(^|[^\\\\])\\b${m}\\b`, 'g'), (_m, p1) => `${p1}\\${m}`);
    });
    const uniMap = [
      [/×/g, '\\times'], [/·/g, '\\cdot'], [/÷/g, '\\div'],
      [/≤/g, '\\le'],    [/≥/g, '\\ge'],   [/≠/g, '\\neq'],
      [/±/g, '\\pm'],    [/∑/g, '\\sum'],  [/−/g, '-']
    ];
    uniMap.forEach(([re, rep]) => { t = t.replace(re, rep); });
    t = t.replace(/√\s*([A-Za-z0-9]+)/g, '\\sqrt{$1}');
    t = t.replace(/(\d+)\s*%/g, '$1\\%');
    return t;
  };

  // ฟังก์ชันสำหรับครอบ $...$ ให้กับข้อความคณิตศาสตร์ที่ยังไม่มี
  const wrapBareMath = (seg) => {
    if (/\$|\\\(|\\\[/.test(seg)) return seg;
    if (!latexTokenLike.test(seg)) return seg;
    const lead = seg.match(/^\s*/)[0];
    const tail = seg.match(/\s*$/)[0];
    const core = seg.trim();
    return `${lead}$${fixLatexContent(core)}$${tail}`;
  };

  // ---------- เริ่มกระบวนการแก้ไข ----------
  nodes.forEach(el => {
    const original = getText(el);
    let s = normalize(original);

    // 1. ซ่อมภายในตัวคั่น $...$ ที่มีอยู่แล้ว
    s = s.replace(/\$([^$]*?)\$/g, (_m, inner) => `$${fixLatexContent(inner)}$`);

    // 2. ตรวจจับและครอบ $...$ ให้กับส่วนที่น่าจะเป็นคณิตศาสตร์แต่ยังไม่มี
    // (ใช้ Logic แบบง่ายๆ โดยการแยกข้อความด้วยช่องว่าง)
    const parts = s.split(/(\s+)/);
    const newParts = parts.map(part => {
        if (/\s+/.test(part)) return part; // ถ้าเป็นช่องว่าง ให้คงไว้
        return wrapBareMath(part);
    });
    s = newParts.join('');
    
    // 3. ถ้ามีการเปลี่ยนแปลง ให้เขียนทับเนื้อหาเดิม
    if (s !== original) {
      setText(el, s);
      totalChanges++;
    }
  });

  // ---------- สรุปผลและสั่ง Render ใหม่ ----------
  if (totalChanges > 0) {
    showMessage(`แก้ไขสูตรคณิตศาสตร์ ${totalChanges} จุดเรียบร้อยแล้ว`);
    try {
      // สั่งให้ MathJax ทำการสแกนและแปลงสูตรใหม่อีกครั้ง
      // โดยระบุเป้าหมายไปที่ `root` (หน้าต่างบทเรียน) เท่านั้น
      if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise([root]);
      }
    } catch (e) {
        console.error("MathJax re-render failed:", e);
    }
  } else {
    showMessage('ไม่พบรูปแบบสูตรที่ต้องแก้ไขเพิ่มเติม');
  }
}

// ▼▼▼ วางโค้ดนี้ทับฟังก์ชัน handleAutoFixLatex เดิมทั้งหมด ▼▼▼
function handleAutoFixLatex() {
  const root = document.getElementById('quiz-editor-questions-container') || document;
  const nodes = root.querySelectorAll('textarea, input[type="text"], [contenteditable="true"], [role="textbox"], .ql-editor, label, .choice-text, .option-text, .answer-text, p, li');
  let totalChanges = 0;

  const getText = el => ('value' in el ? String(el.value) : (el.innerText !== undefined ? el.innerText : (el.textContent || '')));
  const setText = (el, s) => {
    if ('value' in el) { el.value = s; return; }
    if (el.querySelector && el.querySelector('mjx-container')) return;
    if (el.innerText !== undefined) el.innerText = s; else el.textContent = s;
  };

  const normalize = s => s.replace(/\u00A0/g, ' ').replace(/\u200B/g, '').replace(/\r\n?/g, '\n');

  const latexTokenLike = /[\^_\\]|\b(?:frac|sqrt|times|cdot|div|leq|geq|neq|pm|sin|cos|tan|log|ln)\b|[×÷≤≥≠±·√]/;

  const fixLatexContent = (content) => {
    let t = content.trim();
    // *** START: ส่วนแก้ไขที่สำคัญที่สุด ***
    // แก้ไข frac ที่ไม่มี backslash และอยู่ในรูปแบบต่างๆ เช่น frac12, frac{1}{2}
    t = t.replace(/\bfrac\{?(\d+)\}?\{?(\d+)\}?/g, '\\frac{$1}{$2}');
    t = t.replace(/\bfrac(\d)(\d)/g, '\\frac{$1}{$2}');
    // *** END: ส่วนแก้ไขที่สำคัญที่สุด ***

    const macros = ['frac','sqrt','times','cdot','div','leq','geq','neq','pm','sin','cos','tan','log','ln'];
    macros.forEach(m => {
      t = t.replace(new RegExp(`(^|[^\\\\])\\b${m}\\b`, 'g'), (_m, p1) => `${p1}\\${m}`);
    });
    const uniMap = [[/×/g, '\\times'], [/·/g, '\\cdot'], [/÷/g, '\\div'], [/≤/g, '\\le'], [/≥/g, '\\ge'], [/≠/g, '\\neq'], [/±/g, '\\pm']];
    uniMap.forEach(([re, rep]) => { t = t.replace(re, rep); });
    return t;
  };

  const wrapBareMath = (seg) => {
    if (/\$|\\\(|\\\[/.test(seg)) return seg;
    if (!latexTokenLike.test(seg)) return seg;
    const lead = seg.match(/^\s*/)[0];
    const tail = seg.match(/\s*$/)[0];
    const core = seg.trim();
    return `${lead}$${fixLatexContent(core)}$${tail}`;
  };

  nodes.forEach(el => {
    const original = getText(el);
    let s = normalize(original);
    s = s.replace(/\$([^$]*?)\$/g, (_m, inner) => `$${fixLatexContent(inner)}$`);
    const parts = s.split(/(\s+)/);
    const newParts = parts.map(part => (/\s+/.test(part) ? part : wrapBareMath(part)));
    s = newParts.join('');
    if (s !== original) { setText(el, s); totalChanges++; }
  });

  if (totalChanges > 0) {
    showMessage(`แก้ไขโค้ดคณิตศาสตร์อัตโนมัติ ${totalChanges} จุด`);
    try {
      if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
    } catch (_) {}
  } else {
    showMessage('ไม่พบรูปแบบที่ต้องแก้ไขเพิ่มเติม');
  }
}

async function listenForCustomMathTopics() {
    // if (!userId) return; // ไม่จำเป็นต้องเช็ค userId แล้ว เพราะเป็นข้อมูลสาธารณะ
    const customTopicsRef = collection(db, `artifacts/${appId}/public/data/customMathTopics`);

    onSnapshot(customTopicsRef, (snapshot) => {
        customMathTopics = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        // เมื่อข้อมูลอัปเดต ให้วาดรายการหัวข้อใหม่
        renderTopicCheckboxes(); 
    }, (error) => {
        console.error("Error listening for custom math topics:", error);
    });
}

function handleSelectAllTopics() {
        const container = document.getElementById('math-topics-checkbox-container');
        const checkboxes = container.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => {
            cb.checked = true;
        });
        // อัปเดตจำนวนที่เลือก
        updateSelectedTopicsCount();
    }

    function handleDeselectAllTopics() {
        const container = document.getElementById('math-topics-checkbox-container');
        const checkboxes = container.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => {
            cb.checked = false;
        });
        // อัปเดตจำนวนที่เลือก
        updateSelectedTopicsCount();
    }
	
	/**
 * จัดการการลบหัวข้อคณิตศาสตร์ที่ผู้ใช้สร้างเอง
 * @param {string} topicId - ID ของเอกสารหัวข้อใน Firestore
 */
async function handleDeleteCustomTopic(topicId) {
    if (!topicId) return;

    try {
        const topicRef = doc(db, `artifacts/${appId}/public/data/customMathTopics`, topicId);
        await deleteDoc(topicRef);
        showMessage("ลบหัวข้อสำเร็จ");
        // ไม่ต้อง re-render เอง เพราะ onSnapshot จะตรวจจับการเปลี่ยนแปลงและ re-render ให้อัตโนมัติ
    } catch (error) {
        console.error("Error deleting custom topic:", error);
        showMessage("เกิดข้อผิดพลาดในการลบหัวข้อ");
    }
}

async function handleAddCustomMathTopic() {
    const input = document.getElementById('custom-math-topic-input');
    const topicName = input.value.trim();

    if (!topicName) {
        showMessage("กรุณาป้อนชื่อหัวข้อที่ต้องการเพิ่ม");
        return;
    }
    if (!userId) {
        showMessage("ไม่พบข้อมูลผู้ใช้ ไม่สามารถบันทึกได้");
        return;
    }

    try {
        const customTopicsRef = collection(db, `artifacts/${appId}/public/data/customMathTopics`);
        await addDoc(customTopicsRef, {
            name: topicName,
            createdAt: serverTimestamp()
        });
        input.value = ''; // ล้างช่องกรอกข้อมูล
        showMessage(`เพิ่มหัวข้อ "${topicName}" สำเร็จ`);
    } catch (error) {
        console.error("Error adding custom topic:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึกหัวข้อ");
    }
}

// ▼▼▼ เพิ่มฟังก์ชันใหม่นี้เข้าไปทั้งหมด ▼▼▼
/**
 * ฟังก์ชันสำหรับสแกนและอัปเดตแบบทดสอบเก่าที่ยังไม่มี ID ในแต่ละคำถาม
 */
async function handleUpdateOldQuizzes() {
    showConfirmation(
        'คุณต้องการเริ่มกระบวนการอัปเดต ID ให้กับคำถามในแบบทดสอบเก่าทั้งหมดหรือไม่? กระบวนการนี้จะทำเพียงครั้งเดียวและปลอดภัยต่อข้อมูลของคุณ',
        async () => {
            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loader-text');
            const originalText = loaderText.textContent;
            
            // แสดงสถานะกำลังทำงาน
            loader.classList.remove('hidden');
            loaderText.textContent = 'กำลังสแกนหาแบบทดสอบเก่า...';

            try {
                const quizzesRef = collection(db, `artifacts/${appId}/public/data/quizzes`);
                const snapshot = await getDocs(quizzesRef);
                
                if (snapshot.empty) {
                    showMessage("ไม่พบแบบทดสอบในระบบเลย");
                    return;
                }

                const batch = writeBatch(db);
                let quizzesToUpdateCount = 0;

                snapshot.forEach(docSnap => {
                    const quizData = docSnap.data();
                    const quizId = docSnap.id;
                    
                    // ตรวจสอบว่าแบบทดสอบนี้เป็นเวอร์ชันเก่าหรือไม่
                    // (โดยดูว่าคำถามข้อแรกมี property 'id' หรือไม่)
                    if (quizData.questions && quizData.questions.length > 0 && !quizData.questions[0].hasOwnProperty('id')) {
                        console.log(`พบแบบทดสอบเก่าที่ต้องอัปเดต: ${quizId} (${quizData.topic})`);
                        quizzesToUpdateCount++;
                        
                        // สร้าง Array ของคำถามชุดใหม่ที่มี ID แล้ว
                        const updatedQuestions = quizData.questions.map((q, index) => {
                            // ถ้ายังไม่มี ID ให้สร้างใหม่, ถ้ามีอยู่แล้วให้ใช้ค่าเดิม
                            return {
                                ...q,
                                id: q.id || `q_${Date.now()}_${quizId}_${index}` 
                            };
                        });
                        
                        // เพิ่มการอัปเดตนี้เข้าไปใน Batch
                        const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
                        batch.update(quizRef, { questions: updatedQuestions });
                    }
                });

                if (quizzesToUpdateCount > 0) {
                    loaderText.textContent = `กำลังอัปเดตแบบทดสอบ ${quizzesToUpdateCount} รายการ...`;
                    await batch.commit(); // ส่งการแก้ไขทั้งหมดขึ้น Firestore ในครั้งเดียว
                    showMessage(`อัปเดตแบบทดสอบเก่า ${quizzesToUpdateCount} รายการสำเร็จ!`);
                } else {
                    showMessage("ไม่พบแบบทดสอบเก่าที่ต้องอัปเดต ทุกอย่างเป็นเวอร์ชันล่าสุดแล้ว");
                }

            } catch (error) {
                console.error("Error updating old quizzes:", error);
                showMessage(`เกิดข้อผิดพลาดในการอัปเดต: ${error.message}`);
            } finally {
                // ซ่อนสถานะกำลังทำงาน
                loader.classList.add('hidden');
                loaderText.textContent = originalText;
            }
        }
    );
}

// ▼▼▼ วางทับฟังก์ชัน handleBulkUpdateQuizSettings เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
async function handleBulkUpdateQuizSettings() {
    const newSettings = {
        shuffle: document.getElementById('bulk-shuffle-select').value,
        resultsDisplay: document.getElementById('bulk-results-display-select').value,
        loopUntilPass: document.getElementById('bulk-loop-until-pass-checkbox').checked,
        isConfidenceScoringEnabled: document.getElementById('bulk-confidence-scoring-checkbox').checked,
        confidenceMode: document.getElementById('bulk-confidence-mode-select').value
    };

    try {
        // ▼▼▼ เพิ่มโค้ดส่วนนี้เพื่อดึงข้อมูลล่าสุด ▼▼▼
        showMessage("กำลังตรวจสอบรายการแบบทดสอบล่าสุด...");
        const quizzesQuery = await getDocs(collection(db, `artifacts/${appId}/public/data/quizzes`));
        const liveQuizzes = quizzesQuery.docs.map(doc => ({ id: doc.id, data: doc.data() }));
        const totalQuizzes = liveQuizzes.length;
        // ▲▲▲ สิ้นสุดส่วนที่เพิ่ม ▲▲▲

        showConfirmation(
            `คุณแน่ใจหรือไม่ว่าต้องการอัปเดตการตั้งค่านี้ให้กับแบบทดสอบทั้งหมด ${totalQuizzes} ชุด? การกระทำนี้ไม่สามารถย้อนกลับได้`,
            async () => {
                const confirmBtn = document.getElementById('confirm-bulk-quiz-settings-btn');
                confirmBtn.disabled = true;
                confirmBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>กำลังอัปเดต...`;

                try {
                    const batch = writeBatch(db);
                    
                    // ใช้ข้อมูลล่าสุดที่เพิ่งดึงมา (liveQuizzes) แทน allQuizzesGlobal
                    liveQuizzes.forEach(quizDoc => {
                        const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizDoc.id);
                        const updatedSettings = { ...(quizDoc.data.settings || {}), ...newSettings };
                        batch.update(quizRef, { settings: updatedSettings });
                    });

                    await batch.commit();
                    
                    document.getElementById('bulk-quiz-settings-modal').classList.add('hidden');
                    showMessage(`อัปเดตการตั้งค่าของแบบทดสอบ ${totalQuizzes} ชุดสำเร็จ!`);

                } catch (error) {
                    console.error("Error during bulk quiz settings update (inside confirmation):", error);
                    showMessage("เกิดข้อผิดพลาดขณะกำลังบันทึกข้อมูลแบบกลุ่ม");
                } finally {
                    confirmBtn.disabled = false;
                    confirmBtn.innerHTML = 'ยืนยันและอัปเดตทั้งหมด';
                }
            }
        );

    } catch (fetchError) {
        console.error("Error fetching quizzes for bulk update:", fetchError);
        showMessage("เกิดข้อผิดพลาดในการดึงรายการแบบทดสอบล่าสุด");
    }
}

/**
 * จัดการการบันทึกชื่อโปรเจคใหม่หลังจากแก้ไข
 */
async function handleSaveProjectName() {
    const projectTitleEl = document.getElementById('project-title');
    const saveBtn = document.getElementById('save-project-name-btn');
    const newName = projectTitleEl.textContent.trim();

    if (!newName || !currentProjectId) {
        showMessage("ชื่อโปรเจคห้ามว่าง");
        projectTitleEl.textContent = currentProjectData.projectName; // คืนค่าเดิม
        return;
    }

    saveBtn.disabled = true;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

    try {
        const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, currentProjectId);
        await updateDoc(projectRef, { projectName: newName });

        // อัปเดตข้อมูลใน state ปัจจุบันด้วย
        if(currentProjectData) {
            currentProjectData.projectName = newName;
        }

        showMessage("เปลี่ยนชื่อโปรเจคสำเร็จ");
    } catch (error) {
        console.error("Error updating project name:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึก");
        projectTitleEl.textContent = currentProjectData.projectName; // คืนค่าเดิม
    } finally {
        saveBtn.classList.add('hidden');
        saveBtn.disabled = false;
        saveBtn.innerHTML = '<i class="fas fa-save mr-2"></i>บันทึก';
    }
}

// ✅ ฟังก์ชันใหม่ 1: จัดการ UI สำหรับสร้างแบบทดสอบ
function handleGeneratePracticeTest(topic, grade) {
    const modal = document.getElementById('lesson-view-modal');
    const titleEl = document.getElementById('lesson-view-title');
    const loaderEl = document.getElementById('lesson-loader');
    const contentContainer = document.getElementById('lesson-sections-container');

    // 1. Reset และแสดง Modal พร้อม Loader
    titleEl.textContent = `กำลังสร้างแบบทดสอบ: ${topic}`;
    contentContainer.classList.add('hidden');
    loaderEl.classList.remove('hidden');
    modal.classList.remove('hidden');

    // 2. เรียกฟังก์ชัน generator ตัวใหม่
    generatePracticeTest(topic, grade).catch(err => {
        console.error("Failed to generate practice test:", err);
        showMessage("ขออภัย, ไม่สามารถสร้างแบบทดสอบสำหรับหัวข้อนี้ได้");
        modal.classList.add('hidden');
    });
}

// ✅ ฟังก์ชันใหม่ 2: เรียก API และแสดงผลเฉพาะส่วนแบบทดสอบ
async function generatePracticeTest(topic, gradeLevel) {
    // ซ่อนทุกส่วนของบทเรียนก่อน
    ['pointContent', 'memoryContent', 'applicationContent', 'summaryContent'].forEach(id => {
        const parentSection = document.getElementById(id).parentElement;
        if (parentSection) {
            parentSection.style.display = 'none';
        }
    });

    try {
        const onetFocusPrompt = `โดยเน้นสร้างโจทย์ที่สอดคล้องกับแนวทางข้อสอบ O-NET สำหรับระดับชั้นนี้อย่างเคร่งครัด`;
        const appPrompt = `สร้างแบบฝึกหัดแบบปรนัย 4 ตัวเลือก จำนวน 5 ข้อ สำหรับนักเรียนระดับชั้น '${gradeLevel}' ในหัวข้อ '${topic}'. โจทย์และตัวเลือกต้องมีความซับซ้อนใกล้เคียงกับแนวข้อสอบ O-NET จริงๆ. ระบุคำตอบที่ถูกต้อง (เป็น index 0-3) และหากมีสูตรคณิตศาสตร์ให้ใช้รูปแบบ LaTeX`;

        const appContentJson = await callGemini(appPrompt, true);

        // --- ส่วนแสดงผล ---
        const titleEl = document.getElementById('lesson-view-title');
        const loaderEl = document.getElementById('lesson-loader');
        const contentContainer = document.getElementById('lesson-sections-container');
        const applicationSection = document.getElementById('applicationContent').parentElement;

        titleEl.innerText = `แบบทดสอบฝึกฝนเรื่อง: ${topic.replace(/•\s/g, '')} (สำหรับ ${gradeLevel})`;

        currentApplicationData = JSON.parse(appContentJson);
        const applicationContentEl = document.getElementById('applicationContent');
        applicationContentEl.innerHTML = currentApplicationData.map((q, index) => `
            <div class="application-question mb-4">
                <p class="font-semibold">${index + 1}. ${marked.parseInline(q.question)}</p>
                <div class="application-options mt-2" id="q${index}-options">
                    ${q.options.map((opt, optIndex) => `
                        <button class="w-full text-left p-2 border rounded-md mt-1 hover:bg-gray-100" onclick="checkAnswer(${index}, ${optIndex})">${String.fromCharCode(97 + optIndex)}. ${marked.parseInline(opt)}</button>
                    `).join('')}
                </div>
            </div>
        `).join('');

        if (window.MathJax) {
            MathJax.typesetPromise([applicationContentEl]);
        }

        // แสดงเฉพาะส่วน APPLICATION
        if (applicationSection) {
            applicationSection.style.display = 'block';
        }

        loaderEl.classList.add('hidden');
        contentContainer.classList.remove('hidden');

    } catch (error) {
        console.error(error);
        throw error;
    }
}

async function callGemini(prompt, isJson = false) {
    const apiKey = "AIzaSyB8ziZtJkPE4_53A4djxRjAXI_DDOP_vdg";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
    
    const payload = { contents: [{ parts: [{ text: prompt }] }] };

    if (isJson) {
        payload.generationConfig = { responseMimeType: "application/json" };
        if (prompt.includes("Test Blueprint")) {
            payload.generationConfig.responseSchema = {
                type: "OBJECT",
                properties: {
                    "gradeLevel": { "type": "STRING" },
                    "curriculum": {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "sara": { "type": "STRING" },
                                "mainTopics": {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            "topicName": { "type": "STRING" },
                                            "subTopics": { "type": "ARRAY", "items": { "type": "STRING" } }
                                        },
                                        required: ["topicName", "subTopics"]
                                    }
                                }
                            },
                            required: ["sara", "mainTopics"]
                        }
                    }
                },
                required: ["gradeLevel", "curriculum"]
            };
        } else {
             payload.generationConfig.responseSchema = {
                 type: "ARRAY",
                 items: {
                     type: "OBJECT",
                     properties: { "question": { "type": "STRING" }, "options": { "type": "ARRAY", "items": { "type": "STRING" } }, "answer": { "type": "NUMBER" } },
                     required: ["question", "options", "answer"]
                 }
             };
        }
    }

    try {
        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) {
            const errorBody = await response.text();
            console.error("API Error Body:", errorBody);
            throw new Error(`API call failed with status: ${response.status}`);
        }
        const result = await response.json();
        if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
             return result.candidates[0].content.parts[0].text;
        } else {
            console.error("Unexpected API response structure:", result);
            if (result.candidates && result.candidates[0].finishReason === 'SAFETY') return JSON.stringify({ error: "เนื้อหาที่สร้างขึ้นถูกบล็อกเนื่องจากนโยบายความปลอดภัย" });
            throw new Error("Invalid response structure from API.");
        }
    } catch (error) {
        console.error("Error calling Gemini API:", error);
        throw error;
    }
}

async function generateLesson(topicOverride = null, gradeLevelOverride = null) {
    const topic = topicOverride;
    const gradeLevel = gradeLevelOverride || 'ไม่ระบุ';
    const lessonLoader = document.getElementById('lesson-loader');
    const lessonLoaderText = document.getElementById('lesson-loader-text');
    lessonLoaderText.textContent = `AI กำลังสร้างบทเรียนเรื่อง "${topic}"...`;

    try {
        let extraParts = [];
        const referenceFileUrl = document.getElementById('bp-reference-file-url')?.value.trim();

        if (referenceFileUrl) {
            try {
                lessonLoaderText.textContent = 'กำลังดึงไฟล์ O-NET อ้างอิงจากลิงก์...';
                const referenceFile = await fetchFileFromUrl(referenceFileUrl, "reference_onet.pdf");
                const refBase64 = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(referenceFile);
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                });
                extraParts.push({ inlineData: { mimeType: referenceFile.type, data: refBase64 } });
            } catch (fileError) {
                console.error("Could not fetch reference file, proceeding without it.", fileError);
                showMessage("ไม่สามารถดึงไฟล์อ้างอิงได้ ระบบจะสร้างบทเรียนตามปกติ");
            }
        }

        const onetStyleInstruction = `
        **[กฎควบคุมความซับซ้อน (Complexity Control Rule) - สำคัญที่สุด!]**
        นี่คือกฎที่สำคัญที่สุด: หากมี "ไฟล์ข้อสอบ O-NET ต้นฉบับ" (ไฟล์อ้างอิง) แนบมาด้วย ภารกิจหลักของคุณคือการสร้าง **"บทเรียน"** ที่มีเนื้อหา, สูตร, และตัวอย่าง ที่ **"เพียงพอและไม่ยากเกินกว่า"** ที่จะใช้แก้โจทย์ในไฟล์อ้างอิงนั้น

        **ห้าม (DO NOT)** สร้างเนื้อหาบทเรียน, สูตรลัด, หรือตัวอย่าง ที่มีความซับซ้อนทางวิชาการ **"เกินกว่า"** ระดับความรู้ที่จำเป็นสำหรับไฟล์อ้างอิงโดยเด็ดขาด
        ให้ยึดไฟล์อ้างอิงเป็น **"เพดาน" (Ceiling)** ของขอบเขตเนื้อหาและความซับซ้อน

        **[กฎเหล็ก: ปรัชญาการสร้างเนื้อหาและโจทย์สไตล์ O-NET โดยอ้างอิงจากไฟล์]**
        บทบาท: คุณคือผู้เชี่ยวชาญด้านการออกแบบหลักสูตรคณิตศาสตร์ O-NET
        ภารกิจ: จาก "ไฟล์ข้อสอบ O-NET ต้นฉบับ" ที่แนบมานี้ (ถ้ามี) จงวิเคราะห์สไตล์, ขอบเขต, และระดับความลึกของโจทย์ที่เกี่ยวข้องกับหัวข้อ "${topic}" แล้วนำมาสร้างเนื้อหาบทเรียนและแบบฝึกหัดชุดใหม่
        
        กฎการสร้าง (ภายใต้กฎควบคุมความซับซ้อน):
        1.  **วิเคราะห์ต้นแบบ:** อ่านไฟล์ที่แนบมาเพื่อทำความเข้าใจว่าข้อสอบ O-NET จริงๆ ถามเกี่ยวกับหัวข้อ "${topic}" ในลักษณะใด
        2.  **สร้างเนื้อหาที่ตรงจุด (POINT, MEMORY):** เนื้อหาต้องสอนและสรุปเฉพาะประเด็นที่จำเป็นต่อการทำโจทย์สไตล์นั้นๆ **เท่านั้น**
        3.  **ตัวอย่างต้องสอดคล้อง (blockquote):** ตัวอย่างประกอบต้องมีลักษณะใกล้เคียงกับโจทย์ในไฟล์อ้างอิง แต่ต้องเป็นโจทย์ที่สร้างขึ้นใหม่
        4.  **แบบฝึกหัด (APPLICATION) ต้องสมมูล:** โจทย์ในส่วน APPLICATION ต้องวัดความเข้าใจในเรื่องเดียวกันและมีความยากใกล้เคียงกัน
        `;

        lessonLoaderText.textContent = `AI กำลังสร้างบทเรียนเรื่อง "${topic}"...`;

        const pointPrompt = `สร้างเนื้อหาการสอนสำหรับนักเรียนระดับชั้น '${gradeLevel}' ในหัวข้อ '${topic}' สำหรับส่วน 'POINT'. ${onetStyleInstruction}. โดยต้องมีองค์ประกอบดังนี้:\n1. ใช้ Markdown ในการจัดรูปแบบ\n2. อธิบายแนวคิดหลักอย่างน้อย 3-4 ข้อ โดยใช้ ### สำหรับหัวข้อแนวคิด\n3. ในแต่ละแนวคิดหลัก ต้องมีตัวอย่างประกอบที่ชัดเจน ใส่ตัวอย่างใน blockquote (>)\n4. ถ้ามีสูตรคณิตศาสตร์ ให้ใช้รูปแบบ LaTeX เช่น $a^2 + b^2 = c^2$\n5. เมื่ออธิบายแนวคิดทางเรขาคณิต ให้สร้างรูปภาพประกอบเป็น SVG แบบ inline ที่เรียบง่ายและชัดเจน แทนการใช้ ASCII art`;
        
        const memoryPrompt = `สำหรับหัวข้อ '${topic}', สร้างเนื้อหาสรุปสูตรหรือหลักการสำคัญสำหรับนักเรียนระดับชั้น '${gradeLevel}' ในส่วน 'MEMORY'. ${onetStyleInstruction}. ให้อยู่ในรูปแบบที่จดจำง่าย โดยใช้ Markdown table หรือ bullet points ที่เน้นข้อความสำคัญ ถ้ามีสูตรคณิตศาสตร์ ให้ใช้รูปแบบ LaTeX`;
        
        // === [UPDATED] เพิ่มกฎตัวลวงคมๆ สำหรับส่วน APPLICATION ===
        const sharpDistractorForLesson = `
        **กฎเหล็กสำหรับการสร้างตัวเลือก (Advanced Distractor Rule):**
        1. ห้ามสุ่มตัวเลขมั่วๆ มาใส่เป็นตัวหลอก
        2. ตัวเลือกที่ผิด (Distractors) ต้องออกแบบมาเพื่อดักจับ "ความผิดพลาดที่พบบ่อย" (Common Misconceptions) เช่น:
           - การคำนวณผิดในขั้นตอนสุดท้าย (Calculation Error)
           - การจำสูตรผิด หรือสลับตัวแปร (Conceptual Error)
           - ลืมแปลงหน่วย หรือตีความโจทย์ผิด (Unit/Interpretation Error)
        3. ตัวเลือกต้องดูสมเหตุสมผลและใกล้เคียงกับคำตอบจริง
        `;

        const appPrompt = `สร้างแบบฝึกหัดแบบปรนัย 4 ตัวเลือก จำนวน 5 ข้อ สำหรับนักเรียนระดับชั้น '${gradeLevel}' ในหัวข้อ '${topic}' สำหรับส่วน 'APPLICATION'. 
        ${onetStyleInstruction}. 
        ${sharpDistractorForLesson}
        ระบุคำตอบที่ถูกต้อง (เป็น index 0-3) และหากมีสูตรหรือสัญลักษณ์คณิตศาสตร์ให้ใช้รูปแบบ LaTeX`;
        
        const summaryPrompt = `สร้างเนื้อหาสรุปภาพรวมทั้งหมดของหัวข้อ '${topic}' สำหรับนักเรียนระดับชั้น '${gradeLevel}' ในหน้าเดียวอย่างกระชับสำหรับส่วน 'ONE-PAGE SUMMARY'. ${onetStyleInstruction}. ให้เหมาะสำหรับใช้เป็นแผ่นสรุปก่อนสอบ โดยต้องรวมแนวคิดสำคัญ, สูตรหลัก (ใช้ LaTeX), และตัวอย่างการนำไปใช้ที่สำคัญ โดยใช้ Markdown ในการจัดรูปแบบ`;

        const appSchema = {
            type: "ARRAY",
            items: {
                type: "OBJECT",
                properties: {
                    "question": { "type": "STRING" },
                    "options": { "type": "ARRAY", items: { "type": "STRING" } },
                    "answer": { "type": "NUMBER" }
                },
                required: ["question", "options", "answer"]
            }
        };

        const [pointContent, memoryContent, appContentData, summaryContent] = await Promise.all([
            handleApiCall([{ text: pointPrompt }, ...extraParts], "...", null, null, false),
            handleApiCall([{ text: memoryPrompt }, ...extraParts], "...", null, null, false),
            handleApiCall([{ text: appPrompt }, ...extraParts], "...", appSchema, null, false),
            handleApiCall([{ text: summaryPrompt }, ...extraParts], "...", null, null, false)
        ]);

        const appContentJson = JSON.stringify(appContentData || []); 

        const titleEl = document.getElementById('lesson-view-title');
        const contentContainer = document.getElementById('lesson-sections-container');
        titleEl.innerText = `บทเรียนเรื่อง: ${topic.replace(/•\s/g, '')} (สำหรับ ${gradeLevel})`;

        ['pointContent', 'memoryContent', 'summaryContent'].forEach(id => {
            document.getElementById(id).innerHTML = ''; 
        });
        
        document.getElementById('pointContent').innerHTML = pointContent ? marked.parse(pointContent) : '<p class="text-red-500">ไม่สามารถสร้างเนื้อหาส่วนนี้ได้</p>';
        document.getElementById('memoryContent').innerHTML = memoryContent ? marked.parse(memoryContent) : '<p class="text-red-500">ไม่สามารถสร้างเนื้อหาส่วนนี้ได้</p>';
        document.getElementById('summaryContent').innerHTML = summaryContent ? marked.parse(summaryContent) : '<p class="text-red-500">ไม่สามารถสร้างเนื้อหาส่วนนี้ได้</p>';
        
        currentApplicationData = JSON.parse(appContentJson);
        const applicationContentEl = document.getElementById('applicationContent');
        applicationContentEl.innerHTML = (currentApplicationData || []).map((q, index) => `
            <div class="application-question mb-4">
                <p class="font-semibold">${index + 1}. ${marked.parseInline(q.question || '')}</p>
                <div class="application-options mt-2" id="q${index}-options">
                    ${(q.options || []).map((opt, optIndex) => `
                        <button class="w-full text-left p-2 border rounded-md mt-1 hover:bg-gray-100" onclick="checkAnswer(${index}, ${optIndex})">${String.fromCharCode(97 + optIndex)}. ${marked.parseInline(opt || '')}</button>
                    `).join('')}
                </div>
            </div>
        `).join('') || '<p class="text-red-500">ไม่สามารถสร้างแบบทดสอบได้</p>';

        if (window.MathJax) {
            MathJax.typesetPromise([contentContainer]);
        }
        lessonLoader.classList.add('hidden');
        contentContainer.classList.remove('hidden');

    } catch (error) {
        console.error(error);
        throw error; 
    }
}
		
		        function checkAnswer(questionIndex, selectedOptionIndex) {
            const questionData = currentApplicationData[questionIndex];
            const optionsContainer = document.getElementById(`q${questionIndex}-options`);
            const buttons = optionsContainer.getElementsByTagName('button');

            for (let btn of buttons) { btn.disabled = true; }

            if (selectedOptionIndex === questionData.answer) {
                buttons[selectedOptionIndex].classList.add('correct');
            } else {
                buttons[selectedOptionIndex].classList.add('incorrect');
                buttons[questionData.answer].classList.add('correct');
            }
        }
		
window.handleGenerateAndShowLesson = handleGenerateAndShowLesson;
window.checkAnswer = checkAnswer;
window.handleGeneratePracticeTest = handleGeneratePracticeTest;
window.handleGenerateQuizFromBlueprintTopic = handleGenerateQuizFromBlueprintTopic;

// --- ตัวแปรและฟังก์ชันสำหรับ Cropper (ฉบับแก้ปัญหาหา element ไม่เจอ) ---
let cropperInstance = null;

// ฟังก์ชันสร้าง HTML ของ Modal อัตโนมัติ (ถ้ายังไม่มี)
function ensureCropperModalExists() {
    // ถ้ามีอยู่แล้ว ไม่ต้องสร้างใหม่
    if (document.getElementById('cropper-modal')) return;

    // สร้าง HTML ด้วย JavaScript และยัดใส่ body โดยตรง
    const modalHTML = `
    <div id="cropper-modal" class="fixed inset-0 bg-black bg-opacity-90 z-[70] hidden flex flex-col items-center justify-center p-4">
        <div class="relative w-full max-w-4xl h-[70vh] bg-black flex items-center justify-center">
            <img id="image-to-crop" src="" class="max-w-full max-h-full block" style="display: block; max-width: 100%;">
        </div>
        <div class="flex gap-4 mt-4">
            <button id="cancel-crop-btn" class="bg-gray-500 text-white py-2 px-6 rounded-lg hover:bg-gray-600 font-bold">
                <i class="fas fa-times"></i> ยกเลิก
            </button>
            <button id="confirm-crop-btn" class="bg-green-600 text-white py-2 px-6 rounded-lg hover:bg-green-700 font-bold shadow-lg transform transition hover:scale-105">
                <i class="fas fa-crop-alt"></i> ตัดส่วนนี้ & สแกน
            </button>
        </div>
    </div>`;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // ผูก Event Listener ให้ปุ่มที่เพิ่งสร้าง
    setupCropperButtons();
}

function setupCropperButtons() {
    // ปุ่มยกเลิก
    document.getElementById('cancel-crop-btn').addEventListener('click', () => {
        document.getElementById('cropper-modal').classList.add('hidden');
        if (cropperInstance) {
            cropperInstance.destroy();
            cropperInstance = null;
        }
        document.getElementById('camera-input').value = '';
    });

    // ปุ่มยืนยัน
    document.getElementById('confirm-crop-btn').addEventListener('click', () => {
        if (!cropperInstance) return;
        const confirmBtn = document.getElementById('confirm-crop-btn');
        const originalText = confirmBtn.innerHTML;
        confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังประมวลผล...';
        confirmBtn.disabled = true;

        cropperInstance.getCroppedCanvas().toBlob(async (blob) => {
            document.getElementById('cropper-modal').classList.add('hidden');
            
            const croppedFile = new File([blob], "cropped_image.png", { type: "image/png" });
            await handleScanImageForText(croppedFile);

            confirmBtn.innerHTML = originalText;
            confirmBtn.disabled = false;
            cropperInstance.destroy();
            cropperInstance = null;
        }, 'image/png');
    });
}

function startCropper(file) {
    // 1. เรียกใช้ฟังก์ชันนี้ก่อนเสมอ เพื่อสร้าง Modal ถ้ามันหายไป
    ensureCropperModalExists();

    const modal = document.getElementById('cropper-modal');
    const imageElement = document.getElementById('image-to-crop');
    
    // 2. อ่านไฟล์
    const reader = new FileReader();
    reader.onload = (e) => {
        // ตอนนี้ imageElement ต้องมีอยู่จริงแน่นอน 100%
        imageElement.src = e.target.result; 
        modal.classList.remove('hidden');

        if (cropperInstance) cropperInstance.destroy();

        cropperInstance = new Cropper(imageElement, {
            viewMode: 1,
            dragMode: 'move',
            autoCropArea: 0.8,
            restore: false,
            guides: true,
            center: true,
            highlight: false,
            cropBoxMovable: true,
            cropBoxResizable: true,
            toggleDragModeOnDblclick: false,
        });
    };
    reader.readAsDataURL(file);
}

// Event Listeners หลัก (วางต่อท้าย code นี้ได้เลย)
document.addEventListener('DOMContentLoaded', () => {
    const cameraInput = document.getElementById('camera-input');
    const cameraBtn = document.getElementById('camera-crop-btn');
    
    if (cameraBtn && cameraInput) {
        cameraBtn.addEventListener('click', () => {
            cameraInput.value = '';
            cameraInput.click();
        });

        cameraInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                startCropper(e.target.files[0]);
            }
        });
    }
});

async function handleScanImageForText(file) {
    const textArea = document.getElementById('text-content-input');
    const scanBtn = document.getElementById('scan-text-image-btn');
    
    if (!file) return;

    // แสดงสถานะกำลังทำงาน
    scanBtn.disabled = true;
    scanBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังอ่านรูปภาพ...';
    textArea.placeholder = "AI กำลังพยายามอ่านข้อความจากรูปภาพของคุณ กรุณารอสักครู่...";

    try {
        // 1. แปลงไฟล์รูปเป็น Base64
        const base64String = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
        });

        // 2. เตรียมคำสั่งให้ AI
        const prompt = `
            ภารกิจ: แกะข้อความจากรูปภาพนี้ (OCR)
            คำสั่ง:
            1. อ่านตัวอักษรทั้งหมดในรูปภาพ ไม่ว่าจะเป็นภาษาไทยหรืออังกฤษ
            2. จัดรูปแบบเว้นวรรคและบรรทัดให้เหมือนต้นฉบับมากที่สุด
            3. ไม่ต้องใส่คำนำหน้าอย่าง "นี่คือข้อความ" ให้ส่งคืนเฉพาะเนื้อหาในรูปเท่านั้น
        `;

        // 3. เรียกใช้ handleApiCall (ส่งไปแบบไม่มี Schema เพื่อขอ Text ล้วนๆ)
        const parts = [
            { text: prompt },
            { inlineData: { mimeType: file.type, data: base64String } }
        ];

        // ใช้ false เพื่อไม่ให้แสดงผล Quiz, และ null schema เพื่อขอ String
        const extractedText = await handleApiCall(parts, "AI กำลังสแกนข้อความ...", null, null, false);

        if (extractedText) {
            // 4. นำข้อความที่ได้มาใส่ลงใน Textarea (ต่อจากของเดิมถ้ามี)
            const currentText = textArea.value.trim();
            textArea.value = currentText ? currentText + "\n\n" + extractedText : extractedText;
            showMessage("สแกนข้อความเรียบร้อยแล้ว! คุณสามารถตรวจสอบและแก้ไขได้ก่อนสร้างแบบทดสอบ");
        } else {
            throw new Error("AI ไม่สามารถอ่านข้อความได้");
        }

    } catch (error) {
        console.error("OCR Error:", error);
        showMessage("เกิดข้อผิดพลาดในการอ่านรูปภาพ: " + error.message);
    } finally {
        // คืนค่าปุ่ม
        scanBtn.disabled = false;
        scanBtn.innerHTML = '<i class="fas fa-camera"></i> สแกนข้อความจากรูปภาพ';
        document.getElementById('scan-text-image-input').value = ''; // รีเซ็ต input
    }
}

async function initialize() {
    try {
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        setupAuthListener();
        setupEventListeners();
        showView('student'); 
        renderTopicCheckboxes();
        
        // --- [ เพิ่มบรรทัดนี้เข้าไปในตอนท้ายของ try block ] ---
        setupStudentProgressListeners();
		resumeActiveGameSession();
		listenForFileShortcuts();
		listenForParallelTestShortcuts();

    } catch (error) {
        console.error("Firebase initialization failed:", error);
        showMessage("ไม่สามารถเชื่อมต่อกับฐานข้อมูลได้");
    }
}

        async function handleVerifyAnswersInEditor() {
    const editorModal = document.getElementById('quiz-editor-modal');
    if (!editorModal) return;

    const verifyBtn = document.getElementById('verify-answers-editor-btn');
    verifyBtn.disabled = true;
    verifyBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>AI กำลังสแกนหาข้อผิดพลาด...`;

    try {
        // รวบรวมข้อมูลจากฟอร์ม
        const questionElements = editorModal.querySelectorAll('.question-editor-item');
        const verificationPayload = Array.from(questionElements).map((el, index) => {
            const questionType = el.dataset.qType;
            const questionText = el.querySelector('textarea').value;
            let options = null;
            let proposedAnswer = '';
            let correctIndex = -1;

            switch(questionType) {
                case 'multiple_choice':
                    const optionInputs = el.querySelectorAll('input[type="text"]');
                    options = Array.from(optionInputs).map(input => input.value);
                    const checkedRadioMCQ = el.querySelector('input[type="radio"]:checked');
                    if(checkedRadioMCQ) {
                        correctIndex = parseInt(checkedRadioMCQ.value);
                        proposedAnswer = options[correctIndex] || "";
                    }
                    break;
                case 'short_answer':
                case 'fill_in_no_choices':
                    options = []; 
                    proposedAnswer = el.querySelector('.ideal-answer-input').value;
                    break;
                case 'true_false':
                    options = ["true", "false"]; 
                    const checkedRadioTF = el.querySelector('input[type="radio"]:checked');
                    proposedAnswer = checkedRadioTF ? checkedRadioTF.value : '';
                    break;
                case 'matching_item':
                    options = []; 
                    proposedAnswer = el.querySelector('.correct-response-input').value;
                    break;
            }
            return { 
                questionIndex: index, 
                questionType, 
                question: questionText, 
                options, 
                proposedAnswer,
                correctIndex // ส่ง Index ที่เลือกไปด้วย เพื่อให้ AI เช็คตัวอื่นเทียบกับตัวนี้
            };
        });

        // ▼▼▼ [Prompt ใหม่: เข้มงวดเรื่องคำตอบซ้ำ] ▼▼▼
        const prompt = `
            คุณคือ "ผู้ตรวจสอบข้อสอบ" ที่มีความละเอียดสูงที่สุด
            ภารกิจของคุณคือตรวจสอบชุดข้อสอบ JSON นี้ เพื่อหาข้อผิดพลาด 2 ประเภท:
            1. **Validity:** เฉลยที่เลือกไว้ (proposedAnswer) ผิดหลักการหรือไม่?
            2. **Uniqueness (สำคัญมาก):** มีตัวเลือกอื่น (Distractors) ที่ "เผลอถูก" หรือ "กำกวม" หรือไม่? (Double Key)

            สำหรับแต่ละข้อ ให้ปฏิบัติดังนี้:
            - ตรวจสอบโจทย์และตัวเลือกทุกข้ออย่างละเอียด
            - **เงื่อนไขการให้ผ่าน (isCorrect: true):** ต้องมีคำตอบที่ถูกเพียงข้อเดียว และข้อนั้นต้องตรงกับ proposedAnswer
            
            - **เงื่อนไขการปรับตก (isCorrect: false):**
              1. ถ้า proposedAnswer ผิด
              2. หรือ **ถ้ามีตัวเลือกอื่นที่ถูกต้องทางคณิตศาสตร์ด้วย** (เช่น โจทย์ถามผลบวก แต่มีตัวเลือกถูก 2 ข้อ)
              3. หรือ ถ้าตัวเลือกซ้ำกัน
            
            - **การแก้ไข (เมื่อ isCorrect: false):**
              - คุณต้องสร้าง "newOptionsPayload" ใหม่
              - **newOptions:** สร้างอาเรย์ตัวเลือกใหม่ 4 ข้อ โดยให้มีข้อถูกเพียง 1 ข้อเท่านั้น! ส่วนอีก 3 ข้อต้องผิดแน่นอน (ห้ามกำกวม)
              - **newCorrectIndex:** ระบุตำแหน่งของข้อที่ถูกใน newOptions

            ข้อมูลที่ต้องตรวจสอบ: ${JSON.stringify(verificationPayload)}
        `;
        
        const verificationSchema = {
            type: "ARRAY",
            items: {
                type: "OBJECT",
                properties: {
                    questionIndex: { type: "NUMBER" },
                    isCorrect: { type: "BOOLEAN" },
                    justification: { type: "STRING" },
                    newOptionsPayload: { 
                        type: "OBJECT",
                        properties: {
                            newOptions: { type: "ARRAY", items: { type: "STRING" } },
                            newCorrectIndex: { type: "NUMBER" }
                        },
                        required: ["newOptions", "newCorrectIndex"]
                    }
                },
                required: ["questionIndex", "isCorrect", "justification"]
            }
        };

        const verificationResults = await callAnalysisApi(prompt, { type: "OBJECT", properties: { result: verificationSchema }, required: ["result"] });
        
        if (verificationResults && verificationResults.result) {
            displayVerificationResultsInEditor(verificationResults.result);
        } else {
            throw new Error("AI ไม่ส่งผลลัพธ์กลับมา");
        }

    } catch (error) {
        console.error("Error verifying answers in editor:", error);
        showMessage("เกิดข้อผิดพลาด: " + error.message);
    } finally {
        verifyBtn.disabled = false;
        verifyBtn.innerHTML = `<i class="fas fa-check-double mr-2"></i>ตรวจทานเฉลย (AI)`;
    }
}

        function displayVerificationResultsInEditor(results) {
            results.forEach(res => {
                const questionDiv = document.querySelector(`.question-editor-item[data-q-index="${res.questionIndex}"]`);
                if (!questionDiv) return;
                
                const oldVerification = questionDiv.querySelector('.verification-result-editor');
                if (oldVerification) oldVerification.remove();

                let resultHtml = '';

                // ▼▼▼ [เพิ่มใหม่] ตรรกะสำคัญ: ตรวจสอบว่า AI สั่งให้สร้างตัวเลือกใหม่หรือไม่ ▼▼▼
                if (res.newOptionsPayload && res.newOptionsPayload.newOptions) {
                    
                    const newOptions = res.newOptionsPayload.newOptions;
                    const newCorrectIndex = res.newOptionsPayload.newCorrectIndex;
                    const questionType = questionDiv.dataset.qType;

                    // ใช้ได้เฉพาะกับ multiple_choice
                    if (questionType === 'multiple_choice') {
                        
                        // 1. ค้นหาช่องกรอกตัวเลือกทั้งหมดในข้อนั้น
                        const optionInputs = questionDiv.querySelectorAll('input[type="text"]');
                        
                        // 2. วนลูปเขียนทับค่า (value) ของตัวเลือกเดิมด้วยตัวเลือกใหม่จาก AI
                        optionInputs.forEach((input, i) => {
                            if (newOptions[i]) {
                                input.value = newOptions[i];
                            } else {
                                // กรณีนี้น่าจะไม่เกิด แต่ใส่ไว้กันพลาด
                                input.value = "--- (AI ไม่ได้สร้างตัวเลือกนี้) ---"; 
                            }
                        });

                        // 3. ค้นหาปุ่ม Radio ที่ตรงกับเฉลยใหม่ แล้วสั่ง 'checked'
                        const radioToSelect = questionDiv.querySelector(`input[type="radio"][value="${newCorrectIndex}"]`);
                        if (radioToSelect) {
                            radioToSelect.checked = true;
                        }

                        // 4. แสดงข้อความแจ้งเตือนสีเหลือง (รุนแรงกว่า)
                        resultHtml = `
                            <div class="verification-result-editor mt-2 p-3 border-l-4 border-yellow-400 bg-yellow-50 text-yellow-800 text-sm">
                                <p class="font-bold flex items-center"><i class="fas fa-magic-wand-sparkles mr-2"></i>AI ตรวจไม่พบคำตอบที่ถูกต้อง!</p>
                                <p>ระบบได้สร้างชุดตัวเลือกใหม่ และแก้ไขเฉลยให้ถูกต้องอัตโนมัติแล้ว</p>
                            </div>`;
                        
                        // 5. ไฮไลท์การ์ดคำถามนั้นให้เป็นสีเหลืองชั่วขณะ
                        questionDiv.classList.add('bg-yellow-200', 'transition-all', 'duration-300');
                        setTimeout(() => {
                            questionDiv.classList.remove('bg-yellow-200');
                        }, 2500); // แสดงไฮไลท์ 2.5 วินาที
                    }
                
                // ▼▼▼ [แก้ไข] เพิ่ม else if เพื่อให้ตรรกะเดิมยังทำงานได้ ▼▼▼
                } else if (!res.isCorrect && res.suggestedAnswer) {
                    // (ตรรกะเดิมของคุณ: ถ้าเฉลยผิด แต่มีเฉลยในตัวเลือกอื่น)
                    const autoFixMessage = res.suggestedAnswer ? ' <strong class="text-green-600">(แก้ไขอัตโนมัติ)</strong>' : '';
                    resultHtml = `
                        <div class="verification-result-editor mt-2 p-3 border-l-4 border-red-400 bg-red-50 text-red-800 text-sm">
                            <p class="font-bold flex items-center"><i class="fas fa-exclamation-triangle mr-2"></i>AI ตรวจพบว่าเฉลยอาจไม่ถูกต้อง${autoFixMessage}</p>
                            <p><strong>เหตุผล:</strong> ${res.justification}</p>
                            ${res.suggestedAnswer ? `<p><strong>คำตอบที่แนะนำ:</strong> ${res.suggestedAnswer}</p>` : ''}
                        </div>`;
                    
                    // (ส่วน auto-fix ของคุณเหมือนเดิม)
                    const questionType = questionDiv.dataset.qType;
                    const highlightElement = (el) => {
                        if (!el) return;
                        el.classList.add('bg-green-200', 'transition-all', 'duration-300');
                        setTimeout(() => { el.classList.remove('bg-green-200'); }, 2500);
                    };

                    if (questionType === 'multiple_choice') {
                        const allOptionInputs = Array.from(questionDiv.querySelectorAll('input[type="text"]'));
                        const suggestedIndex = allOptionInputs.findIndex(opt => opt.value.trim().toLowerCase() === res.suggestedAnswer.trim().toLowerCase());
                        if (suggestedIndex !== -1) {
                            const radioToSelect = questionDiv.querySelector(`input[type="radio"][value="${suggestedIndex}"]`);
                            if (radioToSelect) {
                                radioToSelect.checked = true;
                                highlightElement(radioToSelect.closest('div'));
                            }
                        }
                    } else if (questionType === 'short_answer' || questionType === 'matching_item') {
                        const inputField = questionDiv.querySelector('.ideal-answer-input, .correct-response-input');
                        if (inputField) {
                            inputField.value = res.suggestedAnswer;
                            highlightElement(inputField);
                        }
                    } else if (questionType === 'true_false') {
                        const suggestedValue = res.suggestedAnswer.trim().toLowerCase();
                        const radioToSelect = questionDiv.querySelector(`input[type="radio"][value="${suggestedValue}"]`);
                        if (radioToSelect) {
                            radioToSelect.checked = true;
                            highlightElement(radioToSelect.closest('div'));
                        }
                    }
                } else if (res.isCorrect) {
                    // (ตรรกะเดิม: ถ้าถูกต้อง)
                    resultHtml = `
                        <div class="verification-result-editor mt-2 text-sm text-green-700 flex items-center">
                            <i class="fas fa-check-circle mr-2"></i> AI ยืนยันว่าเฉลยถูกต้อง
                        </div>`;
                }
                // ▲▲▲ [สิ้นสุดการแก้ไข] ▲▲▲

                questionDiv.insertAdjacentHTML('beforeend', resultHtml);
            });
            showMessage("ตรวจทานเฉลยเสร็จสิ้น!");
        }

        async function handleVerifyAnswers() {
            if (!currentQuizData || !currentQuizData.questions) {
                showMessage("ไม่พบข้อมูลแบบทดสอบสำหรับตรวจทาน");
                return;
            }

            const verifyBtn = document.getElementById('verify-answers-btn');
            verifyBtn.disabled = true;
            verifyBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>AI กำลังตรวจทาน...`;

            try {
                // สร้างข้อมูลสรุปสำหรับส่งให้ AI ตรวจสอบ
                const verificationPayload = currentQuizData.questions.map((q, index) => {
                    let correctAnswerText = '';
                    const questionType = q.questionType || currentQuizData.quizType;
                    switch(questionType) {
                        case 'multiple_choice':
                            correctAnswerText = q.options[q.correctAnswerIndex];
                            break;
                        case 'short_answer':
                            correctAnswerText = q.idealAnswer;
                            break;
                        case 'true_false':
                            correctAnswerText = q.correctAnswer.toString();
                            break;
                        case 'matching_item':
                             correctAnswerText = q.correctResponse;
                            break;
                    }
                    return {
                        question: q.stem || q.questionText,
                        options: q.options || null,
                        proposedAnswer: correctAnswerText
                    };
                });
                
                const prompt = `
                    คุณคือผู้ตรวจสอบข้อสอบคณิตศาสตร์ที่มีความแม่นยำสูง ภารกิจของคุณคือการตรวจทานความถูกต้องของเฉลยที่ AI สร้างขึ้น
                    สำหรับแต่ละข้อต่อไปนี้ ให้ตรวจสอบว่า "proposedAnswer" (เฉลยที่เสนอ) นั้นถูกต้องสำหรับคำถามหรือไม่
                    
                    ข้อมูล: ${JSON.stringify(verificationPayload)}

                    ให้ตอบกลับเป็น JSON array เท่านั้น โดยแต่ละ object ใน array ต้องมี key ดังนี้:
                    - "questionIndex": (number) ลำดับของข้อที่ตรวจ (เริ่มจาก 0)
                    - "isCorrect": (boolean) เฉลยที่เสนอมานั้นถูกต้องใช่หรือไม่
                    - "justification": (string) คำอธิบายสั้นๆ ว่าทำไมถึงถูกหรือผิด
                    - "suggestedAnswer": (string, optional) หากเฉลยผิด ให้เสนอคำตอบที่ถูกต้อง
                `;
                
                const verificationSchema = {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            questionIndex: { type: "NUMBER" },
                            isCorrect: { type: "BOOLEAN" },
                            justification: { type: "STRING" },
                            suggestedAnswer: { type: "STRING" }
                        },
                        required: ["questionIndex", "isCorrect", "justification"]
                    }
                };

                const verificationResults = await callAnalysisApi(prompt, { type: "OBJECT", properties: { result: verificationSchema }, required: ["result"] });
                displayVerificationResults(verificationResults.result);

            } catch (error) {
                console.error("Error verifying answers:", error);
                showMessage("เกิดข้อผิดพลาดระหว่างการตรวจทานคำตอบ");
            } finally {
                verifyBtn.disabled = false;
                verifyBtn.innerHTML = `<i class="fas fa-check-double mr-2"></i>ตรวจทานอีกครั้ง`;
            }
        }

        /**
         * แสดงผลลัพธ์การตรวจทานบน UI
         * @param {Array} results - ผลลัพธ์ที่ได้จาก AI ตรวจทาน
         */
        function displayVerificationResults(results) {
            results.forEach(res => {
                const questionDiv = document.querySelector(`div[data-question-index="${res.questionIndex}"]`);
                if (questionDiv) {
                    // ลบผลการตรวจทานเก่าออกก่อน (ถ้ามี)
                    const oldVerification = questionDiv.querySelector('.verification-result');
                    if (oldVerification) oldVerification.remove();

                    let resultHtml = '';
                    if (res.isCorrect) {
                        resultHtml = `
                            <div class="verification-result mt-2 text-sm text-green-700 flex items-center">
                                <i class="fas fa-check-circle mr-2"></i> AI ยืนยันว่าเฉลยถูกต้อง
                            </div>
                        `;
                    } else {
                        resultHtml = `
                            <div class="verification-result mt-2 p-3 border-l-4 border-red-400 bg-red-50 text-red-800 text-sm">
                                <p class="font-bold flex items-center"><i class="fas fa-exclamation-triangle mr-2"></i>AI ตรวจพบว่าเฉลยอาจไม่ถูกต้อง</p>
                                <p><strong>เหตุผล:</strong> ${res.justification}</p>
                                ${res.suggestedAnswer ? `<p><strong>คำตอบที่แนะนำ:</strong> ${res.suggestedAnswer}</p>` : ''}
                            </div>
                        `;
                    }
                    questionDiv.insertAdjacentHTML('beforeend', resultHtml);
                }
            });
            showMessage("ตรวจทานเฉลยเสร็จสิ้น!");
        }
		
		/**
 * ฟังก์ชันสำหรับเปรียบเทียบคำตอบที่เป็นตัวเลขโดยเฉพาะ
 * @param {string} userAnswer คำตอบจากผู้ใช้
 * @param {string} idealAnswer คำตอบที่ถูกต้อง
 * @returns {boolean} คืนค่า true ถ้าตัวเลขเทียบเท่ากัน
 */
function compareNumericalAnswers(userAnswer, idealAnswer) {
    // แปลง comma เป็น period และตัดตัวอักษรที่ไม่ใช่ตัวเลขออก (ยกเว้นจุดทศนิยมและเครื่องหมายลบ)
    const cleanUserStr = String(userAnswer).replace(',', '.').replace(/[^\d.-]/g, '').trim();
    const cleanIdealStr = String(idealAnswer).replace(',', '.').replace(/[^\d.-]/g, '').trim();

    // ถ้าสตริงว่างเปล่าหลังจากการล้างค่า ให้ถือว่าไม่ใช่ตัวเลข
    if (cleanUserStr === '' || cleanIdealStr === '') {
        return false;
    }

    const userNum = parseFloat(cleanUserStr);
    const idealNum = parseFloat(cleanIdealStr);

    // ตรวจสอบว่าทั้งสองค่าเป็นตัวเลขที่ถูกต้องหรือไม่
    if (isNaN(userNum) || isNaN(idealNum)) {
        return false;
    }

    // เปรียบเทียบตัวเลขโดยยอมรับค่าคลาดเคลื่อนเล็กน้อย (Epsilon) สำหรับทศนิยม
    return Math.abs(userNum - idealNum) < 0.001;
}

/**
 * [ฟังก์ชันใหม่] Helper สำหรับตรวจสอบว่าข้อความมีแนวโน้มเป็นตัวเลขหรือไม่
 * @param {string|number} str - ข้อความที่ต้องการตรวจสอบ
 * @returns {boolean}
 */
function isPotentiallyNumeric(str) {
    if (typeof str !== 'string' && typeof str !== 'number') return false;
    // แทนที่คอมม่าด้วยจุด และลบช่องว่าง
    const cleanedStr = String(str).replace(',', '.').trim();
    // ตรวจสอบว่าไม่ใช่สตริงว่าง และสามารถแปลงเป็นตัวเลขที่สมบูรณ์ได้
    return cleanedStr !== '' && !isNaN(parseFloat(cleanedStr)) && isFinite(cleanedStr);
}


async function gradeShortAnswer(userAnswer, questionData) {
    const idealAnswer = questionData.idealAnswer;

    // ทำความสะอาดข้อมูล (ตัด $ และช่องว่างหน้าหลัง)
    const cleanUserStr = String(userAnswer).replace(/\$/g, '').trim();
    const cleanIdealStr = String(idealAnswer).replace(/\$/g, '').trim();

    // --- ขั้นที่ 1: ตรวจสอบแบบตรงตัว (Exact Match) ---
    if (cleanUserStr.toLowerCase() === cleanIdealStr.toLowerCase()) {
        return true;
    }

    // --- ขั้นที่ 2: ตรวจสอบเชิงตัวเลข (Numeric Check) ---
    if (isPotentiallyNumeric(cleanUserStr) && isPotentiallyNumeric(cleanIdealStr)) {
        if (compareNumericalAnswers(cleanUserStr, cleanIdealStr)) {
            return true;
        }
    }

    // --- ขั้นที่ 3: (ปิดการใช้งาน AI) ---
    // ถ้าไม่ตรงกับ 2 ข้อบน ให้ถือว่า "ผิด" ทันที
    console.log("Exact/Numeric checks failed. AI grading is DISABLED.");
    return false; 
}
		
async function revealAnswerForAdmin(index, total) {
            // เปลี่ยนสถานะของเกมใน Firestore เพื่อบอกให้ทุกคนรู้ว่าต้องไปหน้าสรุปกราฟ
            const gameRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
            await updateDoc(gameRef, { questionStatus: 'summary_chart' });

            // ไม่ต้องทำอะไรกับหน้าจอ Admin ตรงนี้แล้ว เพราะ listenForLiveGameUpdates จะเป็นคนจัดการ
        }
		
/**
         * แสดงหน้าจอ Leaderboard 5 อันดับแรก (สำหรับ Admin) - เวอร์ชันอัปเดต
         * @param {object} gameData - ข้อมูลเกมทั้งหมดจาก Firestore
         */
        function showTop5LeaderboardView(gameData) {
            const players = Object.values(gameData.players || {}).filter(p => p.status === 'active');
            
            players.sort((a, b) => b.score - a.score);
            const top5 = players.slice(0, 5);

            const leaderboardHTML = `
                <div class="live-game-bg text-white rounded-lg p-8 flex flex-col h-full items-center justify-between">
                    <h2 class="text-4xl font-bold mb-6">ตารางคะแนน</h2>
                    
                    <div class="w-full max-w-lg space-y-3">
                        ${top5.map((player, index) => `
                            <div class="bg-black/20 p-3 rounded-lg flex justify-between items-center text-xl">
                                <span class="font-semibold">${index + 1}. ${player.name || Object.keys(gameData.players).find(key => gameData.players[key] === player)}</span>
                                <span class="font-bold">${player.score}</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <button id="goto-next-question-btn" class="bg-gray-800 hover:bg-black text-white font-bold py-3 px-8 rounded-lg text-2xl mt-8">
                        ${gameData.currentQuestionIndex + 1 === currentQuizData.questions.length ? 'สรุปผลสุดท้าย' : 'ข้อต่อไป'} <i class="fas fa-arrow-right"></i>
                    </button>
                </div>
            `;
            liveGameView.innerHTML = leaderboardHTML;

            document.getElementById('goto-next-question-btn').addEventListener('click', async () => {
                const gameRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
                const nextIndex = gameData.currentQuestionIndex + 1;
                
                if (nextIndex < currentQuizData.questions.length) {
                    const updateData = {
                        currentQuestionIndex: nextIndex,
                        questionDisplayedAt: serverTimestamp(),
                        questionStatus: 'answering'
                    };
                    Object.keys(gameData.players).forEach(playerName => {
                        updateData[`players.${playerName}.answeredCurrentQuestion`] = false;
                    });
                    await updateDoc(gameRef, updateData);
                } else {
                    await updateDoc(gameRef, { status: 'podium' });
                }
            });
        }

// โค้ดใหม่ที่ถูกต้อง (วางทับฟังก์ชันเดิมทั้งหมด)
function setupAuthListener() {
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            userId = user.uid;
            userIdDisplay.textContent = userId;

            // --- [ส่วนที่แก้ไข] ---
            // 1. อ่านค่าการตั้งค่าจาก Firestore
            const prefs = await loadUserPreferences();
            
            // 2. นำค่าที่อ่านได้มาตั้งค่าให้กับ Dropdown
            if (prefs.projectSortOrder) {
                document.getElementById('project-sort-select').value = prefs.projectSortOrder;
            }
			
			globalDashboardSettings.projectView = prefs.projectView || 'grid';

            // 3. เริ่มดึงข้อมูลโปรเจค (ซึ่งจะใช้ค่า Dropdown ที่เพิ่งตั้งไป)
            if (unsubscribeProjectsListener) unsubscribeProjectsListener();
            listenForProjects();
            listenForStarredQuizzes();
            listenForCustomMathTopics();
			listenForBlueprintShortcuts();
        } else {
            await authenticateUser();
        }
    });
}

/**
 * บันทึกการตั้งค่าของผู้ใช้ลงใน Firestore
 * @param {string} key - ชื่อของการตั้งค่า เช่น 'projectSortOrder'
 * @param {any} value - ค่าที่ต้องการบันทึก
 */
async function saveUserPreference(key, value) {
    if (!userId) return;
    try {
        const prefRef = doc(db, `artifacts/${appId}/users/${userId}/preferences/main`);
        const updateData = {};
        updateData[key] = value;
        await setDoc(prefRef, updateData, { merge: true });
    } catch (error) {
        console.error("Error saving user preference:", error);
    }
}

/**
 * อ่านการตั้งค่าของผู้ใช้จาก Firestore
 * @returns {Promise<object>} - Promise ที่จะคืนค่าเป็น object ของการตั้งค่าทั้งหมด
 */
async function loadUserPreferences() {
    if (!userId) return {};
    try {
        const prefRef = doc(db, `artifacts/${appId}/users/${userId}/preferences/main`);
        const docSnap = await getDoc(prefRef);
        if (docSnap.exists()) {
            return docSnap.data();
        }
        return {}; // คืนค่า object ว่างถ้ายังไม่เคยมีการตั้งค่า
    } catch (error) {
        console.error("Error loading user preferences:", error);
        return {};
    }
}

// ▼▼▼ ADD THESE NEW FUNCTIONS TO YOUR SCRIPT ▼▼▼

/**
 * Parses indented text into the blueprint JSON structure.
 * @param {string} text - The indented text from the textarea.
 * @returns {object} - The structured curriculum data.
 */
function parseIndentedBlueprint(text) {
    const lines = text.split('\n').filter(line => line.trim() !== '');
    const curriculum = [];
    let currentSara = null;
    let currentMainTopic = null;

    lines.forEach(line => {
        const indentation = line.match(/^\s*/)[0].length;
        const content = line.trim();

        if (indentation === 0) { // This is a Sara
            currentSara = {
                sara: content,
                mainTopics: []
            };
            curriculum.push(currentSara);
            currentMainTopic = null; // Reset main topic
        } else if (indentation > 0 && indentation < 8 && currentSara) { // This is a Main Topic (e.g., 4 spaces)
            currentMainTopic = {
                topicName: content,
                subTopics: []
            };
            currentSara.mainTopics.push(currentMainTopic);
        } else if (indentation >= 8 && currentMainTopic) { // This is a Sub Topic (e.g., 8 spaces)
            currentMainTopic.subTopics.push(content);
        }
    });

    return { curriculum };
}

// ▼▼▼ วางทับฟังก์ชัน handleManualBlueprintSave เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
async function handleManualBlueprintSave() {
    const projectName = document.getElementById('manual-bp-project-name').value.trim();
    const gradeLevel = document.getElementById('manual-bp-grade-level').value.trim();
    const content = document.getElementById('manual-bp-content').value;

    if (!projectName || !gradeLevel || !content) {
        showMessage("กรุณากรอกข้อมูลให้ครบทุกช่อง");
        return;
    }

    const parsedData = parseIndentedBlueprint(content);

    if (!parsedData.curriculum || parsedData.curriculum.length === 0) {
        showMessage("ไม่สามารถวิเคราะห์โครงสร้างจากข้อความที่ป้อนได้");
        return;
    }

    const topicsMap = {};
    let orderIndex = 0; // <<< [เพิ่ม] ตัวแปรสำหรับนับลำดับ

    // วนลูปเพื่อสร้างข้อมูลพร้อมเพิ่ม order
    parsedData.curriculum.forEach(sara => {
        sara.mainTopics.forEach(mainTopic => {
            mainTopic.subTopics.forEach(subTopic => {
                const topicId = 'topic_' + Date.now() + Math.random().toString(36).substr(2, 9);
                topicsMap[topicId] = {
                    sara: sara.sara,
                    mainTopic: mainTopic.topicName,
                    subTopic: subTopic,
                    status: "not_generated",
                    lessonContent: null,
                    order: orderIndex++ // <<< [แก้ไข] เพิ่มลำดับเข้าไปในข้อมูล
                };
            });
        });
    });

    try {
        const projectsRef = collection(db, `artifacts/${appId}/public/data/blueprintProjects`);
        await addDoc(projectsRef, {
            projectName: projectName,
            gradeLevel: gradeLevel,
            topics: topicsMap, // บันทึกข้อมูลที่มี order แล้ว
            createdAt: serverTimestamp()
        });
        showMessage(`บันทึกโปรเจค "${projectName}" สำเร็จ!`);
        document.getElementById('manual-blueprint-modal').classList.add('hidden');
    } catch (error) {
        console.error("Error saving manual blueprint project:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึกโปรเจค");
    }
}

function handleClearAllLinksForTopic(topicId) {
    showConfirmation(
        "คุณแน่ใจหรือไม่ว่าต้องการล้างการเชื่อมโยงแบบทดสอบทั้งหมดในคลังนี้? (ตัวแบบทดสอบจริงจะไม่ถูกลบ)",
        async () => {
            try {
                const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
                // สั่งอัปเดต field linkedQuizIds ให้เป็น Array ว่าง
                await updateDoc(projectRef, {
                    [`topics.${topicId}.linkedQuizIds`]: [] 
                });
                showMessage("ล้างการเชื่อมโยงทั้งหมดสำเร็จ");
                openTopicQuizBank(topicId); // รีเฟรชหน้าต่างคลัง
                displayBlueprintProjectManager(currentBlueprintProjectId); // รีเฟรชป้ายสถานะที่หน้าหลัก
            } catch (error) {
                console.error("Error clearing all links:", error);
                showMessage("เกิดข้อผิดพลาดในการล้างการเชื่อมโยง");
            }
        }
    );
}

function showPodiumView(players, gameMode = 'live-race', gameData = null) {
    
    const isMarketMode = gameData?.isBlackMarketEnabled === true;

    // 1. แปลงข้อมูล (เพิ่ม correctStreak เข้ามาด้วย)
    const playersArray = Object.entries(players).map(([name, data]) => ({
        name: name,
        realScore: data.realScore || data.score || 0, 
        totalPoints: data.totalPoints || 0,
        badges: data.badges || [],
        hasPerfectScoreBonus: data.hasPerfectScoreBonus || false,
        correctStreak: data.correctStreak || 0 // [เพิ่ม] ดึงค่า Streak
    }));

    // 2. คำนวณค่าสูงสุด
    const maxPoints = Math.max(...playersArray.map(p => p.totalPoints), -Infinity);
    const maxRawScore = Math.max(...playersArray.map(p => p.realScore), -Infinity);

    // 3. จัดเรียง (Sort)
    playersArray.sort((a, b) => {
        if (isMarketMode) {
            const pointsDiff = b.totalPoints - a.totalPoints;
            if (pointsDiff !== 0) return pointsDiff;
            const scoreDiff = b.realScore - a.realScore;
            if (scoreDiff !== 0) return scoreDiff;
            return a.name.localeCompare(b.name, 'th');
        } else {
            const pointsDiff = b.totalPoints - a.totalPoints;
            if (pointsDiff !== 0) return pointsDiff;
            const scoreDiff = b.realScore - a.realScore;
            if (scoreDiff !== 0) return scoreDiff;
            return a.name.localeCompare(b.name, 'th');
        }
    });

    // 4. คำนวณอันดับแบบ 1, 1, 1, 4
    let currentRank = 1;
    for (let i = 0; i < playersArray.length; i++) {
        if (i > 0) {
            const prev = playersArray[i - 1];
            const curr = playersArray[i];
            const isTied = (curr.totalPoints === prev.totalPoints) && (curr.realScore === prev.realScore);
            if (!isTied) {
                currentRank = i + 1;
            }
        }
        playersArray[i].displayRank = currentRank;
    }

    const renderBadges = (badges) => {
        if (!badges || badges.length === 0) return '';
        const badgeIcons = { quick_thinker: '⚡️', on_fire: '🔥' };
        return `<div class="flex justify-center gap-2 my-1 text-2xl">${badges.map(b => badgeIcons[b] || '').join('')}</div>`;
    };
    
    // Helper: สร้าง HTML สำหรับแสดงคะแนน + ไอคอน + ไฟ (สำหรับแท่น 1-2-3)
    const renderScoreHTML = (player) => {
        let bonusIcon = '';
        if (isMarketMode) {
            if (player.totalPoints === maxPoints && maxPoints > 0) bonusIcon += '<span title="เจ้าพ่อตลาดมืด">👑</span> ';
            if (player.realScore === maxRawScore && maxRawScore > 0) bonusIcon += '<span title="เทพวิชาการ">🎓</span> ';
        } else {
            if (player.hasPerfectScoreBonus) bonusIcon = '<span class="text-yellow-300 ml-1">+1 ✨</span>';
        }

        // [เพิ่ม] แสดงไฟ 🔥 ถ้า Streak >= 3
        let fireHtml = '';
        if (player.correctStreak >= 3) {
            fireHtml = ` <span class="text-orange-400 font-bold animate-pulse ml-1 text-lg drop-shadow-sm">🔥 x${player.correctStreak}</span>`;
        }

        if (isMarketMode) {
            const pointsDisplay = player.totalPoints >= 0 
                ? `(+${player.totalPoints.toLocaleString()})` 
                : `(${player.totalPoints.toLocaleString()})`;
            
            return `
                <div class="flex flex-col items-center">
                    <p class="text-xl">${player.realScore} คะแนน ${pointsDisplay}</p>
                    <div class="mt-1">${bonusIcon}${fireHtml}</div>
                </div>`;
        } else {
            return `
                <div class="flex flex-col items-center">
                    <p class="text-xl">${player.totalPoints.toLocaleString()} คะแนน</p>
                    <div class="mt-1">${bonusIcon}${fireHtml}</div>
                </div>`;
        }
    };

    // Helper: สร้าง HTML สำหรับไฟในรายการ "อันดับอื่นๆ"
    const renderFireForList = (streak) => {
         if (streak >= 3) return `<span class="text-orange-400 font-bold ml-2 text-sm animate-pulse">🔥 x${streak}</span>`;
         return '';
    };

    const otherPlayers = playersArray.slice(3);
    const otherPlayersHtml = otherPlayers.length > 0 ? `
        <div class="mt-8 w-full max-w-lg bg-black/20 p-4 rounded-lg text-left">
            <h3 class="text-xl font-bold mb-3 text-center">อันดับอื่นๆ</h3>
            <div class="space-y-2 text-lg">
                ${otherPlayers.map((player, index) => {
                    // เตรียมไอคอนรางวัล
                    let bonusIcon = '';
                    if (isMarketMode) {
                        if (player.totalPoints === maxPoints && maxPoints > 0) bonusIcon += '👑 ';
                        if (player.realScore === maxRawScore && maxRawScore > 0) bonusIcon += '🎓 ';
                    }

                    // เตรียมข้อความคะแนน
                    let scoreText = '';
                    if (isMarketMode) {
                        scoreText = `${player.realScore} คะแนน (${player.totalPoints.toLocaleString()})`;
                    } else {
                        scoreText = `${player.totalPoints.toLocaleString()} คะแนน`;
                    }

                    return `
                    <div class="flex justify-between items-center bg-black/10 hover:bg-black/30 p-2 rounded-md transition-colors">
                        <div class="flex items-center">
                            <span class="font-semibold text-gray-300 w-8 inline-block">${player.displayRank}.</span>
                            <i class="fas fa-user-circle mr-2 text-gray-300"></i>
                            <span>${player.name}</span>
                            ${renderFireForList(player.correctStreak)} </div>
                        <span class="font-bold text-white text-base flex items-center gap-1">
                            ${scoreText} ${bonusIcon}
                        </span>
                    </div>
                `}).join('')}
            </div>
        </div>` : '';

    const podiumHTML = `
        <div class="live-game-bg text-white rounded-lg p-8 flex flex-col h-full items-center justify-center">
            <h2 class="text-4xl font-bold mb-8">สรุปผลการแข่งขัน! <i class="fas fa-trophy text-yellow-300"></i></h2>
            <div class="flex items-end justify-center gap-4 w-full max-w-2xl">
                ${playersArray[1] ? `<div class="podium-step text-center flex-1 transform transition hover:scale-105"><i class="fas fa-user-circle text-6xl mb-2 text-gray-300"></i><p class="font-bold text-2xl truncate">${playersArray[1].name}</p>${renderScoreHTML(playersArray[1])}<div class="bg-gray-400 text-gray-900 font-bold p-4 rounded-t-lg mt-2 h-32 flex items-center justify-center text-5xl shadow-lg border-t-4 border-gray-300">${playersArray[1].displayRank}</div></div>` : '<div class="flex-1"></div>'}
                ${playersArray[0] ? `<div class="podium-step text-center flex-1 transform transition hover:scale-105 z-10"><i class="fas fa-crown text-6xl mb-2 text-yellow-400 animate-bounce"></i><p class="font-bold text-3xl truncate">${playersArray[0].name}</p>${renderScoreHTML(playersArray[0])}<div class="bg-yellow-500 text-yellow-900 font-bold p-4 rounded-t-lg mt-2 h-48 flex items-center justify-center text-6xl shadow-xl border-t-4 border-yellow-300">${playersArray[0].displayRank}</div></div>` : '<div class="flex-1"></div>'}
                ${playersArray[2] ? `<div class="podium-step text-center flex-1 transform transition hover:scale-105"><i class="fas fa-user-circle text-6xl mb-2 text-amber-700"></i><p class="font-bold text-2xl truncate">${playersArray[2].name}</p>${renderScoreHTML(playersArray[2])}<div class="bg-amber-700 text-amber-100 font-bold p-4 rounded-t-lg mt-2 h-24 flex items-center justify-center text-4xl shadow-lg border-t-4 border-amber-600">${playersArray[2].displayRank}</div></div>` : '<div class="flex-1"></div>'}
            </div>
            ${otherPlayersHtml} 
            ${currentMode === 'admin' ? `<button id="close-game-final-btn" class="mt-8 bg-red-600 text-white py-2 px-6 rounded-lg hover:bg-red-700"><i class="fas fa-times-circle mr-2"></i>จบเกมและกลับหน้าหลัก</button>` : `<button id="student-back-to-home-btn" class="mt-8 bg-red-600 text-white py-2 px-6 rounded-lg hover:bg-red-700"><i class="fas fa-times-circle mr-2"></i>จบเกมและกลับหน้าหลัก</button>`}
        </div>`;
    
    liveGameView.innerHTML = podiumHTML;

    if (currentMode === 'admin') {
        document.getElementById('close-game-final-btn').addEventListener('click', async () => {
            let gameRef;
            if (gameMode === 'sync') {
                gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
            } else {
                gameRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
            }
            await deleteDoc(gameRef);
        });
    } else {
        document.getElementById('student-back-to-home-btn')?.addEventListener('click', () => {
            showView('student'); 
        });
    }
}

function renderSyncSummaryView(gameData, question, isAdmin) {
    const variant = gameData.gameVariant || 'classic';
    const isAnonymous = ((variant === 'anonymous' || variant === 'anonymous_reveal_end') && gameData.isAnonymousRevealed === false);
    const isRevealAtEndMode = (variant === 'reveal_at_end' || variant === 'anonymous_reveal_end');

    const questions = gameData.shuffledQuiz.questions;
    const questionType = question.questionType || gameData.shuffledQuiz.quizType;
    
    // ▼▼▼ [ส่วนที่แก้ไข] เพิ่ม matching_item เข้าไปในเงื่อนไขนี้ ▼▼▼
    // เพื่อให้ระบบใช้ Logic แสดงผลแบบ ถูก/ผิด (เขียว/แดง) แทนกราฟแท่ง
    const isShortAnswerType = (questionType === 'short_answer' || questionType === 'fill_in_no_choices' || questionType === 'matching_item');
    // ▲▲▲

    // --- Logic กราฟแสดงผล ---
    let chartHTML = '';
    
    if (isShortAnswerType) {
        // === กรณีเป็นคำถามแบบพิมพ์ตอบ หรือ จับคู่ (แสดงกราฟ ถูก vs ผิด) ===
        let correctCount = 0;
        let incorrectCount = 0;
        const correctNames = [];
        const incorrectDetails = [];

        Object.entries(gameData.players || {}).forEach(([name, data]) => {
            // ค้นหาคำตอบของข้อปัจจุบัน
            const currentAnswerObj = (data.answers || []).find(a => a.questionIndex === gameData.currentQuestionIndex);
            
            if (data.status !== 'inactive' && currentAnswerObj) {
                // สำหรับ matching_item answerText จะเป็นค่าที่เลือกส่งมา
                const ans = currentAnswerObj.answerText; 
                const displayName = isAnonymous ? (gameData.playerNicknames[name] || '???') : name;

                if (currentAnswerObj.isCorrect) {
                    correctCount++;
                    correctNames.push(displayName);
                } else {
                    incorrectCount++;
                    // เก็บรายละเอียดคำตอบที่ผิดไว้แสดงใน Tooltip
                    incorrectDetails.push(`<span class="text-yellow-200 font-bold">${displayName}</span>: ${ans || '(ไม่ตอบ)'}`);
                }
            }
        });

        chartHTML = `
            <div class="w-full max-w-2xl flex justify-center items-end gap-8 my-8">
                <div class="w-1/3 flex flex-col justify-end items-center">
                    <span class="text-xl font-bold mb-1">${correctCount}</span>
                    <div class="summary-bar-item w-full rounded-lg text-white p-4 flex flex-col justify-center items-center gap-1 cursor-pointer relative shadow-lg border-2 border-green-400 transition-transform hover:scale-105" style="min-height: 120px; background-color: #22c55e;" data-tooltip-target="tooltip-hidden-correct">
                        <i class="fas fa-check-circle text-4xl mb-2"></i>
                        <span class="text-xl font-bold pointer-events-none">ตอบถูก</span>
                        <div id="tooltip-hidden-correct" class="live-summary-tooltip absolute bottom-full mb-2 w-max max-w-xs bg-gray-800 text-white text-sm rounded-lg shadow-xl p-3 z-20">
                            <strong class="block mb-2 border-b border-gray-600 pb-1 text-green-400">รายชื่อคนเก่ง:</strong>
                            <div class="max-h-40 overflow-y-auto">${correctNames.length > 0 ? correctNames.join(', ') : '-'}</div>
                        </div>
                    </div>
                </div>
                <div class="w-1/3 flex flex-col justify-end items-center">
                    <span class="text-xl font-bold mb-1">${incorrectCount}</span>
                    <div class="summary-bar-item w-full rounded-lg text-white p-4 flex flex-col justify-center items-center gap-1 cursor-pointer relative shadow-lg border-2 border-red-400 transition-transform hover:scale-105" style="min-height: 120px; background-color: #ef4444;" data-tooltip-target="tooltip-hidden-incorrect">
                        <i class="fas fa-times-circle text-4xl mb-2"></i>
                        <span class="text-xl font-bold pointer-events-none">ตอบผิด</span>
                        <div id="tooltip-hidden-incorrect" class="live-summary-tooltip absolute bottom-full mb-2 w-max max-w-xs bg-gray-800 text-white text-sm rounded-lg shadow-xl p-3 z-20 text-left">
                            <strong class="block mb-2 border-b border-gray-600 pb-1 text-red-400">รายละเอียดคนตอบผิด:</strong>
                            <div class="max-h-48 overflow-y-auto space-y-1">${incorrectDetails.length > 0 ? incorrectDetails.join('<br>') : '-'}</div>
                        </div>
                    </div>
                </div>
            </div>`;
            
    } else {
        // === กรณีเป็นคำถามแบบมีตัวเลือก (แสดงกราฟแท่งตามตัวเลือก) ===
        let options = [];
        if (questionType === 'true_false') {
            options = ['ใช่ / ถูก', 'ไม่ใช่ / ผิด'];
        } else {
            options = question.options || [];
        }
        
        const answerCounts = new Array(options.length).fill(0);
        const namesByAnswer = {};
        options.forEach((opt, index) => { namesByAnswer[index] = []; });

        Object.entries(gameData.players || {}).forEach(([name, data]) => {
            const currentAnswerObj = (data.answers || []).find(a => a.questionIndex === gameData.currentQuestionIndex);
            if (data.status !== 'inactive' && currentAnswerObj && currentAnswerObj.answer !== null) {
                const answerIndex = parseInt(currentAnswerObj.answer);
                if (!isNaN(answerIndex) && namesByAnswer[answerIndex] !== undefined) {
                    const displayName = isAnonymous ? (gameData.playerNicknames[name] || '???') : name;
                    namesByAnswer[answerIndex].push(displayName);
                    answerCounts[answerIndex]++;
                }
            }
        });

        chartHTML = `
            <div class="w-full max-w-2xl flex justify-around items-end gap-4 my-8">
                ${answerCounts.map((count, index) => {
                    const tooltipText = namesByAnswer[index].length > 0 ? namesByAnswer[index].join(', ') : 'ไม่มีผู้ตอบตัวเลือกนี้';
                    const barColor = '#6366F1';
                    return `
                    <div class="w-1/4 flex flex-col justify-end items-center">
                        <span class="text-xl font-bold mb-1">${count}</span>
                        <div class="summary-bar-item w-full rounded-lg text-white p-2 flex flex-col justify-center items-center gap-1 cursor-pointer relative" style="min-height: 60px; background-color: ${barColor};" data-tooltip-target="tooltip-${index}">
                            <span class="text-sm sm:text-sm font-semibold text-center pointer-events-none">${options[index]}</span>
                            <div id="tooltip-${index}" class="live-summary-tooltip absolute bottom-full mb-2 w-max max-w-xs bg-gray-800 text-white text-sm rounded-lg shadow-lg p-3 z-10">
                                <strong class="block mb-1 border-b border-gray-600 pb-1">ผู้ที่ตอบตัวเลือกนี้:</strong>${tooltipText}
                            </div>
                        </div>
                    </div>`;
                }).join('')}
            </div>`;
    }

    // --- ส่วนปุ่มควบคุม Admin ---
    let actionButtonsHTML = '';
    const isLastQuestion = gameData.currentQuestionIndex >= questions.length - 1;

    if (isAdmin) {
        if (isRevealAtEndMode) {
            if (isLastQuestion) {
                actionButtonsHTML = `<button id="show-final-results-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-8 rounded-lg text-2xl"><i class="fas fa-chart-bar"></i> เข้าสู่ช่วงเฉลยคำตอบ (Review)</button>`;
            } else {
                actionButtonsHTML = `<button id="next-sync-question-btn" class="bg-gray-800 hover:bg-black text-white font-bold py-3 px-8 rounded-lg text-2xl">ข้อต่อไป <i class="fas fa-arrow-right"></i></button>`;
            }
        } else {
            actionButtonsHTML = `
                <button id="open-sync-scratchpad-btn" class="bg-white/30 hover:bg-white/50 text-white font-bold py-3 px-8 rounded-lg text-xl flex items-center gap-2"><i class="fas fa-pencil-alt"></i> ทดเลข</button>
                <button id="show-results-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-8 rounded-lg text-2xl"><i class="fas fa-chart-bar"></i> แสดงผลลัพธ์</button>
            `;
        }
    } else {
        if (isRevealAtEndMode) {
             actionButtonsHTML = `<p class="mt-8 text-lg text-indigo-200">รอผู้ควบคุมไปข้อต่อไป...</p>`;
        } else {
             actionButtonsHTML = `<p class="mt-8 text-lg text-indigo-200">รอผู้ควบคุมแสดงผลลัพธ์...</p>`;
        }
    }

    const pinDisplayHTML = isAdmin ? `<div class="absolute top-4 left-4 bg-black/30 px-3 py-1 rounded-full text-sm">PIN: <strong class="font-bold">${gameData.pin}</strong></div>` : '';

    const summaryHTML = `
        <div class="bg-indigo-700 text-white rounded-lg p-8 flex flex-col h-full items-center justify-between relative">
        ${pinDisplayHTML} 
            <h2 class="text-3xl font-bold text-center">${question.questionText || question.stem || ''}</h2>
            
            ${chartHTML}

            <div class="flex items-center justify-center gap-4 mt-4">${actionButtonsHTML}</div>
        </div>
    `;
    
    liveGameView.innerHTML = summaryHTML;
    if (window.MathJax) MathJax.typesetPromise();

    if (isAdmin) {
        const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
        
        // Event Listeners
        document.getElementById('show-results-btn')?.addEventListener('click', async () => {
            const leaderboardData = Object.values(gameData.players || {}).map(p => ({
                name: p.name,
                score: p.score || 0,
                totalPoints: p.totalPoints || 0,
                pointsLastRound: p.pointsLastRound || 0,
                answers: p.answers || [],
                correctStreak: p.correctStreak || 0 
            }));
            await updateDoc(gameRef, { status: 'results', publicLeaderboard: leaderboardData });
        });
        
        document.getElementById('open-sync-scratchpad-btn')?.addEventListener('click', () => {
            // เพิ่ม options สำหรับ matching (allResponses) ให้ scratchpad ใช้งานได้
            openScratchpad(question, question.options || question.allResponses || []);
        });

        document.getElementById('next-sync-question-btn')?.addEventListener('click', async () => {
            const nextIndex = gameData.currentQuestionIndex + 1;
            await updateDoc(gameRef, { 
                status: 'question', 
                currentQuestionIndex: nextIndex, 
                questionDisplayedAt: serverTimestamp(),
                scoresCalculated: false 
            });
        });

        document.getElementById('show-final-results-btn')?.addEventListener('click', async () => {
             const leaderboardData = Object.values(gameData.players || {}).map(p => ({
                name: p.name,
                score: p.score || 0,
                totalPoints: p.totalPoints || 0,
                pointsLastRound: p.pointsLastRound || 0,
                answers: p.answers || [],
                correctStreak: p.correctStreak || 0 
            }));
            
            await updateDoc(gameRef, { 
                status: 'results', 
                reviewQuestionIndex: 0, 
                publicLeaderboard: leaderboardData
            });
        });
    }
}

function renderAnonymousStudentResultsView(gameData) {
    const isLastQuestion = gameData.currentQuestionIndex >= gameData.shuffledQuiz.questions.length - 1;
    let message = '';
    
    // 1. ตรวจสอบสถานะการเปิดเผยชื่อ
    if (gameData.isAnonymousRevealed === true) {
        // (กรณี Admin กดเปิดเผยชื่อแล้ว - ซึ่งจะเกิดเฉพาะข้อสุดท้าย)
        const myPlayerData = gameData.players[localTeamPlayers[0]];
        const myRealName = myPlayerData.name;
        const myScore = myPlayerData.score;
        
        message = `
            <p class="text-2xl font-bold text-white mt-4">${myRealName} (นั่นคือคุณ!)</p>
            <p class="text-4xl font-bold text-yellow-300 mt-2">${myScore} คะแนน</p>
            <p class="mt-8 text-xl font-bold text-yellow-300 animate-pulse">เตรียมพบกับผลสรุปสุดท้าย!</p>
        `;
    } else {
        // (กรณียังไม่เปิดเผยชื่อ - นี่คือหน้าจอหลักที่นักเรียนจะเห็น)
        message = `
            <div class="loader"></div>
            <h2 class="text-3xl font-bold mt-4">ส่งคำตอบแล้ว!</h2>
            <p class="mt-4 text-xl text-indigo-200">
                ${isLastQuestion ? 'รอผู้ควบคุมแสดงผลสรุปสุดท้าย...' : 'รอผู้ควบคุมไปข้อต่อไป...'}
            </p>
        `;
    }

    // 2. สร้าง HTML ที่เรียบง่าย
    const resultsHTML = `
        <div class="bg-indigo-700 text-white rounded-lg p-8 flex flex-col h-full items-center justify-center text-center">
            ${message}
        </div>
    `;
    liveGameView.innerHTML = resultsHTML;
}

        async function handleShowStudentRankings() {
    // Insert table headers for student leaderboard views
    const quizTableHead = document.querySelector('#student-quiz-leaderboard-content thead');
    if (quizTableHead) {
      quizTableHead.innerHTML = `
        <tr>
          <th class="py-2 px-3 text-center w-16">อันดับ</th>
          <th class="py-2 px-3 text-left">ชื่อผู้ทำ</th>
          <th class="py-2 px-3 text-center">คะแนน</th>
          <th class="py-2 px-3 text-center">สถานะ (ผ่าน/ไม่ผ่าน)</th>
          <th class="py-2 px-3 text-center">คะแนน Points</th>
          <th class="py-2 px-3 text-left">ไอคอนรางวัล</th>
        </tr>
      `;
    }
    const projectTableHead = document.querySelector('#student-project-leaderboard-content thead');
    if (projectTableHead) {
      projectTableHead.innerHTML = `
        <tr>
          <th class="py-2 px-3 text-center w-16">อันดับ</th>
          <th class="py-2 px-3 text-left">ชื่อผู้เล่น</th>
          <th class="py-2 px-3 text-center">คะแนนรวม (Points)</th>
          <th class="py-2 px-3 text-left">ไอคอนรางวัลที่ได้รับ</th>
        </tr>
      `;
    }
    
            const modal = document.getElementById('student-rankings-modal');
            modal.classList.remove('hidden');

            // Setup close button
            document.getElementById('close-student-rankings-btn').onclick = () => modal.classList.add('hidden');

            // Setup tabs
            const quizTab = document.getElementById('student-quiz-leaderboard-tab');
            const projectTab = document.getElementById('student-project-leaderboard-tab');
            const quizContent = document.getElementById('student-quiz-leaderboard-content');
            const projectContent = document.getElementById('student-project-leaderboard-content');

            quizTab.onclick = () => {
                quizTab.classList.add('active');
                projectTab.classList.remove('active');
                quizContent.classList.remove('hidden');
                projectContent.classList.add('hidden');
            };
            projectTab.onclick = () => {
                projectTab.classList.add('active');
                quizTab.classList.remove('active');
                projectContent.classList.remove('hidden');
                quizContent.classList.add('hidden');
            };

            // Fetch and render data
            try {
                // 1. Fetch data for THIS quiz leaderboard
                const submissionsRef = collection(db, `artifacts/${appId}/public/data/quizzes/${currentQuizData.id}/submissions`);
                const submissionsSnapshot = await getDocs(submissionsRef);
                const submissions = submissionsSnapshot.docs.map(doc => doc.data());
                renderQuizLeaderboard(submissions, currentQuizData, 'student-quiz-leaderboard-table-body');

                // 2. Fetch data for the OVERALL project leaderboard
                const profilesRef = collection(db, `artifacts/${appId}/public/data/projects/${currentQuizData.projectId}/studentProfiles`);
                const profilesSnapshot = await getDocs(profilesRef);
                const profiles = profilesSnapshot.docs.map(doc => doc.data());
                renderLeaderboard(profiles, 'student-project-leaderboard-table-body');

            } catch (error) {
                console.error("Error fetching student rankings:", error);
                showMessage("ไม่สามารถโหลดข้อมูลอันดับได้");
            }
        }

        async function handleSaveToBank(e) {
    const btn = e.currentTarget;
    const index = btn.dataset.index;
    const questionData = currentQuizData.questions[index];

    if (!userId) {
        showMessage("ไม่พบข้อมูลผู้ใช้");
        return;
    }

    try {
        // เพิ่มข้อมูลหัวข้อเดิมเข้าไปด้วย เพื่อให้ง่ายต่อการค้นหาในอนาคต
        const dataToSave = {
            ...questionData,
            originalTopic: currentQuizData.topic, 
            savedAt: serverTimestamp()
        };

        const bankCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/questionBank`);
        await addDoc(bankCollectionRef, dataToSave);

        // แสดงผลตอบรับให้ครูทราบ
        showMessage("บันทึกคำถามลงคลังข้อสอบส่วนตัวแล้ว");
        btn.classList.remove('text-purple-600');
        btn.classList.add('text-green-600'); // เปลี่ยนเป็นสีเขียว
        btn.disabled = true; // ปิดปุ่มหลังบันทึกแล้ว
    } catch (error) {
        console.error("Error saving to question bank:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึก");
    }
}

// ▼▼▼ วางทับฟังก์ชัน selectProjectAndGenerateBlueprintQuiz เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
async function selectProjectAndGenerateBlueprintQuiz(topicName, lessonText = null, blueprintTopicId = null, forceAppStyle = false) {
    cameFromBlueprint = true;

    // --- [START] ส่วนที่เพิ่มเข้ามา ---
    // 1. อ่าน URL จาก input field ในหน้า Blueprint Manager
    const referenceFileUrl = document.getElementById('bp-reference-file-url')?.value.trim();
    let extraParts = null; // เริ่มต้นเป็น null

    // 2. ถ้ามี URL ให้ดึงไฟล์และเตรียมข้อมูลสำหรับส่งให้ AI
    if (referenceFileUrl) {
        showMessage("กำลังดึงไฟล์ O-NET อ้างอิงจากลิงก์...");
        try {
            const referenceFile = await fetchFileFromUrl(referenceFileUrl, "reference_onet.pdf");
            const refBase64 = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(referenceFile);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
            });
            
            // เตรียมข้อมูลไฟล์ในรูปแบบที่ API ต้องการ
            extraParts = [{ inlineData: { mimeType: referenceFile.type, data: refBase64 } }];
            messageModal.classList.add('hidden'); // ซ่อน popup เมื่อโหลดเสร็จ
        } catch (fileError) {
            console.error("Could not fetch reference file:", fileError);
            showMessage("ไม่สามารถดึงไฟล์อ้างอิงได้ ระบบจะสร้างแบบทดสอบตามปกติ");
        }
    }
    // --- [END] สิ้นสุดส่วนที่เพิ่ม ---

    const modal = document.getElementById('move-quiz-modal');
    const projectSelect = document.getElementById('move-quiz-project-select');
    const modalTitle = modal.querySelector('h3');
    const confirmBtn = document.getElementById('confirm-move-quiz-btn');
    const cancelBtn = document.getElementById('cancel-move-quiz-btn');

    modalTitle.textContent = 'เลือกโปรเจคที่จะบันทึกแบบทดสอบ';
    confirmBtn.textContent = 'เลือกและเริ่มสร้าง';
    confirmBtn.disabled = true;

    if (allProjects.length === 0) {
        projectSelect.innerHTML = '<option value="">ยังไม่มีโปรเจคให้เลือก</option>';
    } else {
        projectSelect.innerHTML = '<option value="">-- เลือกโปรเจค --</option>' +
            allProjects.map(p => `<option value="${p.id}">${p.projectName}</option>`).join('');
        confirmBtn.disabled = false;
    }

    modal.classList.remove('hidden');

    const confirmHandler = async () => {
        const selectedProjectId = projectSelect.value;
        if (!selectedProjectId) {
            showMessage("กรุณาเลือกโปรเจคก่อน");
            return;
        }
        modal.classList.add('hidden');
        
        document.getElementById('blueprint-project-manager-view').classList.add('hidden');
        await loadProjectDetails(selectedProjectId);
        showView('project-detail');
        
        // 3. ส่ง extraParts ที่มีข้อมูลไฟล์ต่อไปยังฟังก์ชันถัดไป
        handleGenerateQuizFromBlueprintTopic(topicName, lessonText, selectedProjectId, blueprintTopicId, forceAppStyle, extraParts);
        
        cleanup();
    };
    
    const cleanup = () => {
        modalTitle.textContent = 'ย้ายแบบทดสอบไปโปรเจคอื่น';
        confirmBtn.textContent = 'ย้าย';
        confirmBtn.removeEventListener('click', confirmHandler);
        cancelBtn.removeEventListener('click', cleanup);
        confirmBtn.addEventListener('click', confirmMoveQuiz);
    };
    
    confirmBtn.removeEventListener('click', confirmMoveQuiz);
    confirmBtn.addEventListener('click', confirmHandler);
    cancelBtn.addEventListener('click', cleanup);
}

function listenForStarredQuizzes() {
    if (!userId) return;
    const quizzesRef = collection(db, `artifacts/${appId}/public/data/quizzes`);
    const q = query(quizzesRef, where("isStarred", "==", true));

    onSnapshot(q, (snapshot) => {
        // เก็บข้อมูลแบบทดสอบที่ติดดาวลงในตัวแปร global
        starredQuizzes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        // --- [ ส่วนที่แก้ไข ] ---
        // ตรวจสอบว่าตอนนี้ผู้ใช้อยู่ในหน้ารายการโปรดหรือไม่
        if (currentProjectId === 'starred') {
            // ถ้าใช่ ให้รีเฟรชหน้ารายการโปรด (renderQuizzes)
            renderQuizzes();
        } else {
            // ถ้าไม่ได้อยู่ในหน้ารายการโปรด (อยู่ที่ Dashboard) ให้รีเฟรชหน้า Dashboard (renderProjects)
            renderProjects();
        }

    }, (error) => {
        console.error("Error listening for starred quizzes:", error);
    });
}			
		
// ▼▼▼ START: วางโค้ดชุดฟังก์ชันใหม่นี้ทั้งหมดเข้าไปใน <script> ▼▼▼

/**
 * [File Shortcuts] เริ่มฟังข้อมูลปุ่มลัดจากไฟล์จาก Firestore
 */
function listenForFileShortcuts() {
    const shortcutsRef = doc(db, "globalSettings", "fileShortcutsConfig");

    onSnapshot(shortcutsRef, (docSnap) => {
        let shortcuts = [];
        let tabs = [];
        let order = {};

        if (docSnap.exists()) {
            const data = docSnap.data();
            shortcuts = data.shortcuts || [];
            tabs = data.fileShortcutTabs || []; // <-- [แก้ไข] ดึงข้อมูลแท็บ
            order = data.fileShortcutOrder || {};   // <-- [แก้ไข] ดึงข้อมูลการจัดเรียง
        }

        if (!tabs.find(t => t.id === 'all')) {
            tabs.unshift({ id: 'all', name: 'ไฟล์ทั้งหมด', isDefault: true });
        }

        if (!shortcuts.find(s => s.id === 'file-default-1')) {
            shortcuts.unshift({ id: 'file-default-1', name: 'ไฟล์ลัด 1', url: '', isDefault: true });
        }
        if (!shortcuts.find(s => s.id === 'file-default-2')) {
            shortcuts.unshift({ id: 'file-default-2', name: 'ไฟล์ลัด 2', url: '', isDefault: true });
        }

        fileShortcuts = shortcuts;
        fileShortcutTabs = tabs; // <-- [แก้ไข] อัปเดตตัวแปร Global
        fileShortcutOrder = order; // <-- [แก้ไข] อัปเดตตัวแปร Global

        renderFileShortcuts();

        if (!document.getElementById('additional-file-shortcuts-modal').classList.contains('hidden')) {
            renderAdditionalFileShortcutsModal(); // <-- [แก้ไข] เรียกฟังก์ชันวาด Modal ใหม่
        }
    });
}

// ▼▼▼ [ใหม่] เพิ่มชุดฟังก์ชันสำหรับจัดการ File Shortcut Tabs ทั้งหมด ▼▼▼

async function saveFileShortcutConfig() {
    const configRef = doc(db, "globalSettings", "fileShortcutsConfig");
    try {
        await setDoc(configRef, { 
            fileShortcutTabs: fileShortcutTabs,
            fileShortcutOrder: fileShortcutOrder
        }, { merge: true });
    } catch (error) { console.error("Error saving file shortcut config:", error); }
}

function renderAdditionalFileShortcutsModal() {
    const navContainer = document.getElementById('file-shortcut-tabs-nav');
    const listContainer = document.getElementById('additional-file-shortcuts-list');
    if (!navContainer || !listContainer) return;

    navContainer.innerHTML = fileShortcutTabs.map(tab => {
        const isActive = tab.id === activeFileShortcutTabId;
        return `<div class="relative group flex items-center">
                    <button data-tab-id="${tab.id}" class="file-shortcut-tab-btn whitespace-nowrap py-3 px-2 border-b-2 font-medium text-sm ${isActive ? 'border-indigo-500 text-indigo-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}">
                        <span class="tab-name-display pointer-events-none">${tab.name}</span>
                        <input type="text" value="${tab.name}" class="tab-name-input hidden bg-transparent border-b-2 border-indigo-500 text-sm w-32">
                    </button>
                    ${!tab.isDefault ? `<button data-tab-id="${tab.id}" class="delete-file-shortcut-tab-btn absolute -top-1 -right-1 text-red-400 hover:text-red-700 opacity-0 group-hover:opacity-100">&times;</button>` : ''}
                </div>`;
    }).join('');

    const activeTab = fileShortcutTabs.find(t => t.id === activeFileShortcutTabId);
    let shortcutsToShow = activeTab?.isDefault ? [...fileShortcuts] : fileShortcuts.filter(s => (activeTab?.shortcutIds || []).includes(s.id));
    
    const currentOrder = fileShortcutOrder[activeFileShortcutTabId] || [];
    shortcutsToShow.sort((a, b) => {
        const indexA = currentOrder.indexOf(a.id);
        const indexB = currentOrder.indexOf(b.id);
        return (indexA === -1 ? Infinity : indexA) - (indexB === -1 ? Infinity : indexB);
    });

    listContainer.innerHTML = shortcutsToShow.map(shortcut => {
        const icon = shortcut.url ? '📄' : '🔗';
        const otherTabs = fileShortcutTabs.filter(t => !t.isDefault);
        const moveDropdownHTML = activeTab.isDefault && otherTabs.length > 0 ? `
            <div class="relative inline-block text-left group/dropdown-file">
                <button class="move-file-shortcut-menu-btn text-gray-500 hover:text-blue-700 p-1 rounded-full text-sm"><i class="fas fa-ellipsis-v"></i></button>
                <div class="move-file-shortcut-dropdown origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden z-20">
                    <div class="py-1">
                        <p class="px-4 pt-1 pb-2 text-xs text-gray-400">เพิ่มไปยังแท็บ:</p>
                        ${otherTabs.map(tab => `<a href="#" class="move-file-shortcut-item block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" data-shortcut-id="${shortcut.id}" data-target-tab-id="${tab.id}">${tab.name}</a>`).join('')}
                    </div>
                </div>
            </div>` : '';

        return `<div class="shortcut-list-item p-3 border-b hover:bg-gray-50 flex items-center justify-between" data-shortcut-id="${shortcut.id}" draggable="true">
                    <div><p class="font-semibold text-blue-700">${icon} ${shortcut.name}</p></div>
                    <div class="flex items-center gap-2 shrink-0">
                        <button data-id="${shortcut.id}" class="use-hidden-file-shortcut-btn bg-blue-100 text-blue-700 text-sm py-1 px-3 rounded-md hover:bg-blue-200">เลือกใช้</button>
                        <button data-id="${shortcut.id}" class="edit-hidden-file-shortcut-btn bg-yellow-100 text-yellow-700 text-sm py-1 px-3 rounded-md hover:bg-yellow-200">แก้ไข</button>
                        ${!shortcut.isDefault ? `<button data-id="${shortcut.id}" class="delete-hidden-file-shortcut-btn bg-red-100 text-red-700 text-sm py-1 px-3 rounded-md hover:bg-red-200">ลบ</button>` : ''}
                        ${!activeTab.isDefault ? `<button data-shortcut-id="${shortcut.id}" class="remove-file-shortcut-from-tab-btn text-red-500 ml-2" title="นำออกจากแท็บนี้"><i class="fas fa-times-circle"></i></button>` : ''}
                        ${moveDropdownHTML}
                    </div>
                </div>`;
    }).join('') || '<p class="p-4 text-center text-gray-500">ไม่มีปุ่มลัดในแท็บนี้</p>';
    
    setupFileShortcutModalEventListeners();
}

function setupFileShortcutModalEventListeners() {
    document.querySelectorAll('.file-shortcut-tab-btn').forEach(btn => {
        btn.onclick = e => { activeFileShortcutTabId = e.currentTarget.dataset.tabId; renderAdditionalFileShortcutsModal(); };
        btn.ondblclick = e => {
            const input = e.currentTarget.querySelector('.tab-name-input');
            e.currentTarget.querySelector('.tab-name-display').classList.add('hidden');
            input.classList.remove('hidden'); input.focus(); input.select();
        };
    });
    document.querySelectorAll('#file-shortcut-tabs-nav .tab-name-input').forEach(input => {
        const save = () => {
            const tabId = input.closest('.file-shortcut-tab-btn').dataset.tabId;
            const tab = fileShortcutTabs.find(t => t.id === tabId);
            if(tab) { tab.name = input.value.trim() || tab.name; saveFileShortcutConfig(); }
        };
        input.onblur = save;
        input.onkeydown = e => { if (e.key === 'Enter') input.blur(); };
    });
    document.querySelectorAll('.delete-file-shortcut-tab-btn').forEach(btn => btn.onclick = e => {
        const tabId = e.currentTarget.dataset.tabId;
        showConfirmation("คุณแน่ใจว่าต้องการลบแท็บนี้?", () => {
            fileShortcutTabs = fileShortcutTabs.filter(t => t.id !== tabId);
            delete fileShortcutOrder[tabId];
            if (activeFileShortcutTabId === tabId) activeFileShortcutTabId = 'all';
            saveFileShortcutConfig();
        });
    });
    document.querySelectorAll('.move-file-shortcut-item').forEach(item => item.onclick = e => {
        e.preventDefault();
        const { shortcutId, targetTabId } = e.currentTarget.dataset;
        const tab = fileShortcutTabs.find(t => t.id === targetTabId);
        if(tab && !tab.shortcutIds.includes(shortcutId)) { tab.shortcutIds.push(shortcutId); saveFileShortcutConfig(); }
    });
    document.querySelectorAll('.remove-file-shortcut-from-tab-btn').forEach(btn => btn.onclick = e => {
        const shortcutId = e.currentTarget.dataset.shortcutId;
        const tab = fileShortcutTabs.find(t => t.id === activeFileShortcutTabId);
        if(tab && !tab.isDefault) { tab.shortcutIds = tab.shortcutIds.filter(id => id !== shortcutId); saveFileShortcutConfig(); }
    });
    document.querySelectorAll('.move-file-shortcut-menu-btn').forEach(btn => btn.onclick = e => {
        e.stopPropagation();
        const dropdown = e.currentTarget.nextElementSibling;
        document.querySelectorAll('.move-file-shortcut-dropdown').forEach(d => d.classList.add('hidden'));
        dropdown.classList.remove('hidden');
    });
    const listContainer = document.getElementById('additional-file-shortcuts-list');
    let draggedItem = null;
    listContainer.ondragstart = e => {
        draggedItem = e.target.closest('.shortcut-list-item');
        if(draggedItem) setTimeout(() => draggedItem.classList.add('opacity-50'), 0);
    };
    listContainer.ondragend = () => { if(draggedItem) { draggedItem.classList.remove('opacity-50'); draggedItem = null; }};
    listContainer.ondragover = e => { e.preventDefault(); };
    listContainer.ondrop = e => {
        e.preventDefault();
        if (draggedItem) {
            const afterElement = [...listContainer.querySelectorAll('.shortcut-list-item:not(.opacity-50)')].reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = e.clientY - box.top - box.height / 2;
                return (offset < 0 && offset > closest.offset) ? { offset: offset, element: child } : closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
            if (afterElement == null) { listContainer.appendChild(draggedItem); } 
            else { listContainer.insertBefore(draggedItem, afterElement); }
            const newOrder = [...listContainer.querySelectorAll('.shortcut-list-item')].map(item => item.dataset.shortcutId);
            fileShortcutOrder[activeFileShortcutTabId] = newOrder;
            saveFileShortcutConfig();
        }
    };
}

async function handleAddFileShortcutTab() {
    const name = prompt("กรุณาตั้งชื่อแท็บใหม่:", "แท็บใหม่");
    if (name && name.trim()) {
        fileShortcutTabs.push({ id: `tab_${Date.now()}`, name: name.trim(), shortcutIds: [] });
        await saveFileShortcutConfig();
    }
}
// ▲▲▲ สิ้นสุดชุดฟังก์ชันใหม่ ▲▲▲

function renderFileShortcuts() {
    const container = document.getElementById('file-shortcut-container');
    const additionalList = document.getElementById('additional-file-shortcuts-list');
    const loadingMsg = document.getElementById('file-shortcuts-loading-msg');

    if (loadingMsg) loadingMsg.classList.add('hidden');
    if (!container || !additionalList) return;

    const visibleShortcuts = fileShortcuts.slice(0, 4);
    const hiddenShortcuts = fileShortcuts.slice(4);

    container.innerHTML = visibleShortcuts.map(shortcut => {
        const hasUrl = shortcut.url && shortcut.url.trim() !== '';
        // ตรวจสอบว่าปุ่มนี้คือปุ่มที่ "ถูกเลือก" อยู่หรือไม่
        const isActive = selectedFile && selectedFile.shortcutId === shortcut.id;

        let bgColorClass = 'bg-gray-200 hover:bg-gray-300 text-gray-700';
        let icon = '🔗';

        if (isActive) {
            // สถานะ: พร้อมใช้งาน (สีเขียว, มีเครื่องหมายติ๊กถูก)
            bgColorClass = 'bg-green-600 text-white ring-4 ring-green-300';
            icon = '<i class="fas fa-check-circle"></i>';
        } else if (hasUrl) {
            // สถานะ: มีลิงก์ แต่ยังไม่ถูกเลือก (สีฟ้า)
            bgColorClass = 'bg-blue-500 hover:bg-blue-600 text-white';
            icon = '📄';
        }

        const deleteBtnHtml = !shortcut.isDefault ? 
            `<button data-id="${shortcut.id}" class="delete-file-shortcut-btn absolute top-1 right-1 w-6 h-6 bg-red-500 text-white rounded-full text-xs opacity-0 group-hover:opacity-100 transition-opacity" title="ลบ">&times;</button>` : '';

        return `
            <div class="relative group">
                <div data-id="${shortcut.id}" class="file-shortcut-btn rounded-2xl shadow-lg p-6 h-24 flex items-center justify-center text-center font-semibold cursor-pointer transition hover:scale-105 ${bgColorClass}">
                    <div class="pointer-events-none flex flex-col items-center justify-center gap-1">
                        <span class="text-2xl">${icon}</span>
                        <span class="text-sm">${shortcut.name}</span>
                    </div>
                </div>
                <button data-id="${shortcut.id}" class="edit-file-shortcut-btn absolute bottom-1 right-1 w-6 h-6 bg-white/50 text-gray-800 rounded-full text-xs opacity-0 group-hover:opacity-100 transition-opacity" title="แก้ไข"><i class="fas fa-pen"></i></button>
                ${deleteBtnHtml}
            </div>
        `;
    }).join('');

    if (hiddenShortcuts.length > 0) {
        container.innerHTML += `
            <div id="open-additional-file-shortcuts-btn" class="rounded-2xl shadow-lg p-4 flex flex-col items-center justify-center text-center font-semibold cursor-pointer transition hover:scale-105 h-24 bg-gray-100 hover:bg-gray-200 text-gray-600">
                <i class="fas fa-ellipsis-h text-xl"></i>
                <span class="mt-2 text-sm">ปุ่มลัดเพิ่มเติม</span>
            </div>
        `;
    }

    if (hiddenShortcuts.length > 0) {
        additionalList.innerHTML = hiddenShortcuts.map(shortcut => `
            <div class="p-3 border-b hover:bg-gray-100 flex items-center justify-between">
                <p class="font-semibold text-blue-700">${shortcut.url ? '📄' : '🔗'} ${shortcut.name}</p>
                <div class="flex items-center gap-2 shrink-0">
                    <button data-id="${shortcut.id}" class="use-hidden-file-shortcut-btn bg-blue-100 text-blue-700 text-sm py-1 px-3 rounded-md hover:bg-blue-200">เลือกใช้</button>
                    <button data-id="${shortcut.id}" class="edit-hidden-file-shortcut-btn bg-yellow-100 text-yellow-700 text-sm py-1 px-3 rounded-md hover:bg-yellow-200">แก้ไข</button>
                    ${!shortcut.isDefault ? `<button data-id="${shortcut.id}" class="delete-hidden-file-shortcut-btn bg-red-100 text-red-700 text-sm py-1 px-3 rounded-md hover:bg-red-200">ลบ</button>` : ''}
                </div>
            </div>
        `).join('');
    } else {
        additionalList.innerHTML = '<p class="p-4 text-center text-gray-500">ไม่มีปุ่มลัดเพิ่มเติม</p>';
    }
}

/**
 * [File Shortcuts] เปิด Modal สำหรับแก้ไขหรือเพิ่มปุ่มลัดใหม่
 */
function openFileShortcutEditor(shortcutId = null) {
    const modal = document.getElementById('file-shortcut-editor-modal');
    const title = document.getElementById('file-shortcut-modal-title');
    const idInput = document.getElementById('file-shortcut-id-input');
    const nameInput = document.getElementById('file-shortcut-name-input');
    const urlInput = document.getElementById('file-shortcut-url-input');

    if (shortcutId) {
        const shortcut = fileShortcuts.find(s => s.id === shortcutId);
        if (!shortcut) return;
        title.textContent = 'แก้ไขปุ่มลัดจากไฟล์';
        idInput.value = shortcut.id;
        nameInput.value = shortcut.name;
        urlInput.value = shortcut.url || '';
    } else {
        title.textContent = 'เพิ่มปุ่มลัดจากไฟล์ใหม่';
        idInput.value = ''; nameInput.value = ''; urlInput.value = '';
    }
    modal.classList.remove('hidden');
}

/**
 * [File Shortcuts] บันทึกการเปลี่ยนแปลงจาก Modal ลง Firebase
 */
async function saveFileShortcutChanges() {
    const id = document.getElementById('file-shortcut-id-input').value;
    const name = document.getElementById('file-shortcut-name-input').value.trim();
    const url = document.getElementById('file-shortcut-url-input').value.trim();

    if (!name) { showMessage("กรุณากรอก 'ชื่อปุ่มลัด'"); return; }

    const newShortcutData = {
        id: id || `file-shortcut_${Date.now()}`,
        name: name, url: url, isDefault: id.startsWith('file-default-')
    };

    let updatedShortcuts;
    if (id) {
        updatedShortcuts = fileShortcuts.map(s => s.id === id ? newShortcutData : s);
    } else {
        updatedShortcuts = [...fileShortcuts, newShortcutData];
    }

    try {
        const prefRef = doc(db, "globalSettings", "fileShortcutsConfig");
        await setDoc(prefRef, { shortcuts: updatedShortcuts }, { merge: true });
        document.getElementById('file-shortcut-editor-modal').classList.add('hidden');
    } catch (error) {
        console.error("Error saving file shortcut:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึก");
    }
}

/**
 * [File Shortcuts] ฟังก์ชันหลักเมื่อคลิกที่ปุ่มลัด
 */
async function handleFileShortcutClick(shortcutId) {
    const shortcut = fileShortcuts.find(s => s.id === shortcutId);
    if (!shortcut) return;

    // ถ้าปุ่มยังไม่มีลิงก์ ให้เปิดหน้าต่างแก้ไขแทน
    if (!shortcut.url || shortcut.url.trim() === '') {
        openFileShortcutEditor(shortcutId);
        return;
    }

    // แสดงสถานะกำลังโหลดบนปุ่มที่ถูกคลิก
    const btnElement = document.querySelector(`.file-shortcut-btn[data-id="${shortcutId}"]`);
    if (btnElement) {
        const originalContent = btnElement.innerHTML;
        btnElement.innerHTML = `<span class="pointer-events-none"><i class="fas fa-spinner fa-spin"></i></span>`;
        btnElement.disabled = true;
    }
    
    // ปิดการใช้งานปุ่มอื่นชั่วคราว
    document.querySelectorAll('.file-shortcut-btn').forEach(btn => {
        if(btn.dataset.id !== shortcutId) btn.classList.add('opacity-50', 'pointer-events-none');
    });

    try {
        const urlPath = new URL(shortcut.url).pathname;
        const filename = urlPath.substring(urlPath.lastIndexOf('/') + 1) || (shortcut.url.includes('.txt') ? 'file.txt' : 'file.pdf');
        
        // เรียกใช้ฟังก์ชัน fetchFileFromUrl ที่มีอยู่แล้ว
        const fileObject = await fetchFileFromUrl(shortcut.url, filename);
        
        // เพิ่ม ID ของปุ่มลัดเข้าไปใน File object เพื่อใช้ตรวจสอบสถานะ "Active"
        fileObject.shortcutId = shortcutId; 

        // **จุดเชื่อมต่อที่สำคัญ:** นำ File object ไปใส่ในตัวแปร `selectedFile`
        // เสมือนว่าผู้ใช้เพิ่งอัปโหลดไฟล์นี้ด้วยตนเอง
        selectedFile = fileObject;
        
        // อัปเดต UI ของปุ่มลัดทั้งหมดเพื่อแสดงสถานะ "พร้อมใช้งาน" (สีเขียว)
        renderFileShortcuts(); 
        
        // **เรียกใช้ฟังก์ชันกลาง** เพื่อเปิดใช้งานฟีเจอร์เสริมและปุ่ม "สร้างแบบทดสอบ"
        activateFileInputAreaWithLoadedFile();
        
        // เลื่อนหน้าจอไปยังส่วน "จากไฟล์" เพื่อให้ผู้ใช้เห็นว่าพร้อมแล้ว
        document.getElementById('file-input-area').scrollIntoView({ behavior: 'smooth', block: 'center' });

    } catch (error) {
        console.error("Error processing file shortcut click:", error);
        showMessage(`เกิดข้อผิดพลาดในการโหลดไฟล์จากลิงก์: ${error.message}`);
        renderFileShortcuts(); // คืนค่า UI ของปุ่มเป็นปกติหากเกิดข้อผิดพลาด
    } finally {
        // เปิดการใช้งานปุ่มอื่นกลับมา
        document.querySelectorAll('.file-shortcut-btn').forEach(btn => {
            btn.classList.remove('opacity-50', 'pointer-events-none');
            btn.disabled = false;
        });
    }
}

function parsePageSelection(input, maxPages) {
    if (!input || input.trim() === '') return null; // null = เอาทั้งหมด
    
    const pages = new Set();
    const parts = input.split(',');
    
    parts.forEach(part => {
        part = part.trim();
        if (part.includes('-')) {
            const [start, end] = part.split('-').map(Number);
            if (!isNaN(start) && !isNaN(end)) {
                for (let i = Math.min(start, end); i <= Math.max(start, end); i++) {
                    if (i >= 1 && i <= maxPages) pages.add(i);
                }
            }
        } else {
            const num = Number(part);
            if (!isNaN(num) && num >= 1 && num <= maxPages) {
                pages.add(num);
            }
        }
    });
    
    // เรียงลำดับจากน้อยไปมาก
    return Array.from(pages).sort((a, b) => a - b);
}

/**
 * [ฟังก์ชันใหม่] สร้างไฟล์ PDF ใหม่ที่มีเฉพาะหน้าที่เลือก (Render to Image -> PDF)
 */
async function createPdfFromSelectedPages(file, selectedPages) {
    // ใช้ jsPDF ที่มีอยู่แล้วในโปรเจค
    const { jsPDF } = window.jspdf;
    
    // อ่านไฟล์ PDF ต้นฉบับ
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
    
    const newPdf = new jsPDF();
    const totalSelected = selectedPages.length;

    for (let i = 0; i < totalSelected; i++) {
        const pageNum = selectedPages[i];
        
        // แจ้งสถานะการตัดต่อ
        const loaderText = document.getElementById('loader-text');
        if (loaderText) loaderText.textContent = `กำลังเตรียมหน้า PDF: หน้าที่ ${pageNum}...`;

        const page = await pdf.getPage(pageNum);
        
        // กำหนดคุณภาพ (Scale 1.5 = ชัดกำลังดี ไม่ใหญ่เกินไปสำหรับ AI)
        const viewport = page.getViewport({ scale: 1.5 });
        
        // สร้าง Canvas เพื่อวาดหน้า PDF เป็นรูปภาพ
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        await page.render({ canvasContext: context, viewport: viewport }).promise;
        
        // แปลงเป็นรูปภาพ JPEG (ขนาดเล็กกว่า PNG)
        const imgData = canvas.toDataURL('image/jpeg', 0.8);
        
        // เพิ่มหน้าใน PDF ใหม่
        if (i > 0) newPdf.addPage();
        
        // คำนวณขนาดให้พอดีหน้า A4 ใน PDF ใหม่
        const pdfPageWidth = newPdf.internal.pageSize.getWidth();
        const pdfPageHeight = newPdf.internal.pageSize.getHeight();
        const imgProps = newPdf.getImageProperties(imgData);
        const ratio = imgProps.width / imgProps.height;
        const pdfRatio = pdfPageWidth / pdfPageHeight;
        
        let finalW, finalH;
        if (ratio > pdfRatio) {
            finalW = pdfPageWidth;
            finalH = pdfPageWidth / ratio;
        } else {
            finalH = pdfPageHeight;
            finalW = pdfPageHeight * ratio;
        }

        newPdf.addImage(imgData, 'JPEG', 0, 0, finalW, finalH);
    }

    // คืนค่าเป็น Base64 string (ตัด prefix data uri ออก)
    const pdfOutput = newPdf.output('datauristring');
    return pdfOutput.split(',')[1];
}

async function ensureGlobalQuizzesLoaded() {
    if (allQuizzesGlobal.length > 0) {
        return; // ถ้ามีข้อมูลอยู่แล้ว ก็ไม่ต้องทำอะไร
    }

    console.log("Global quiz cache is empty. Fetching now...");
    showMessage("กำลังโหลดคลังข้อสอบทั้งหมด..."); // แจ้งให้ผู้ใช้ทราบ
    try {
        const qs = await getDocs(collection(db, `artifacts/${appId}/public/data/quizzes`));
        allQuizzesGlobal = qs.docs.map(d => ({ id: d.id, ...d.data() }));
        console.log(`Loaded ${allQuizzesGlobal.length} quizzes into global cache.`);
        messageModal.classList.add('hidden'); // ซ่อนข้อความ "กำลังโหลด..." เมื่อเสร็จ
    } catch (error) {
        console.error("Fatal: Could not fetch global quizzes.", error);
        messageModal.classList.add('hidden');
        // โยน error ออกไปเพื่อให้ฟังก์ชันที่เรียกใช้รู้ว่าล้มเหลว
        throw new Error("ไม่สามารถโหลดคลังข้อสอบได้");
    }
}

function exportQuizAsWorksheetPDF() {
    if (!currentQuizData || !currentQuizData.questions) {
        showMessage("ไม่พบข้อมูลแบบทดสอบสำหรับสร้างใบงาน");
        return;
    }

    const quizData = currentQuizData;
    const worksheetWindow = window.open('', '_blank');

    const toEngChar = (index) => String.fromCharCode(65 + index); // 65 คือรหัสของ 'A'

    const worksheetHtml = `
        <!DOCTYPE html>
        <html lang="th">
        <head>
            <meta charset="UTF-8">
            <title>แบบทดสอบ: ${quizData.topic}</title>
            <script src="https://cdn.tailwindcss.com"><\/script>
            <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
            
            <script>
                window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']] } };
            <\/script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"><\/script>
            <style>
                body { 
                    font-family: 'Sarabun', sans-serif;
                    font-size: 14px; /* ปรับขนาดอักษรให้เล็กลงอีกเล็กน้อยเพื่อความกระชับ */
                }
                @media print {
                    body { -webkit-print-color-adjust: exact; }
                }
                .question-item { 
                    break-inside: avoid; /* ป้องกันไม่ให้ข้อสอบ 1 ข้อถูกตัดแบ่งคอลัมน์ */
                }
                .answer-space {
                    border-bottom: 1px dotted black;
                    min-height: 22px;
                    display: block;
                    margin-top: 8px;
                }
                /* ▼▼▼ CSS สำหรับสร้าง 2 คอลัมน์ ▼▼▼ */
                .quiz-columns {
                    column-count: 2;
                    column-gap: 2rem; /* ระยะห่างระหว่างคอลัมน์ */
                }
            </style>
        </head>
        <body class="p-6 max-w-5xl mx-auto">
            <div class="text-center mb-6">
                <h1 class="text-xl font-bold">แบบทดสอบเรื่อง: ${quizData.topic}</h1>
            </div>
            <div class="flex justify-between mb-6 text-base">
                <p>ชื่อ-สกุล: ....................................................................</p>
                <p>เลขที่: .............</p>
                <p>คะแนน: .................</p>
            </div>
            <hr class="mb-4">
            
            <div class="quiz-columns">
                ${quizData.questions.map((q, index) => {
                    let questionBody = '';
                    const questionType = q.questionType || quizData.quizType;

                    switch(questionType) {
                        case 'multiple_choice':
                        case 'fill_in_with_choices':
                            // จัดเรียงตัวเลือกเป็น 1 คอลัมน์ภายในข้อ แต่ข้อสอบโดยรวมเป็น 2 คอลัมน์
                            questionBody = `<div class="mt-2 space-y-1 text-base">${q.options.map((opt, i) => `
                                <span>${toEngChar(i)}. ${opt}</span>
                            `).join('<br>')}</div>`;
                            break;
                        
                        case 'true_false':
                            questionBody = `<div class="mt-2 space-y-1 text-base">
                               <span>A. ถูก</span><br>
                                <span>B. ผิด</span>
                            </div>`;
                            break;

                        default: // สำหรับข้อเขียน
                            questionBody = `<div class="answer-space"></div>`;
                            break;
                    }

                    // ▼▼▼ เพิ่ม mb-5 (margin-bottom) ให้แต่ละข้อเพื่อเว้นระยะห่าง ▼▼▼
                    return `
                        <div class="question-item mb-5">
                            <div class="flex items-start">
                                <p class="font-semibold mr-2">${index + 1}.</p>
                                <div class="w-full">
                                    <p class="font-semibold">${q.stem || q.questionText}</p>
                                    ${q.imageCode ? `<div class="my-2">${q.imageCode}</div>` : ''}
                                    ${questionBody}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('')}
            </div>
			
			<div id="cropper-modal" class="fixed inset-0 bg-black bg-opacity-90 z-[70] hidden flex flex-col items-center justify-center p-4">
    <div class="relative w-full max-w-4xl h-[70vh] bg-black">
        <img id="image-to-crop" src="" class="max-w-full max-h-full block">
    </div>
    
    <div class="flex gap-4 mt-4">
        <button id="cancel-crop-btn" class="bg-gray-500 text-white py-2 px-6 rounded-lg hover:bg-gray-600 font-bold">
            <i class="fas fa-times"></i> ยกเลิก
        </button>
        <button id="confirm-crop-btn" class="bg-green-600 text-white py-2 px-6 rounded-lg hover:bg-green-700 font-bold shadow-lg transform transition hover:scale-105">
            <i class="fas fa-crop-alt"></i> ตัดส่วนนี้ & สแกน
        </button>
    </div>
</div>
			
        </body>
        </html>
    `;

    worksheetWindow.document.write(worksheetHtml);
    worksheetWindow.document.close();
    worksheetWindow.onload = function() {
        setTimeout(() => {
            worksheetWindow.print();
        }, 1500);
    };
}

/**
 * สร้างหน้า HTML สำหรับพิมพ์แบบทดสอบ (เวอร์ชันติวข้อสอบ ข้อละหน้า)
 */
function exportQuizAsTutorPDF() {
    if (!currentQuizData || !currentQuizData.questions) {
        showMessage("ไม่พบข้อมูลแบบทดสอบสำหรับสร้างใบงาน");
        return;
    }

    const quizData = currentQuizData;
    const worksheetWindow = window.open('', '_blank');
    const toEngChar = (index) => String.fromCharCode(65 + index);

    const worksheetHtml = `
        <!DOCTYPE html>
        <html lang="th">
        <head>
            <meta charset="UTF-8">
            <title>เอกสารติว: ${quizData.topic}</title>
            <script src="https://cdn.tailwindcss.com"><\/script>
            <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
            <script>
                window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']] } };
            <\/script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"><\/script>
            <style>
                body { font-family: 'Sarabun', sans-serif; }
                @media print {
                    body { -webkit-print-color-adjust: exact; }
                }
                /* ▼▼▼ CSS สำคัญ: สั่งให้ขึ้นหน้าใหม่หลังจบแต่ละข้อ ▼▼▼ */
                .page-break {
                    page-break-after: always;
                }
                .question-container {
                    min-height: 90vh; /* ทำให้แต่ละข้อเต็มหน้ากระดาษ */
                    display: flex;
                    flex-direction: column;
                }
            </style>
        </head>
        <body class="p-6 max-w-4xl mx-auto">
            ${quizData.questions.map((q, index) => {
                let questionBody = '';
                const questionType = q.questionType || quizData.quizType;
                switch(questionType) {
                    case 'multiple_choice':
                    case 'fill_in_with_choices':
                        questionBody = `<div class="mt-4 space-y-3 text-xl">${q.options.map((opt, i) => `
                            <span>${toEngChar(i)}. ${opt}</span>`).join('<br>')}
                        </div>`;
                        break;
                    case 'true_false':
                        questionBody = `<div class="mt-4 space-y-3 text-xl">
                            <span>A. ถูก</span><br><span>B. ผิด</span>
                        </div>`;
                        break;
                    default:
                        questionBody = '';
                        break;
                }
                return `
                <div class="page-break">
                    <div class="question-container">
                        <div class="flex-grow">
                            <p class="text-sm text-gray-500">แบบทดสอบเรื่อง: ${quizData.topic}</p>
                            <div class="flex items-start mt-4">
                                <p class="text-2xl font-bold mr-3">${index + 1}.</p>
                                <div class="w-full">
                                    <p class="text-2xl font-bold">${q.stem || q.questionText}</p>
                                    ${q.imageCode ? `<div class="my-6">${q.imageCode}</div>` : ''}
                                    ${questionBody}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                `;
            }).join('')}
        </body>
        </html>
    `;
    worksheetWindow.document.write(worksheetHtml);
    worksheetWindow.document.close();
    worksheetWindow.onload = function() {
        setTimeout(() => { worksheetWindow.print(); }, 1500);
    };
}

async function handleToggleStarQuiz(quizId) {
            const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
            try {
                const quizDoc = await getDoc(quizRef);
                if (quizDoc.exists()) {
                    const currentStatus = quizDoc.data().isStarred || false;
                    await updateDoc(quizRef, {
                        isStarred: !currentStatus
                    });
                }
            } catch (error) {
                console.error("Error toggling star status:", error);
                showMessage("เกิดข้อผิดพลาดในการติดดาว");
            }
        }

async function displayQuestionBank() {
    const container = document.getElementById('bank-input-area');
    container.innerHTML = '<div class="loader mx-auto"></div>'; // แสดงสถานะกำลังโหลด

    try {
        const bankCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/questionBank`);
        const q = query(bankCollectionRef); // สามารถเพิ่ม orderBy ได้ในอนาคต
        const snapshot = await getDocs(q);

        if (snapshot.empty) {
            container.innerHTML = '<p class="text-center text-gray-500">คลังข้อสอบของคุณยังว่างอยู่</p>';
            return;
        }

        let questionsHTML = snapshot.docs.map(doc => {
            const question = doc.data();
            const questionId = doc.id;
            return `
                <div class="flex items-start gap-3 p-2 border-b">
                    <input type="checkbox" value='${JSON.stringify(question)}' class="mt-1 h-4 w-4">
                    <div>
                        <p class="font-semibold">${question.questionText || question.stem}</p>
                        <p class="text-xs text-gray-500">จากเรื่อง: ${question.originalTopic}</p>
                    </div>
                </div>
            `;
        }).join('');

        container.innerHTML = `
            <div class="max-h-60 overflow-y-auto border rounded-lg p-2">${questionsHTML}</div>
            <button id="create-from-bank-btn" class="w-full bg-purple-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-purple-700">
                สร้างแบบทดสอบจากข้อที่เลือก
            </button>
        `;

        document.getElementById('create-from-bank-btn').addEventListener('click', createQuizFromBank);

    } catch (error) {
        console.error("Error displaying question bank:", error);
        container.innerHTML = '<p class="text-center text-red-500">ไม่สามารถโหลดคลังข้อสอบได้</p>';
    }
}

/**
 * ✅ ฟังก์ชันใหม่: สร้างหน้าสำหรับพิมพ์บทเรียนเป็น PDF
 */
async function handleExportLessonToPDF() {
    const lessonContentEl = document.getElementById("lesson-sections-container");
    const lessonTitle = document.getElementById('lesson-view-title').textContent || 'บทเรียน';

    if (!lessonContentEl) {
        showMessage("ไม่พบเนื้อหาบทเรียนสำหรับ Export");
        return;
    }

    // เปิดหน้าต่างใหม่เพื่อเตรียมพิมพ์
    const printWindow = window.open('', '_blank');

    // สร้างโครงสร้าง HTML ทั้งหมดสำหรับหน้าที่จะพิมพ์
    const printHtml = `
        <!DOCTYPE html>
        <html lang="th">
        <head>
            <meta charset="UTF-8">
            <title>${lessonTitle}</title>
            <script src="https://cdn.tailwindcss.com"><\/script>
            <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

            <script>
                window.MathJax = {
                    tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']] }
                };
            <\/script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"><\/script>

            <style>
                body { font-family: 'Sarabun', sans-serif; }
                @media print {
                    body { -webkit-print-color-adjust: exact; }
                    .no-print { display: none; }
                }
                /* คัดลอก Style ที่จำเป็นมาจากหน้าหลักเพื่อให้ PDF สวยงาม */
                .ai-content { page-break-inside: avoid; }
                .ai-content h1, .ai-content h2, .ai-content h3, .ai-content h4 { font-weight: 700; color: #1e3a8a; margin-top: 1.5rem; margin-bottom: 0.75rem; }
                .ai-content blockquote { background-color: #eff6ff; border-left: 4px solid #3b82f6; padding: 0.75rem 1rem; margin: 1rem 0; }
                .ai-content table { width: 100%; border-collapse: collapse; }
                .ai-content th, .ai-content td { border: 1px solid #e2e8f0; padding: 0.5rem 1rem; }
                .ai-content th { background-color: #fefce8; }
                .ai-content svg { max-width: 100%; height: auto; display: block; margin: 1rem auto; }
                .section-header { display: flex; align-items: center; font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem; color: #1e3a8a; border-bottom: 2px solid #dbeafe; padding-bottom: 0.5rem; }
                .section-header i { margin-right: 0.75rem; color: #3b82f6; }
            </style>
        </head>
        <body class="p-8 max-w-4xl mx-auto">
            <h1 class="text-3xl font-bold text-center mb-8">${lessonTitle}</h1>
            <div class="ai-content">
                ${lessonContentEl.innerHTML}
            </div>
        </body>
        </html>
    `;

    // เขียน HTML ลงในหน้าต่างใหม่
    printWindow.document.write(printHtml);
    printWindow.document.close();

    // รอให้เนื้อหาและ MathJax โหลดเสร็จ แล้วค่อยสั่งพิมพ์
    printWindow.onload = function() {
        setTimeout(() => {
            printWindow.print();
        }, 2000); // หน่วงเวลา 2 วินาทีเพื่อให้สูตรคณิตศาสตร์แสดงผลสมบูรณ์
    };
}

function showAdminLiveQuestionView(question, index, total) {
    const questionType = question.questionType || currentQuizData.quizType;
    let optionsHTML = '';

    if(questionType === 'multiple_choice' || questionType === 'true_false') {
        const options = questionType === 'true_false' ? ['ใช่', 'ไม่ใช่'] : question.options;
        const correctIndex = questionType === 'true_false' ? (question.correctAnswer ? 0 : 1) : question.correctAnswerIndex;

        optionsHTML = options.map((opt, i) => `
            <div class="p-4 rounded-lg text-xl flex items-center justify-center text-center bg-white/30" data-is-correct="${i === correctIndex}">
                ${opt}
            </div>
        `).join('');
    } else if (questionType === 'matching_item') {
        const options = question.allResponses || [];
        optionsHTML = options.map(opt => `
            <div class="p-4 rounded-lg text-xl flex items-center justify-center text-center bg-white/30" data-is-correct="${opt === question.correctResponse}">
                ${opt}
            </div>
        `).join('');
    }

    const questionDisplayText = question.stem || question.questionText;
    
    const adminQuestionHTML = `
        <div class="live-game-bg text-white rounded-lg p-8 flex flex-col h-full">
            <div class="flex justify-between items-center text-lg">
                <div class="flex items-center gap-4">
                    <span>ข้อที่ ${index + 1} / ${total}</span>
                    <span class="bg-white/20 px-3 py-1 rounded-full text-base font-mono" title="รหัสเข้าร่วมเกม">
                        <i class="fas fa-key mr-2 opacity-70"></i>${currentLiveGamePin}
                    </span>
                </div>

                <div class="flex items-center gap-4">
                    <span class="bg-white/20 px-3 py-1 rounded-full text-base">
                        ตอบแล้ว: <span id="answer-counter" class="font-bold">0/0</span>
                    </span>
                    <button id="manage-players-btn" class="text-xs bg-white/20 hover:bg-white/40 px-2 py-1 rounded-md">จัดการผู้เล่น</button>
                </div>
                <button id="end-game-btn" class="bg-red-600 text-white py-1 px-3 rounded-md hover:bg-red-700 text-sm">จบเกม</button>
            </div>

            <div id="live-player-management" class="hidden w-full max-w-lg mx-auto bg-black/20 p-2 rounded-lg mt-2 text-sm">
                <p class="text-center font-semibold mb-1">ผู้เล่นที่ยังอยู่ในเกม</p>
                <div id="live-player-list" class="flex flex-wrap justify-center gap-2">
                    </div>
            </div>

            <div class="flex-grow flex flex-col items-center justify-center">
                <h2 class="text-3xl font-bold mb-8 text-center">${questionDisplayText}</h2>
                <div class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-4">
                    ${optionsHTML}
                </div>
            </div>
            <div id="admin-action-buttons" class="text-center mt-8">
                <button id="reveal-answer-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-8 rounded-lg text-2xl">
                    <i class="fas fa-eye"></i> เฉลย
                </button>
            </div>
        </div>
    `;

    liveGameView.innerHTML = adminQuestionHTML;
    
    if (window.MathJax && MathJax.typesetPromise) { MathJax.typesetPromise([liveGameView]); }

    document.getElementById('reveal-answer-btn').addEventListener('click', () => revealAnswerForAdmin(index, total));
    
    // --- [START] นี่คือส่วนที่แก้ไข ---
    document.getElementById('end-game-btn').addEventListener('click', async () => {
        // เพิ่มการยืนยันก่อนจบเกม เพื่อป้องกันการกดพลาด
        showConfirmation(
            'คุณแน่ใจหรือไม่ว่าต้องการจบเกมนี้ก่อนเวลาอันควร?',
            async () => {
                const gameRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
                // เปลี่ยนจากการลบ เป็นการอัปเดตสถานะให้เป็น 'podium'
                await updateDoc(gameRef, { status: 'podium' });
            }
        );
    });
    // --- [END] สิ้นสุดส่วนที่แก้ไข ---

    document.getElementById('manage-players-btn').addEventListener('click', () => {
        document.getElementById('live-player-management').classList.toggle('hidden');
    });
}

// ▼▼▼ เพิ่มฟังก์ชันใหม่นี้เข้าไปทั้งหมด ▼▼▼

/**
 * [ใหม่] แสดง Modal ให้เลือกโปรเจคก่อนเริ่มสร้างแบบทดสอบจาก Blueprint
 * @param {string} topicName - ชื่อหัวข้อที่จะใช้สร้างแบบทดสอบ
 */
function promptForProjectBeforeGenerating(topicName) {
    const modal = document.getElementById('move-quiz-modal'); // เราจะใช้ Modal ของการ "ย้าย" มาประยุกต์ใช้
    const projectSelect = document.getElementById('move-quiz-project-select');
    const modalTitle = modal.querySelector('h3');
    const confirmBtn = document.getElementById('confirm-move-quiz-btn');
    const cancelBtn = document.getElementById('cancel-move-quiz-btn');

    // 1. เปลี่ยนข้อความใน Modal ให้เหมาะสมกับการสร้างควิซ
    modalTitle.textContent = 'เลือกโปรเจคที่จะบันทึกแบบทดสอบ';
    confirmBtn.textContent = 'เลือกและเริ่มสร้าง';
    confirmBtn.disabled = true; // ปิดปุ่มไว้ก่อนจนกว่าจะเลือก

    // 2. แสดงรายการโปรเจคทั้งหมดที่มีในระบบ
    if (allProjects.length === 0) {
        projectSelect.innerHTML = '<option value="">ยังไม่มีโปรเจคให้เลือก</option>';
    } else {
        projectSelect.innerHTML = '<option value="">-- เลือกโปรเจค --</option>' +
            allProjects.map(p => `<option value="${p.id}">${p.projectName}</option>`).join('');
        confirmBtn.disabled = false;
    }

    // 3. แสดง Modal
    modal.classList.remove('hidden');

    // 4. สร้าง Event Listener ที่จะทำงานแค่ครั้งเดียวสำหรับปุ่ม "ยืนยัน"
// ▼▼▼ วางทับ confirmHandler เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
const confirmHandler = async () => { // <--- เพิ่ม async เข้าไป
    const selectedProjectId = projectSelect.value;
    if (!selectedProjectId) {
        showMessage("กรุณาเลือกโปรเจคก่อน");
        return;
    }

    // ซ่อน Modal ก่อน
    modal.classList.add('hidden');

    // 1. (เพิ่ม) โหลดข้อมูลของโปรเจคที่เลือก
    await loadProjectDetails(selectedProjectId);

    // 2. (เพิ่ม) สั่งให้เปลี่ยนไปแสดงหน้า "รายละเอียดโปรเจค"
    showView('project-detail');

    // 3. เริ่มสร้างแบบทดสอบ (ซึ่งตอนนี้จะแสดงผลในหน้าที่ถูกต้องแล้ว)
    handleGenerateQuizFromBlueprintTopic(topicName);

    // 4. คืนค่า Modal ให้เป็นปกติ
    cleanup();
};
// ▲▲▲ สิ้นสุดโค้ดสำหรับวางทับ ▲▲▲

    // ฟังก์ชันสำหรับคืนค่า Modal และลบ Event Listener ที่สร้างขึ้นชั่วคราว
    const cleanup = () => {
        modalTitle.textContent = 'ย้ายแบบทดสอบไปโปรเจคอื่น';
        confirmBtn.textContent = 'ย้าย';
        confirmBtn.removeEventListener('click', confirmHandler);
        cancelBtn.removeEventListener('click', cleanup);
        // **สำคัญ:** คืนค่า Event Listener เดิมของปุ่ม "ยืนยัน" ให้กลับไปทำงานเหมือนเดิม
        confirmBtn.addEventListener('click', confirmMoveQuiz);
    };
    
    // **สำคัญ:** เราต้องลบ Listener เก่าของปุ่ม "ยืนยัน" (confirmMoveQuiz) ออกไปก่อนชั่วคราว
    // เพื่อป้องกันไม่ให้โค้ดทำงานซ้ำซ้อนกัน
    confirmBtn.removeEventListener('click', confirmMoveQuiz);
    
    // เพิ่ม Listener ใหม่เข้าไป
    confirmBtn.addEventListener('click', confirmHandler);
    cancelBtn.addEventListener('click', cleanup);
}
// ▲▲▲ สิ้นสุดฟังก์ชันใหม่ ▲▲▲

function showStudentLiveQuestionView(question, index, total) {
    const questionType = question.questionType || currentQuizData.quizType;
    let optionsHTML = '';

            if(questionType === 'multiple_choice' || questionType === 'true_false') {
                const options = questionType === 'true_false' ? ['ใช่', 'ไม่ใช่'] : question.options;
                optionsHTML = options.map((opt, i) => `
                    <button data-index="${i}" class="live-answer-btn p-4 rounded-lg text-xl text-center bg-white text-gray-800 hover:bg-indigo-100 transition-all transform hover:scale-105">
                        ${opt}
                    </button>
                `).join('');
            } else if (questionType === 'matching_item') { // <-- เพิ่มส่วนนี้
                const options = question.allResponses || [];
                optionsHTML = options.map((opt, i) => `
                    <button data-index="${i}" class="live-answer-btn p-4 rounded-lg text-xl text-center bg-white text-gray-800 hover:bg-indigo-100 transition-all transform hover:scale-105">
                        ${opt}
                    </button>
                `).join('');
				} else if (questionType === 'short_answer') { // <-- เพิ่มส่วนนี้
                optionsHTML = `
                    <div class="w-full md:col-span-2 flex flex-col items-center gap-4">
                        <textarea id="live-short-answer-input" class="w-full max-w-lg p-3 border rounded-lg text-gray-800 text-lg" rows="3" placeholder="พิมพ์คำตอบของคุณ..."></textarea>
                        <button id="live-submit-short-answer-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-xl">
                            <i class="fas fa-paper-plane mr-2"></i>ส่งคำตอบ
                        </button>
                    </div>
                `;
            }

				const questionDisplayText = question.stem || question.questionText; // <-- เพิ่มบรรทัดนี้
    const studentQuestionHTML = `
        <div class="live-game-bg text-white rounded-lg p-8 flex flex-col h-full">
            <p class="text-lg text-center">ข้อที่ ${index + 1} / ${total}</p>
            <div class="flex-grow flex flex-col items-center justify-center">
                <h2 class="text-3xl font-bold mb-8 text-center">${questionDisplayText}</h2>
                <div id="live-options-container" class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-4">
                    ${optionsHTML}
                </div>
            </div>
        </div>
    `;
    liveGameView.innerHTML = studentQuestionHTML;

    
    // Typeset math after injecting student live question
    if (window.MathJax && MathJax.typesetPromise) { MathJax.typesetPromise([liveGameView]); }
	
	 // --- [ เริ่ม ] เพิ่มโค้ดส่วนนี้เข้าไป ---
    const submitShortAnswerBtn = document.getElementById('live-submit-short-answer-btn');
    if (submitShortAnswerBtn) {
        submitShortAnswerBtn.addEventListener('click', () => {
            const answerText = document.getElementById('live-short-answer-input').value;
            handleLiveAnswer(answerText, question); // ส่งข้อความที่พิมพ์ไปจัดการต่อ
        });
    }
    // --- [ สิ้นสุด ] เพิ่มโค้ดส่วนนี้เข้าไป ---
	
// Add event listener for student answers
    document.getElementById('live-options-container').addEventListener('click', (e) => {
        const btn = e.target.closest('.live-answer-btn');
        if (btn) {
            const answerIndex = parseInt(btn.dataset.index);
            handleLiveAnswer(answerIndex, question);
        }
    });
}

// ▼▼▼ เพิ่มฟังก์ชันใหม่ทั้งหมดนี้เข้าไปใน <script> ▼▼▼

/**
 * [Shortcuts] เริ่มฟังข้อมูลปุ่มลัดจาก Firestore
 */
function listenForBlueprintShortcuts() {
    const shortcutsRef = doc(db, "globalSettings", "dashboardConfig");

    onSnapshot(shortcutsRef, (docSnap) => {
        let shortcuts = [];
        let tabs = [];
        let order = {};

        if (docSnap.exists()) {
            const data = docSnap.data();
            shortcuts = data.blueprintShortcuts || [];
            tabs = data.shortcutTabs || [];
            order = data.shortcutOrder || {};
        }

        if (!tabs.find(t => t.id === 'all')) {
            tabs.unshift({ id: 'all', name: 'ปุ่มลัดทั้งหมด', isDefault: true });
        }

        if (!shortcuts.find(s => s.id === 'default-1')) {
            shortcuts.unshift({ id: 'default-1', name: 'Blueprint 1', blueprintUrl: '', referenceUrl: '', isDefault: true });
        }
        if (!shortcuts.find(s => s.id === 'default-2')) {
            shortcuts.unshift({ id: 'default-2', name: 'Blueprint 2', blueprintUrl: '', referenceUrl: '', isDefault: true });
        }

        blueprintShortcuts = shortcuts;
        shortcutTabs = tabs;
        shortcutOrder = order;

        // ▼▼▼ เพิ่มบรรทัดนี้กลับเข้าไป เพื่อสั่งให้วาดปุ่มที่หน้า Dashboard หลักเสมอ ▼▼▼
        renderBlueprintShortcuts(); 
        // ▲▲▲ สิ้นสุดส่วนที่เพิ่ม ▲▲▲

        if (!document.getElementById('additional-shortcuts-modal').classList.contains('hidden')) {
            renderAdditionalShortcutsModal();
        }
    });
}

// ▼▼▼ เพิ่มโค้ดชุดฟังก์ชันใหม่นี้ทั้งหมดเข้าไปใน <script> ▼▼▼

/**
 * [CORE] ฟังก์ชันหลักสำหรับวาดหน้าต่าง Modal ทั้งหมด (แท็บ + รายการปุ่มลัด)
 */
function renderAdditionalShortcutsModal() {
    const navContainer = document.getElementById('shortcut-tabs-nav');
    const listContainer = document.getElementById('additional-shortcuts-list');
    if (!navContainer || !listContainer) return;

    // --- 1. วาดแถบแท็บ (Tab Navigation) ---
    navContainer.innerHTML = shortcutTabs.map(tab => {
        const isActive = tab.id === activeShortcutTabId;
        const activeClasses = 'border-indigo-500 text-indigo-600';
        const inactiveClasses = 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300';
        
        return `
            <div class="relative group flex items-center">
                <button data-tab-id="${tab.id}" class="shortcut-tab-btn whitespace-nowrap py-3 px-2 border-b-2 font-medium text-sm ${isActive ? activeClasses : inactiveClasses}">
                    <span class="tab-name-display pointer-events-none">${tab.name}</span>
                    <input type="text" value="${tab.name}" class="tab-name-input hidden bg-transparent border-b-2 border-indigo-500 text-sm font-medium focus:outline-none w-32">
                </button>
                ${!tab.isDefault ? `
                    <button data-tab-id="${tab.id}" class="delete-shortcut-tab-btn absolute -top-1 -right-1 text-red-400 hover:text-red-700 opacity-0 group-hover:opacity-100 transition-opacity rounded-full bg-white text-lg w-5 h-5 flex items-center justify-center" title="ลบแท็บนี้">
                        &times;
                    </button>
                ` : ''}
            </div>
        `;
    }).join('');

    // --- 2. กรองและจัดเรียงปุ่มลัดตามแท็บที่เลือก ---
    const activeTab = shortcutTabs.find(t => t.id === activeShortcutTabId);
    let shortcutsToShow = [];

    if (activeTab) {
        if (activeTab.isDefault) { // แท็บ "ทั้งหมด"
            shortcutsToShow = [...blueprintShortcuts];
        } else { // แท็บที่สร้างเอง
            const shortcutIdsInTab = activeTab.shortcutIds || [];
            shortcutsToShow = blueprintShortcuts.filter(s => shortcutIdsInTab.includes(s.id));
        }
    }
    
    // จัดเรียงตามลำดับที่ผู้ใช้ลากวาง
    const currentOrder = shortcutOrder[activeShortcutTabId] || [];
    shortcutsToShow.sort((a, b) => {
        const indexA = currentOrder.indexOf(a.id);
        const indexB = currentOrder.indexOf(b.id);
        if (indexA === -1) return 1;
        if (indexB === -1) return -1;
        return indexA - indexB;
    });

    // --- 3. สร้าง HTML สำหรับรายการปุ่มลัด ---
    listContainer.innerHTML = shortcutsToShow.length > 0 ? shortcutsToShow.map(shortcut => {
        let icon = '🧩';
        if (shortcut.blueprintUrl && shortcut.referenceUrl) icon = '📗';
        else if (shortcut.blueprintUrl) icon = '📘';

        const otherTabs = shortcutTabs.filter(t => !t.isDefault);
const moveDropdownHTML = activeTab.isDefault && otherTabs.length > 0 ? `
    <div class="relative inline-block text-left group/dropdown">
        <button class="move-shortcut-menu-btn text-gray-500 hover:text-blue-700 p-1 rounded-full text-sm"><i class="fas fa-ellipsis-v"></i></button>
        <div class="move-shortcut-dropdown origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden z-20">
            <div class="py-1" role="menu">
                        <p class="px-4 pt-1 pb-2 text-xs text-gray-400">เพิ่มไปยังแท็บ:</p>
                        ${otherTabs.map(tab => `
                            <a href="#" class="move-shortcut-item block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" data-shortcut-id="${shortcut.id}" data-target-tab-id="${tab.id}">${tab.name}</a>
                        `).join('')}
                    </div>
                </div>
            </div>
        ` : '';

        return `
            <div class="shortcut-list-item p-3 border-b hover:bg-gray-50 flex items-center justify-between" data-shortcut-id="${shortcut.id}" draggable="true">
                <div>
                    <p class="font-semibold text-blue-700">${icon} ${shortcut.name}</p>
                </div>
                <div class="flex items-center gap-2 shrink-0">
                    <button data-id="${shortcut.id}" class="use-hidden-shortcut-btn bg-blue-100 text-blue-700 text-sm py-1 px-3 rounded-md hover:bg-blue-200">ใช้งาน</button>
                    <button data-id="${shortcut.id}" class="edit-hidden-shortcut-btn bg-yellow-100 text-yellow-700 text-sm py-1 px-3 rounded-md hover:bg-yellow-200">แก้ไข</button>
                    ${!shortcut.isDefault ? `<button data-id="${shortcut.id}" class="delete-hidden-shortcut-btn bg-red-100 text-red-700 text-sm py-1 px-3 rounded-md hover:bg-red-200">ลบ</button>` : ''}
                    ${!activeTab.isDefault ? `<button data-shortcut-id="${shortcut.id}" class="remove-shortcut-from-tab-btn text-red-500 ml-2" title="นำออกจากแท็บนี้"><i class="fas fa-times-circle"></i></button>` : ''}
                    ${moveDropdownHTML}
                </div>
            </div>`;
    }).join('') : '<p class="p-4 text-center text-gray-500">ไม่มีปุ่มลัดในแท็บนี้</p>';
    
    // 4. เรียกฟังก์ชันเพื่อผูก Event Listeners ให้กับปุ่มและรายการที่สร้างขึ้นใหม่
    setupShortcutModalEventListeners();
}

/**
 * ฟังก์ชันสำหรับผูก Event Listener ทั้งหมดภายใน Modal
 */
function setupShortcutModalEventListeners() {
    // สลับแท็บ
    document.querySelectorAll('.shortcut-tab-btn').forEach(btn => {
        btn.addEventListener('click', e => {
            activeShortcutTabId = e.currentTarget.dataset.tabId;
            renderAdditionalShortcutsModal();
        });
        
        btn.addEventListener('dblclick', e => {
            const container = e.currentTarget;
            container.querySelector('.tab-name-display').classList.add('hidden');
            const input = container.querySelector('.tab-name-input');
            input.classList.remove('hidden');
            input.focus();
            input.select();
        });
    });

    // บันทึกการเปลี่ยนชื่อแท็บ
    document.querySelectorAll('.tab-name-input').forEach(input => {
        const save = () => {
            const tabId = input.closest('.shortcut-tab-btn').dataset.tabId;
            handleRenameShortcutTab(tabId, input.value);
        };
        input.addEventListener('blur', save);
        input.addEventListener('keydown', e => { if (e.key === 'Enter') input.blur(); });
    });
    
    // ลบแท็บ
    document.querySelectorAll('.delete-shortcut-tab-btn').forEach(btn => {
        btn.addEventListener('click', e => handleDeleteShortcutTab(e.currentTarget.dataset.tabId));
    });

    // ย้ายปุ่มลัดไปแท็บอื่น (เมื่อคลิกที่ชื่อแท็บในเมนู Dropdown)
    document.querySelectorAll('.move-shortcut-item').forEach(item => {
        item.addEventListener('click', e => {
            e.preventDefault();
            const { shortcutId, targetTabId } = e.currentTarget.dataset;
            handleMoveShortcutToTab(shortcutId, targetTabId);
        });
    });
    
    // นำปุ่มลัดออกจากแท็บปัจจุบัน
    document.querySelectorAll('.remove-shortcut-from-tab-btn').forEach(btn => {
        btn.addEventListener('click', e => {
            handleRemoveShortcutFromTab(e.currentTarget.dataset.shortcutId, activeShortcutTabId);
        });
    });

    // จัดการปุ่ม "ใช้งาน", "แก้ไข", "ลบ" (เหมือนเดิม)
    const listContainer = document.getElementById('additional-shortcuts-list');
    listContainer.querySelectorAll('.use-hidden-shortcut-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.getElementById('additional-shortcuts-modal').classList.add('hidden');
            handleShortcutClick(btn.dataset.id);
        });
    });
    // (โค้ดสำหรับ Event Listener ของปุ่ม edit และ delete ที่เหลือในส่วนนี้จะทำงานตามปกติ)


    // จัดการ Drag-and-Drop (เหมือนเดิม)
    let draggedItem = null;
    listContainer.addEventListener('dragstart', e => {
        draggedItem = e.target.closest('.shortcut-list-item');
        if (draggedItem) {
            setTimeout(() => draggedItem.classList.add('opacity-50'), 0);
        }
    });
    listContainer.addEventListener('dragend', () => {
        if (draggedItem) {
            draggedItem.classList.remove('opacity-50');
            draggedItem = null;
        }
    });
    listContainer.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = [...listContainer.querySelectorAll('.shortcut-list-item:not(.opacity-50)')].reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = e.clientY - box.top - box.height / 2;
            return (offset < 0 && offset > closest.offset) ? { offset: offset, element: child } : closest;
        }, { offset: Number.NEGATIVE_INFINITY }).element;
        
        if (afterElement == null) {
            listContainer.appendChild(draggedItem);
        } else {
            listContainer.insertBefore(draggedItem, afterElement);
        }
    });
    listContainer.addEventListener('drop', e => {
        e.preventDefault();
        if (draggedItem) {
            const newOrder = [...listContainer.querySelectorAll('.shortcut-list-item')].map(item => item.dataset.shortcutId);
            handleShortcutOrderChange(activeShortcutTabId, newOrder);
        }
    });

    // --- [ส่วนที่แก้ไข/เพิ่มเข้ามาใหม่] ---
    // จัดการการคลิกเพื่อเปิด/ปิดเมนู "ย้าย"
    document.querySelectorAll('.move-shortcut-menu-btn').forEach(btn => {
        btn.addEventListener('click', e => {
            e.stopPropagation(); // ป้องกันไม่ให้ event การคลิกกระจายไปที่อื่น
            const dropdown = e.currentTarget.nextElementSibling;
            const isCurrentlyHidden = dropdown.classList.contains('hidden');

            // ปิดเมนูอื่นๆ ทั้งหมดก่อน
            document.querySelectorAll('.move-shortcut-dropdown').forEach(d => d.classList.add('hidden'));

            // ถ้าเมนูที่คลิกกำลังซ่อนอยู่ ให้แสดงขึ้นมา
            if (isCurrentlyHidden) {
                dropdown.classList.remove('hidden');
            }
        });
    });
}

// เพิ่ม Event Listener ให้กับหน้าเว็บทั้งหมด เพื่อปิดเมนูเมื่อคลิกที่บริเวณอื่น
document.addEventListener('click', (e) => {
    // ถ้าไม่ได้คลิกที่บริเวณเมนู ให้ซ่อนเมนูทั้งหมด
    if (!e.target.closest('.group\\/dropdown')) {
         document.querySelectorAll('.move-shortcut-dropdown').forEach(d => d.classList.add('hidden'));
    }
});

/**
 * ฟังก์ชันสำหรับบันทึกข้อมูลแท็บและลำดับลง Firestore
 */
async function saveShortcutConfig() {
    const configRef = doc(db, "globalSettings", "dashboardConfig");
    try {
        await setDoc(configRef, { 
            shortcutTabs: shortcutTabs,
            shortcutOrder: shortcutOrder
        }, { merge: true });
    } catch (error) {
        console.error("Error saving shortcut config:", error);
    }
}

// ฟังก์ชันจัดการแท็บและปุ่มลัด
async function handleAddShortcutTab() {
    const name = prompt("กรุณาตั้งชื่อแท็บใหม่:", "แท็บใหม่");
    if (!name || name.trim() === '') return;
    shortcutTabs.push({ id: `tab_${Date.now()}`, name: name.trim(), shortcutIds: [] });
    await saveShortcutConfig();
}
async function handleRenameShortcutTab(tabId, newName) {
    const tab = shortcutTabs.find(t => t.id === tabId);
    if (tab && newName.trim() !== '') {
        tab.name = newName.trim();
        await saveShortcutConfig();
    }
}
async function handleDeleteShortcutTab(tabId) {
    const tab = shortcutTabs.find(t => t.id === tabId);
    if (tab && !tab.isDefault) {
        showConfirmation(`คุณแน่ใจว่าต้องการลบแท็บ "${tab.name}"? (ปุ่มลัดจะไม่ถูกลบ)`, async () => {
            shortcutTabs = shortcutTabs.filter(t => t.id !== tabId);
            delete shortcutOrder[tabId];
            if (activeShortcutTabId === tabId) activeShortcutTabId = 'all'; // กลับไปแท็บหลัก
            await saveShortcutConfig();
        });
    }
}
async function handleMoveShortcutToTab(shortcutId, targetTabId) {
    const targetTab = shortcutTabs.find(t => t.id === targetTabId);
    if (targetTab && !targetTab.shortcutIds.includes(shortcutId)) {
        targetTab.shortcutIds.push(shortcutId);
        await saveShortcutConfig();
    }
}
async function handleRemoveShortcutFromTab(shortcutId, sourceTabId) {
    const sourceTab = shortcutTabs.find(t => t.id === sourceTabId);
    if (sourceTab && !sourceTab.isDefault) {
        sourceTab.shortcutIds = sourceTab.shortcutIds.filter(id => id !== shortcutId);
        await saveShortcutConfig();
    }
}
async function handleShortcutOrderChange(tabId, newOrder) {
    shortcutOrder[tabId] = newOrder;
    await saveShortcutConfig();
}

// ▲▲▲ สิ้นสุดชุดฟังก์ชันใหม่ ▲▲▲

function renderBlueprintShortcuts() {
    const container = document.getElementById('blueprint-shortcut-container');
    const additionalList = document.getElementById('additional-shortcuts-list');
    const loadingMsg = document.getElementById('shortcuts-loading-msg');

    if (loadingMsg) {
        loadingMsg.classList.add('hidden');
    }
    if (!container || !additionalList) return;

    const visibleShortcuts = blueprintShortcuts.slice(0, 4);
    const hiddenShortcuts = blueprintShortcuts.slice(4);

    container.innerHTML = visibleShortcuts.map(shortcut => {
        let bgColor = 'bg-gray-200 hover:bg-gray-300 text-gray-700';
        let icon = '🧩';
        
        if (shortcut.blueprintUrl && shortcut.referenceUrl) {
            bgColor = 'bg-green-500 hover:bg-green-600 text-white';
            icon = '📗';
        } else if (shortcut.blueprintUrl) {
            bgColor = 'bg-blue-500 hover:bg-blue-600 text-white';
            icon = '📘';
        }

        const deleteBtnHtml = !shortcut.isDefault ? 
            `<button data-id="${shortcut.id}" class="delete-shortcut-btn absolute top-1 right-1 w-6 h-6 bg-red-500 text-white rounded-full text-xs opacity-0 group-hover:opacity-100 transition-opacity" title="ลบ">&times;</button>` : '';

        // *** START: แก้ไขขนาดปุ่มตรงนี้ ***
        return `
            <div class="relative group">
                <div data-id="${shortcut.id}" class="shortcut-btn rounded-2xl shadow-lg p-4 flex items-center justify-center text-center font-semibold cursor-pointer transition transform hover:scale-105 h-24 ${bgColor}">
                    <span class="pointer-events-none">${icon} ${shortcut.name}</span>
                </div>
                <button data-id="${shortcut.id}" class="edit-shortcut-btn absolute bottom-1 right-1 w-6 h-6 bg-white/50 text-gray-800 rounded-full text-xs opacity-0 group-hover:opacity-100 transition-opacity" title="แก้ไข"><i class="fas fa-pen"></i></button>
                ${deleteBtnHtml}
            </div>
        `;
        // *** END: สิ้นสุดการแก้ไขขนาด ***
    }).join('');

    if (hiddenShortcuts.length > 0) {
        // *** START: แก้ไขขนาดปุ่ม "เพิ่มเติม" ตรงนี้ ***
        container.innerHTML += `
            <div id="open-additional-shortcuts-btn" class="rounded-2xl shadow-lg p-4 flex flex-col items-center justify-center text-center font-semibold cursor-pointer transition transform hover:scale-105 h-24 bg-gray-100 hover:bg-gray-200 text-gray-600">
                <i class="fas fa-ellipsis-h text-xl"></i>
                <span class="mt-2 text-sm">ปุ่มลัดเพิ่มเติม</span>
            </div>
        `;
        // *** END: สิ้นสุดการแก้ไขขนาด ***
    }

    if (hiddenShortcuts.length > 0) {
        additionalList.innerHTML = hiddenShortcuts.map(shortcut => {
            let icon = '🧩';
            if (shortcut.blueprintUrl && shortcut.referenceUrl) {
                icon = '📗';
            } else if (shortcut.blueprintUrl) {
                icon = '📘';
            }

            return `
            <div class="p-3 border-b hover:bg-gray-100 flex items-center justify-between">
                <div>
                    <p class="font-semibold text-blue-700">${icon} ${shortcut.name}</p>
                </div>
                <div class="flex items-center gap-2 shrink-0">
                    <button data-id="${shortcut.id}" class="use-hidden-shortcut-btn bg-blue-100 text-blue-700 text-sm py-1 px-3 rounded-md hover:bg-blue-200">ใช้งาน</button>
                    <button data-id="${shortcut.id}" class="edit-hidden-shortcut-btn bg-yellow-100 text-yellow-700 text-sm py-1 px-3 rounded-md hover:bg-yellow-200">แก้ไข</button>
                    ${!shortcut.isDefault ? `<button data-id="${shortcut.id}" class="delete-hidden-shortcut-btn bg-red-100 text-red-700 text-sm py-1 px-3 rounded-md hover:bg-red-200">ลบ</button>` : ''}
                </div>
            </div>
            `;
        }).join('');
    } else {
        additionalList.innerHTML = '<p class="p-4 text-center text-gray-500">ไม่มีปุ่มลัดเพิ่มเติม</p>';
    }
}

// ▼▼▼ เพิ่มฟังก์ชันใหม่นี้เข้าไปใน <script> ▼▼▼
/**
 * [Helper] แปลงชื่อไฟล์เป็น MIME Type ที่ถูกต้อง
 */
function getMimeTypeFromFilename(filename) {
    const extension = filename.split('.').pop().toLowerCase();
    switch (extension) {
        case 'pdf':
            return 'application/pdf';
        case 'txt':
            return 'text/plain';
        default:
            // คืนค่าเป็น pdf ถ้าไม่รู้จัก เพื่อให้โอกาสทำงานได้มากที่สุด
            return 'application/pdf';
    }
}
// ▲▲▲ สิ้นสุดฟังก์ชันใหม่ ▲▲▲

function openShortcutEditor(shortcutId = null) {
    const modal = document.getElementById('shortcut-editor-modal');
    const title = document.getElementById('shortcut-modal-title');
    const idInput = document.getElementById('shortcut-id-input');
    const nameInput = document.getElementById('shortcut-name-input');
    const blueprintUrlInput = document.getElementById('shortcut-blueprint-url-input');
    const referenceUrlInput = document.getElementById('shortcut-reference-url-input');

    if (shortcutId) {
        // โหมดแก้ไข
        const shortcut = blueprintShortcuts.find(s => s.id === shortcutId);
        if (!shortcut) return;
        title.textContent = 'แก้ไขปุ่มลัด';
        idInput.value = shortcut.id;
        nameInput.value = shortcut.name;
        blueprintUrlInput.value = shortcut.blueprintUrl || '';
        referenceUrlInput.value = shortcut.referenceUrl || '';
    } else {
        // โหมดเพิ่มใหม่
        title.textContent = 'เพิ่มปุ่มลัดใหม่';
        idInput.value = ''; // ปล่อยว่างไว้เพื่อสร้าง ID ใหม่
        nameInput.value = '';
        blueprintUrlInput.value = '';
        referenceUrlInput.value = '';
    }
    modal.classList.remove('hidden');
}

/**
 * [Shortcuts] บันทึกการเปลี่ยนแปลงจาก Modal ลง Firebase
 */
async function saveShortcutChanges() {
    const id = document.getElementById('shortcut-id-input').value;
    const name = document.getElementById('shortcut-name-input').value.trim();
    const blueprintUrl = document.getElementById('shortcut-blueprint-url-input').value.trim();

    if (!name || !blueprintUrl) {
        showMessage("กรุณากรอก 'ชื่อปุ่มลัด' และ 'ลิงก์ Test Blueprint'");
        return;
    }

    const newShortcutData = {
        id: id || `shortcut_${Date.now()}`,
        name: name,
        blueprintUrl: blueprintUrl,
        referenceUrl: document.getElementById('shortcut-reference-url-input').value.trim(),
        isDefault: id.startsWith('default-')
    };

    let updatedShortcuts;
    if (id) {
        updatedShortcuts = blueprintShortcuts.map(s => s.id === id ? newShortcutData : s);
    } else {
        updatedShortcuts = [...blueprintShortcuts, newShortcutData];
    }

    try {
        // เปลี่ยน path ตรงนี้
        const prefRef = doc(db, "globalSettings", "dashboardConfig");
        await setDoc(prefRef, { blueprintShortcuts: updatedShortcuts }, { merge: true });
        document.getElementById('shortcut-editor-modal').classList.add('hidden');
    } catch (error) {
        console.error("Error saving shortcut:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึก");
    }
}

async function handleShortcutClick(shortcutId) {
    const shortcut = blueprintShortcuts.find(s => s.id === shortcutId);
    if (!shortcut || !shortcut.blueprintUrl) return;

    // ซ่อนตัวเลือกและปุ่มสร้างหลัก
    document.getElementById('blueprint-options-container').classList.add('hidden');
    document.getElementById('generate-from-blueprint-btn').disabled = true;

    const loader = document.getElementById('loader');
    const loaderText = document.getElementById('loader-text');

    document.getElementById('quiz-generation-area').classList.remove('hidden');
    document.getElementById('generated-quiz-container').innerHTML = '';
    loader.classList.remove('hidden');

    try {
        loaderText.textContent = 'กำลังดึงไฟล์ Blueprint จากลิงก์...';
        const blueprintFile = await fetchFileFromUrl(shortcut.blueprintUrl, "blueprint.pdf");

        let referenceFile = null;
        if (shortcut.referenceUrl) {
            loaderText.textContent = 'กำลังดึงไฟล์อ้างอิงจากลิงก์...';

            // --- [START] ส่วนที่แก้ไข ---
            // ตรวจสอบนามสกุลของ URL เพื่อกำหนดชื่อไฟล์ที่ถูกต้อง
            const referenceFilename = shortcut.referenceUrl.toLowerCase().endsWith('.txt') 
                ? "reference.txt" 
                : "reference.pdf";
            referenceFile = await fetchFileFromUrl(shortcut.referenceUrl, referenceFilename);
            // --- [END] สิ้นสุดส่วนที่แก้ไข ---
        }

        // ส่ง File object ที่ได้ไปให้ฟังก์ชันสร้างข้อสอบ
        await handleGenerateFromBlueprintWithFiles(blueprintFile, referenceFile);

    } catch (error) {
        console.error("Error processing shortcut click:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
        loader.classList.add('hidden');
    }
}

function getDirectDownloadUrl(driveUrl) {
    const fileIdMatch = driveUrl.match(/file\/d\/([a-zA-Z0-9_-]+)/);
    if (fileIdMatch && fileIdMatch[1]) {
        return `https://drive.google.com/uc?export=download&id=${fileIdMatch[1]}`;
    }
    return driveUrl; // คืนค่า URL เดิมถ้าไม่ใช่รูปแบบที่รู้จัก
}

async function fetchFileFromUrl(url, defaultFilename) {
    const directUrl = getDirectDownloadUrl(url);
    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(directUrl)}`;

    const response = await fetch(proxyUrl);
    if (!response.ok) {
        throw new Error(`ไม่สามารถโหลดไฟล์จากลิงก์ได้ (Status: ${response.status})`);
    }

const blob = await response.blob();

    // --- [START] ส่วนที่แก้ไขใหม่ทั้งหมด ---

    // 1. อ่าน 4 byte แรกของไฟล์เพื่อตรวจสอบ "Magic Number"
    const fileHeader = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        // เมื่ออ่านเสร็จ ให้คืนค่าเป็น Array ของ byte
        reader.onloadend = () => resolve(new Uint8Array(reader.result));
        reader.onerror = reject;
        // สั่งให้อ่านข้อมูลแค่ 4 byte แรกของไฟล์เท่านั้น
        reader.readAsArrayBuffer(blob.slice(0, 4));
    });

    let determinedMimeType = '';
    // 2. แปลง byte ที่อ่านได้เป็นข้อความ (Text)
    const headerText = new TextDecoder().decode(fileHeader);

    // 3. ตรวจสอบว่าข้อความที่ได้คือ "%PDF" หรือไม่
    if (headerText === '%PDF') {
        determinedMimeType = 'application/pdf';
        console.log('File content identified as PDF by its magic number.');
    } else {
        // 4. ถ้าไม่ใช่ PDF ในกรณีนี้ให้ถือว่าเป็น Text ทั้งหมด
        determinedMimeType = 'text/plain';
        console.log('File content is not a PDF, assuming text/plain.');
    }
    
    // 5. สร้าง File object ด้วย MIME type ที่ตรวจสอบจากเนื้อหาไฟล์แล้ว
    return new File([blob], defaultFilename, { type: determinedMimeType });
    // --- [END] สิ้นสุดส่วนที่แก้ไข ---
}

async function handleGenerateFromBlueprintWithFiles(blueprintFile, referenceFile = null) {
    if (!blueprintFile) {
        showMessage("ไม่พบไฟล์ Test Blueprint");
        return;
    }

    const loader = document.getElementById('loader');
    const loaderText = document.getElementById('loader-text');

    loader.classList.remove('hidden');
    document.getElementById('quiz-generation-area').classList.remove('hidden');
    document.getElementById('generated-quiz-container').innerHTML = '';

    try {
        loaderText.textContent = 'กำลังอ่านไฟล์ Test Blueprint...';
        const blueprintBase64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(blueprintFile);
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
        });

        const extraParts = [];
        if (referenceFile) {
            loaderText.textContent = 'กำลังอ่านไฟล์อ้างอิง...';
            const refText = await referenceFile.text();
            extraParts.push({ text: `\n\nไฟล์ข้อสอบอ้างอิง:\n${refText}` });
        }

        const promptParts = [
            { text: '...' }, // (Prompt หลักของคุณจะถูกใส่ที่นี่โดย handleApiCall)
            { inlineData: { mimeType: blueprintFile.type, data: blueprintBase64 } },
            ...extraParts
        ];

        // เรียกใช้ตรรกะการสร้างข้อสอบเดิมโดยส่งข้อมูลไฟล์เข้าไป
        await handleGenerateFromBlueprint(promptParts);

    } catch (error) {
        console.error("Error in generating from files:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
        loader.classList.add('hidden');
    }
}

// ▲▲▲ สิ้นสุดส่วนฟังก์ชันใหม่ ▲▲▲

async function handleLiveAnswer(answerIndex, question) {
    // ปิดปุ่มทั้งหมดทันทีหลังตอบ เพื่อป้องกันการส่งซ้ำ
    document.querySelectorAll('.live-answer-btn, #live-submit-short-answer-btn').forEach(b => b.disabled = true);

    const questionType = question.questionType || currentQuizData.quizType;
    let isCorrect = false;
    let userAnswerForDb = answerIndex; // ค่าที่จะบันทึกลง DB

    // ตรวจคำตอบ (ส่วนนี้ยังทำงานเหมือนเดิม)
    if (questionType === 'short_answer') {
        const userAnswer = (answerIndex || '').toString(); 
        isCorrect = await gradeShortAnswer(userAnswer, question);
    }
    else if (questionType === 'multiple_choice') {
        isCorrect = answerIndex === question.correctAnswerIndex;
    } else if (questionType === 'true_false') {
        const correctAnswerBool = question.correctAnswer;
        isCorrect = (answerIndex === 0 && correctAnswerBool) || (answerIndex === 1 && !correctAnswerBool);
    } else if (questionType === 'matching_item') {
        const selectedResponse = question.allResponses[answerIndex];
        isCorrect = selectedResponse === question.correctResponse;
        userAnswerForDb = selectedResponse; // สำหรับ matching ให้เก็บข้อความที่เลือก
    }

    const gameRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
    
    // *** ส่วนที่แก้ไขใหม่ทั้งหมด ***
    // เราจะไม่คำนวณคะแนนที่นี่อีกต่อไป
    // แต่จะส่งข้อมูลคำตอบและ "เวลาที่ส่งจากเซิร์ฟเวอร์" กลับไปแทน
    const updatePayload = {};
    updatePayload[`players.${currentStudentName}.answeredCurrentQuestion`] = true;
    updatePayload[`players.${currentStudentName}.lastAnswerCorrect`] = isCorrect;
    updatePayload[`players.${currentStudentName}.lastAnswerIndex`] = (questionType === 'short_answer' || questionType === 'matching_item') ? null : answerIndex;
    updatePayload[`players.${currentStudentName}.lastAnswerValue`] = userAnswerForDb;
    updatePayload[`players.${currentStudentName}.submittedAt`] = serverTimestamp(); // บันทึกเวลาที่ส่งด้วยเวลาเซิร์ฟเวอร์
    updatePayload[`players.${currentStudentName}.isScored`] = false; // เพิ่ม Flag เพื่อบอกว่า "ยังไม่ได้คิดคะแนน"

    // ส่งข้อมูลกลับไปที่ Firestore
    await updateDoc(gameRef, updatePayload);

    // แสดงหน้าจอ "รอ" เหมือนเดิม
    liveGameView.innerHTML = `<div class="live-game-bg text-white rounded-lg p-8 text-center flex flex-col items-center justify-center h-full">
        <h2 class="text-3xl font-bold">ส่งคำตอบแล้ว!</h2>
        <p class="mt-8">รอผู้เล่นคนอื่นสักครู่...</p>
        <div class="loader mt-4"></div>
    </div>`;
}

function showAdminSummaryView(gameData, question) {
    const players = Object.values(gameData.players || {});
    const questionType = question.questionType || currentQuizData.quizType;
    const options = questionType === 'true_false' ? ['ใช่', 'ไม่ใช่'] : (question.options || question.allResponses || []);

    const namesByAnswer = {};
    const answerCounts = new Array(options.length).fill(0);
    options.forEach((opt, index) => {
        namesByAnswer[index] = [];
    });

    Object.entries(gameData.players || {}).forEach(([name, data]) => {
        if (data.status === 'active' && data.lastAnswerIndex !== undefined) {
            const answerIndex = data.lastAnswerIndex;
            if (namesByAnswer[answerIndex]) {
                namesByAnswer[answerIndex].push(name);
                answerCounts[answerIndex]++;
            }
        }
    });
    
    const maxCount = Math.max(...answerCounts, 1);
    
    const summaryHTML = `
        <div class="live-game-bg text-white rounded-lg p-8 flex flex-col h-full items-center justify-between">
            <h2 class="text-3xl font-bold">${question.stem || question.questionText}</h2>
            
            <div class="w-full max-w-2xl h-64 flex justify-around items-end gap-4">
                ${answerCounts.map((count, index) => {
                    const tooltipText = namesByAnswer[index].length > 0 
                        ? namesByAnswer[index].join(', ') 
                        : 'ไม่มีผู้ตอบตัวเลือกนี้';
                    
                    let isCorrectOption = false;
                    if (questionType === 'multiple_choice') {
                        isCorrectOption = (index === question.correctAnswerIndex);
                    } else if (questionType === 'true_false') {
                        const correctValue = question.correctAnswer;
                        isCorrectOption = (correctValue && index === 0) || (!correctValue && index === 1);
                    } else if (questionType === 'matching_item') {
                        isCorrectOption = (options[index] === question.correctResponse);
                    }

                    const barColor = isCorrectOption ? '#26890c' : '#e21b3c';

                    // --- [นี่คือส่วนของโค้ดที่แก้ไขตำแหน่ง Tooltip] ---
                    return `
                    <div class="w-1/4 h-full flex flex-col justify-end items-center">
                        
                        <span class="text-xl font-bold mb-1">${count}</span>

                        <div class="summary-bar-item w-full rounded-lg text-white p-2 flex flex-col justify-center items-center gap-1 cursor-pointer relative"
                             style="height: 60px; background-color: ${barColor};"
                             data-tooltip-target="tooltip-${index}">
                            
                            <span class="text-xs sm:text-sm font-semibold text-center pointer-events-none">${options[index]}</span>
                            
                            <div id="tooltip-${index}" class="live-summary-tooltip absolute bottom-full mb-2 w-max max-w-xs bg-gray-800 text-white text-sm rounded-lg shadow-lg p-3 z-10">
                                <strong class="block mb-1 border-b border-gray-600 pb-1">ผู้ที่ตอบตัวเลือกนี้:</strong>
                                ${tooltipText}
                            </div>
                        </div>
                    </div>`;
                }).join('')}
            </div>

            <div class="flex items-center gap-4 mt-8">
                <button id="open-scratchpad-btn" class="bg-white/30 hover:bg-white/50 text-white font-bold py-3 px-8 rounded-lg text-xl flex items-center gap-2">
                    <i class="fas fa-pencil-alt"></i> ทดเลข
                </button>
                <button id="show-leaderboard-btn" class="bg-gray-800 hover:bg-black text-white font-bold py-3 px-8 rounded-lg text-2xl">
                    ถัดไป <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        </div>
    `;
    
    liveGameView.innerHTML = summaryHTML;
    if (window.MathJax) MathJax.typesetPromise();

    document.getElementById('show-leaderboard-btn').addEventListener('click', async () => {
        const gameRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
        await updateDoc(gameRef, { questionStatus: 'leaderboard' });
    });
    
    document.getElementById('open-scratchpad-btn').addEventListener('click', () => {
        openScratchpad(question, options);
    });
}

        /**
/**
         * แสดงหน้าจอสรุปผลหลังจบข้อ (สำหรับ Player) - เวอร์ชันอัปเกรด
         * @param {object} gameData - ข้อมูลเกมทั้งหมดจาก Firestore
         * @param {string} playerName - ชื่อของผู้เล่นปัจจุบัน
         */
        function showPlayerSummaryView(gameData, playerName) {
            const players = Object.values(gameData.players || {});
            const myData = gameData.players[playerName];

            // คำนวณอันดับ
            const sortedPlayers = players.filter(p => p.status === 'active').sort((a, b) => b.score - a.score);
            const myRank = sortedPlayers.findIndex(p => p === myData) + 1;
            
            const resultText = myData.lastAnswerCorrect ? 'ถูกต้อง!' : 'ผิด';
            const resultBoxClass = myData.lastAnswerCorrect ? 'bg-green-500' : 'bg-red-500';
            const pointsGained = myData.pointsLastQuestion || 0;
            const gradientBg = "bg-gradient-to-br from-indigo-600 to-purple-700";

            const summaryHTML = `
                <div class="rounded-lg p-8 flex flex-col h-full items-center justify-center text-center text-white ${gradientBg}">
                    <div class="px-8 py-2 rounded-lg ${resultBoxClass}">
                        <p class="text-3xl font-bold">${resultText}</p>
                    </div>
                    <p class="text-2xl mt-4">+${pointsGained} คะแนน</p>
                    
                    <div class="w-full max-w-sm bg-black/20 p-4 rounded-lg mt-12">
                        <p class="text-xl">ตอนนี้คุณอยู่อันดับที่</p>
                        <p class="text-6xl font-bold">${myRank > 0 ? myRank : '-'}</p>
                    </div>

                    <p class="mt-12 text-gray-300">รอผู้ควบคุมไปข้อต่อไป...</p>
                </div>
            `;
            liveGameView.innerHTML = summaryHTML;
        }

function createQuizFromBank() {
    const selectedCheckboxes = document.querySelectorAll('#bank-input-area input[type="checkbox"]:checked');
    if (selectedCheckboxes.length === 0) {
        showMessage("กรุณาเลือกข้อสอบอย่างน้อย 1 ข้อ");
        return;
    }

    const questions = [];
    selectedCheckboxes.forEach(box => {
        questions.push(JSON.parse(box.value));
    });

    const newQuizData = {
        topic: "แบบทดสอบจากคลังส่วนตัว",
        questions: questions
    };

    displayGeneratedQuiz(newQuizData);
}

function showAdminLobbyView(gamePin, quizTopic) {
    showView('live-game'); 

    // --- [START] แก้ไขการแสดงผลชื่อผู้เล่นให้มีปุ่มเตะ ---
    const lobbyHTML = `
        <div class="live-game-bg text-white rounded-lg p-8 text-center flex flex-col items-center justify-center h-full">
            <h2 class="text-2xl font-bold mb-2">เริ่มเกม: ${quizTopic}</h2>
            <p class="text-lg mb-4">ให้นักเรียนเข้าร่วมด้วยรหัสนี้:</p>
            <div class="bg-white text-gray-800 rounded-lg p-4 mb-4">
                <p class="text-6xl font-bold tracking-widest">${gamePin}</p>
            </div>
            <div class="w-full max-w-md bg-white/20 p-4 rounded-lg">
                <h3 class="text-xl font-semibold mb-2">ผู้เล่นที่เข้าร่วม (<span id="player-count">0</span>)</h3>
                <div id="player-list-lobby" class="flex flex-wrap justify-center gap-2">
                    </div>
            </div>
            <button id="start-game-btn" class="mt-6 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-2xl transition-transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>
                <i class="fas fa-play"></i> เริ่มการแข่งขัน
            </button>
        </div>
    `;
    // --- [END] สิ้นสุดการแก้ไข ---

    liveGameView.innerHTML = lobbyHTML;

    document.getElementById('start-game-btn').addEventListener('click', async () => {
        if (!currentQuizData || !currentQuizData.questions || currentQuizData.questions.length === 0) {
            showMessage("เกิดข้อผิดพลาด: ไม่พบข้อมูลคำถามสำหรับเกมนี้");
            return;
        }

        try {
            const gameRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
            await updateDoc(gameRef, {
                status: 'question',
                currentQuestionIndex: 0,
                questionDisplayedAt: serverTimestamp()
            });

            const firstQuestion = currentQuizData.questions[0];
            const totalQuestions = currentQuizData.questions.length;
            showAdminLiveQuestionView(firstQuestion, 0, totalQuestions);

        } catch (error) {
            console.error("Error starting game:", error);
            showMessage("ไม่สามารถเริ่มเกมได้");
        }
    });
}

async function openQuizBankModal() {
  // ดึงข้อมูลแบบทดสอบทั้งหมด (ถ้ายังไม่มี)
  if (allQuizzesGlobal.length === 0) {
    const qs = await getDocs(collection(db, `artifacts/${appId}/public/data/quizzes`));
    allQuizzesGlobal = qs.docs.map(d => ({ id: d.id, ...d.data() }));
  }
  // แสดงรายการแบบทดสอบทั้งหมดใน Modal
  renderQuizBankList('');
  document.getElementById('quiz-bank-modal').classList.remove('hidden');
}

// --- วางทับฟังก์ชัน renderQuizBankList เดิมทั้งหมดด้วยโค้ดนี้ ---
function renderQuizBankList(filterText = '', selectionMode = false) {
  const listEl = document.getElementById('bank-quiz-list');
  const term = filterText.toLowerCase().trim();

  const rows = allQuizzesGlobal
    .map(q => ({
      ...q,
      projectName: (allProjects.find(p => p.id === q.projectId)?.projectName) || 'N/A'
    }))
    .filter(q =>
      (q.topic || '').toLowerCase().includes(term) ||
      (q.projectName || '').toLowerCase().includes(term) ||
      (q.id.toString().includes(term))
    );
	
	document.getElementById('quiz-bank-count').textContent = `(${rows.length} ชุด)`;

 listEl.innerHTML = rows.length
  ? rows.map(q => {
      // ซ่อนปุ่มเครื่องมือทั้งหมดเมื่ออยู่ใน selectionMode
      const actionButtonsHTML = !selectionMode ? `
        <div class="flex items-center gap-px ml-4 shrink-0">
            <button data-id="${q.id}" title="ย้ายไปโปรเจคอื่น" class="quiz-bank-move-btn text-purple-600 hover:text-purple-800 text-xl p-2 rounded-full hover:bg-gray-200"><i class="fas fa-project-diagram pointer-events-none"></i></button>
            <button data-id="${q.id}" title="ตั้งค่า" class="quiz-bank-settings-btn text-cyan-600 hover:text-cyan-800 text-xl p-2 rounded-full hover:bg-gray-200"><i class="fas fa-cog pointer-events-none"></i></button>
            <button data-id="${q.id}" title="สร้างแบบทดสอบคู่ขนาน" class="quiz-bank-parallel-btn text-teal-600 hover:text-teal-800 text-xl p-2 rounded-full hover:bg-gray-200"><i class="fas fa-clone pointer-events-none"></i></button>
            <button data-id="${q.id}" title="โหมดนำเสนอ" class="quiz-bank-present-btn text-indigo-600 hover:text-indigo-800 text-xl p-2 rounded-full hover:bg-gray-200"><i class="fas fa-chalkboard-teacher pointer-events-none"></i></button>
            <button data-id="${q.id}" title="ทดลองทำแบบทดสอบ" class="quiz-bank-try-btn text-purple-600 hover:text-purple-800 text-xl p-2 rounded-full hover:bg-gray-200"><i class="fas fa-vial pointer-events-none"></i></button>
            <button data-id="${q.id}" data-topic="${q.topic}" title="ลบ" class="quiz-bank-delete-btn text-red-600 hover:text-red-800 text-xl p-2 rounded-full hover:bg-gray-200"><i class="fas fa-trash-alt pointer-events-none"></i></button>
        </div>
      ` : '';

      return `
      <div class="w-full text-left p-3 border-b hover:bg-gray-100 flex items-center justify-between">
        <div data-id="${q.id}" class="quiz-bank-item flex-grow cursor-pointer">
          <p class="font-semibold text-indigo-700">${q.topic || '(ไม่มีชื่อ)'}
            <span class="text-sm font-normal text-gray-500">(${q.questions?.length || 0} ข้อ)</span>
          </p>
          <p class="text-xs text-gray-600">โปรเจค: ${q.projectName}</p>
          <p class="text-xs text-gray-600 font-mono mt-1">Quiz ID: ${q.id}</p>
        </div>
        ${actionButtonsHTML}
      </div>`;
    }).join('')
  : `<div class="p-4 text-center text-gray-500">ไม่พบแบบทดสอบ</div>`;

  // เพิ่ม Event Listener เฉพาะเมื่อไม่ได้อยู่ใน selectionMode
  if (!selectionMode) {
      listEl.querySelectorAll('.quiz-bank-item').forEach(btn => {
        btn.addEventListener('click', () => {
          const quizId = btn.dataset.id;
          document.getElementById('quiz-bank-modal').classList.add('hidden'); // ซ่อน Modal
          showQuizDetailView(quizId); // เรียกฟังก์ชันเดิมเพื่อไปหน้าวิเคราะห์ผล
        });
      });
      
    // Event Listener สำหรับปุ่ม "ทดลองทำ"
    listEl.querySelectorAll('.quiz-bank-try-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
            event.stopPropagation();
            const quizId = btn.dataset.id;
            const quizData = allQuizzesGlobal.find(q => q.id === quizId);
            if (quizData) {
                currentQuizData = quizData;
                document.getElementById('quiz-bank-modal').classList.add('hidden');
                startAdminTest();
            } else { showMessage('ไม่พบข้อมูลแบบทดสอบ'); }
        });
    });

    // Event Listener สำหรับปุ่ม "สร้างคู่ขนาน"
    listEl.querySelectorAll('.quiz-bank-parallel-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
            event.stopPropagation();
            const quizId = btn.dataset.id;
            const quizData = allQuizzesGlobal.find(q => q.id === quizId);
            if (quizData) {
                document.getElementById('quiz-bank-modal').classList.add('hidden');
                handleGenerateParallelFromBank(quizData);
            } else { showMessage('ไม่พบข้อมูลแบบทดสอบ'); }
        });
    });

    // Event Listener สำหรับปุ่ม "นำเสนอ"
    listEl.querySelectorAll('.quiz-bank-present-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
            event.stopPropagation();
            const quizId = btn.dataset.id;
            const quizData = allQuizzesGlobal.find(q => q.id === quizId);
            if (quizData) {
                document.getElementById('quiz-bank-modal').classList.add('hidden');
                startPresentation(quizData);
            } else { showMessage('ไม่พบข้อมูลแบบทดสอบ'); }
        });
    });

    // Event Listener สำหรับปุ่ม "ย้าย"
    listEl.querySelectorAll('.quiz-bank-move-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
            event.stopPropagation();
            const quizId = btn.dataset.id;
            document.getElementById('quiz-bank-modal').classList.add('hidden');
            handleMoveQuiz(quizId); 
        });
    });
	
	// Event Listener สำหรับปุ่ม "ตั้งค่า"
    listEl.querySelectorAll('.quiz-bank-settings-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
            event.stopPropagation();
            const quizId = btn.dataset.id;
            document.getElementById('quiz-bank-modal').classList.add('hidden');
            handleQuizSettings(quizId);
        });
    });

    // Event Listener สำหรับปุ่ม "ลบ"
    listEl.querySelectorAll('.quiz-bank-delete-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
            event.stopPropagation();
            const quizId = btn.dataset.id;
            const topic = btn.dataset.topic;
            showConfirmation(
                `คุณแน่ใจหรือไม่ว่าต้องการลบแบบทดสอบ "${topic}"? การกระทำนี้ไม่สามารถย้อนกลับได้`,
                () => handleDeleteQuiz(quizId)
            );
        });
    });
  }
}

// ในไฟล์ 50.html
// --- นำโค้ดนี้ไปวางทับฟังก์ชัน handleCompareResults เดิมทั้งหมด ---

async function handleCompareResults(postTestId, preTestId) {
    const modal = document.getElementById('comparison-modal');
    const overallContentEl = document.getElementById('comparison-overall-content');
    const individualContentEl = document.getElementById('comparison-individual-content');
    
    document.getElementById('comparison-overall-tab').classList.add('active');
    document.getElementById('comparison-individual-tab').classList.remove('active');
    overallContentEl.classList.remove('hidden');
    individualContentEl.classList.add('hidden');
    
    overallContentEl.innerHTML = '<div class="loader mx-auto"></div>';
    individualContentEl.innerHTML = '';
    modal.classList.remove('hidden');

    try {
        const postTestRef = doc(db, `artifacts/${appId}/public/data/quizzes`, postTestId);
        const postTestSnap = await getDoc(postTestRef);
        if (!postTestSnap.exists()) throw new Error("ไม่พบข้อมูลข้อสอบหลังเรียน");
        const postTestData = postTestSnap.data();
        const totalQuestions = postTestData.questions.length;

        const preTestSubmissionsRef = collection(db, `artifacts/${appId}/public/data/quizzes/${preTestId}/submissions`);
        const postTestSubmissionsRef = collection(db, `artifacts/${appId}/public/data/quizzes/${postTestId}/submissions`);
        const [preTestSubmissionsSnap, postTestSubmissionsSnap] = await Promise.all([getDocs(preTestSubmissionsRef), getDocs(postTestSubmissionsRef)]);
        const preTestSubmissions = preTestSubmissionsSnap.docs.map(doc => doc.data());
        const postTestSubmissions = postTestSubmissionsSnap.docs.map(doc => doc.data());
        
        const preTestScores = preTestSubmissions.map(s => s.latestScore);
        const postTestScores = postTestSubmissions.map(s => s.latestScore);
        
        // --- START: ส่วนการคำนวณ Z-Score และ T-Score ---
        const preTestStats = calculateMeanAndStdDev(preTestScores);
        const postTestStats = calculateMeanAndStdDev(postTestScores);
        // --- END: ส่วนการคำนวณ ---

        const preTestAvg = preTestStats.mean;
        const postTestAvg = postTestStats.mean;
        const improvement = postTestAvg - preTestAvg;

        let overallHtml = `
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div class="p-4 bg-blue-100 rounded-lg text-center"><p class="text-sm font-semibold text-blue-800">คะแนนเฉลี่ย (ก่อนเรียน)</p><p class="text-3xl font-bold text-blue-900">${preTestAvg.toFixed(2)}</p></div>
                <div class="p-4 bg-green-100 rounded-lg text-center"><p class="text-sm font-semibold text-green-800">คะแนนเฉลี่ย (หลังเรียน)</p><p class="text-3xl font-bold text-green-900">${postTestAvg.toFixed(2)}</p></div>
                <div class="p-4 ${improvement >= 0 ? 'bg-emerald-100' : 'bg-red-100'} rounded-lg text-center"><p class="text-sm font-semibold ${improvement >= 0 ? 'text-emerald-800' : 'text-red-800'}">พัฒนาการเฉลี่ย</p><p class="text-3xl font-bold ${improvement >= 0 ? 'text-emerald-900' : 'text-red-900'}">${improvement >= 0 ? '+' : ''}${improvement.toFixed(2)}</p></div>
            </div>
            <div><h4 class="font-semibold mb-2 text-center">กราฟเปรียบเทียบคะแนนเฉลี่ย</h4><canvas id="comparison-chart"></canvas></div>`;
        overallContentEl.innerHTML = overallHtml;
        
        const ctx = document.getElementById('comparison-chart').getContext('2d');
        if (chartInstances.comparison) chartInstances.comparison.destroy();
        chartInstances.comparison = new Chart(ctx, {
            type: 'bar',
            data: { labels: ['คะแนนเฉลี่ย'], datasets: [{ label: 'ก่อนเรียน', data: [preTestAvg], backgroundColor: 'rgba(59, 130, 246, 0.7)' },{ label: 'หลังเรียน', data: [postTestAvg], backgroundColor: 'rgba(16, 185, 129, 0.7)' }] },
            options: { scales: { y: { beginAtZero: true, suggestedMax: totalQuestions } } }
        });

        const students = currentProjectData.students || [];
        const comparisonData = students.map(name => {
            const preSub = preTestSubmissions.find(s => s.studentName === name);
            const postSub = postTestSubmissions.find(s => s.studentName === name);
            const preScore = preSub ? preSub.latestScore : null;
            const postScore = postSub ? postSub.latestScore : null;
            const gain = (preScore !== null && postScore !== null) ? postScore - preScore : null;

            // --- START: ส่วนการคำนวณ T-Score รายบุคคล ---
            const preZ = preScore !== null ? calculateZScore(preScore, preTestStats.mean, preTestStats.stdDev) : null;
            const postZ = postScore !== null ? calculateZScore(postScore, postTestStats.mean, postTestStats.stdDev) : null;
            const preTScore = preZ !== null ? calculateTScore(preZ) : null;
            const postTScore = postZ !== null ? calculateTScore(postZ) : null;
            const tGain = (preTScore !== null && postTScore !== null) ? postTScore - preTScore : null;
            // --- END: ส่วนการคำนวณ T-Score ---

            return { name, preScore, postScore, gain, preTScore, postTScore, tGain };
        });

        renderIndividualComparisonTable(comparisonData, individualContentEl);

    } catch (error) {
        console.error("Error comparing results:", error);
        overallContentEl.innerHTML = '<p class="text-red-500 text-center">เกิดข้อผิดพลาดในการโหลดข้อมูลเปรียบเทียบ</p>';
    }
}

// =====================================================================
// === [ใหม่] ฟังก์ชันทั้งหมดสำหรับ Blueprint Project Manager ===
// =====================================================================

/**
 * [1] บันทึกข้อมูลหัวข้อจาก Blueprint ลง Firestore เป็นโปรเจคใหม่
 */
async function saveBlueprintProject() {
    if (!extractedBlueprintData || !extractedBlueprintData.curriculum) {
        showMessage("ไม่พบข้อมูลหัวข้อที่จะบันทึก");
        return;
    }

    const projectName = prompt("กรุณาตั้งชื่อโปรเจคสำหรับ Blueprint นี้:", "Blueprint O-NET ป.6");
    if (!projectName || projectName.trim() === '') {
        return; // ผู้ใช้ยกเลิก
    }

    // แปลงโครงสร้าง Array เป็น Map เพื่อให้ง่ายต่อการแก้ไข/ลบ
    const topicsMap = {};
    extractedBlueprintData.curriculum.forEach(sara => {
        sara.mainTopics.forEach(mainTopic => {
            mainTopic.subTopics.forEach(subTopic => {
                const topicId = 'topic_' + Date.now() + Math.random().toString(36).substr(2, 9);
                topicsMap[topicId] = {
                    sara: sara.sara,
                    mainTopic: mainTopic.topicName,
                    subTopic: subTopic,
                    status: "not_generated", // สถานะเริ่มต้น
                    lessonContent: null
                };
            });
        });
    });

try {
    const projectsRef = collection(db, `artifacts/${appId}/public/data/blueprintProjects`);
    await addDoc(projectsRef, {
        projectName: projectName.trim(),
        gradeLevel: extractedBlueprintData.gradeLevel,
        topics: topicsMap, 
        createdAt: serverTimestamp()
    });
        showMessage(`บันทึกโปรเจค "${projectName.trim()}" สำเร็จ!`);
        document.getElementById('save-blueprint-as-project-btn').classList.add('hidden'); // ซ่อนปุ่มหลังบันทึก
    } catch (error) {
        console.error("Error saving blueprint project:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึกโปรเจค");
    }
}

/**
 * [2] เปิด Modal และแสดงรายการโปรเจคที่บันทึกไว้
 */
async function showBlueprintProjects() {
    const modal = document.getElementById('blueprint-projects-modal');
    const listEl = document.getElementById('blueprint-project-list');
    listEl.innerHTML = '<p class="p-4 text-center text-gray-500">กำลังโหลด...</p>';
    modal.classList.remove('hidden');

try {
    const projectsRef = collection(db, `artifacts/${appId}/public/data/blueprintProjects`);
    // vvv แก้ไขบรรทัดนี้ vvv
    const snapshot = await getDocs(projectsRef); 

        if (snapshot.empty) {
            listEl.innerHTML = '<p class="p-4 text-center text-gray-500">ยังไม่มีโปรเจคที่บันทึกไว้</p>';
            return;
        }

        const projects = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        projects.sort((a, b) => a.projectName.localeCompare(b.projectName, 'th'));

        listEl.innerHTML = projects.map(p => `
            <div class="p-3 border-b hover:bg-gray-100 flex items-center justify-between">
                <div>
                    <p class="font-semibold text-teal-700">${p.projectName}</p>
                    <p class="text-xs text-gray-500">${p.gradeLevel} | ${Object.keys(p.topics).length} หัวข้อ</p>
                </div>
                <div>
                    <button data-id="${p.id}" class="open-bp-project-btn bg-blue-100 text-blue-700 text-sm py-1 px-3 rounded-md hover:bg-blue-200">เปิด</button>
                    <button data-id="${p.id}" class="delete-bp-project-btn bg-red-100 text-red-700 text-sm py-1 px-3 rounded-md hover:bg-red-200 ml-2">ลบ</button>
                </div>
            </div>
        `).join('');

    } catch (error) {
        console.error("Error loading blueprint projects:", error);
        listEl.innerHTML = '<p class="p-4 text-center text-red-500">ไม่สามารถโหลดรายการได้</p>';
    }
}

/**
 * [3] แสดงหน้าจอจัดการหัวข้อของโปรเจคที่เลือก
 */
async function displayBlueprintProjectManager(projectId) {
    currentBlueprintProjectId = projectId;
    document.getElementById('blueprint-projects-modal').classList.add('hidden'); // ซ่อน Modal
    showView('admin-dashboard'); // รีเซ็ต view ก่อน
    projectDashboardView.classList.add('hidden'); // ซ่อน dashboard หลัก

    const managerView = document.getElementById('blueprint-project-manager-view');
    managerView.classList.remove('hidden');
    document.getElementById('bp-topic-list-container').innerHTML = '<div class="loader mx-auto"></div>';

    try {
        const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, projectId);
        const docSnap = await getDoc(projectRef);

        if (!docSnap.exists()) {
            throw new Error("ไม่พบโปรเจค");
        }
        const projectData = { id: docSnap.id, ...docSnap.data() };
        document.getElementById('bp-project-title').textContent = projectData.projectName;
		document.getElementById('bp-reference-file-url').value = projectData.referenceFileUrl || '';
        renderBlueprintTopicManager(projectData);
    } catch (error) {
        console.error("Error displaying blueprint project:", error);
        showMessage(error.message);
        showView('admin-dashboard'); // กลับหน้าหลักถ้า Error
    }
}

// ▼▼▼ วางทับฟังก์ชัน renderBlueprintTopicManager เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
function renderBlueprintTopicManager(projectData) {
    const container = document.getElementById('bp-topic-list-container');
    const topicsMap = projectData.topics || {};

    if (Object.keys(topicsMap).length === 0) {
        container.innerHTML = '<p class="text-center text-gray-500">ไม่มีหัวข้อในโปรเจคนี้</p>';
        return;
    }

    // --- [ START: ส่วนแก้ไขที่สำคัญที่สุด ] ---
    // 1. แปลง Object เป็น Array และจัดเรียงตาม 'order' ที่บันทึกไว้
    const sortedTopicsArray = Object.entries(topicsMap)
        .map(([id, data]) => ({ id, ...data }))
        .sort((a, b) => (a.order ?? Infinity) - (b.order ?? Infinity));

    // 2. จัดกลุ่มข้อมูลใหม่จาก Array ที่เรียงลำดับแล้ว
    const groupedTopics = {};
    sortedTopicsArray.forEach(topic => {
        const { sara, mainTopic } = topic;
        if (!groupedTopics[sara]) {
            groupedTopics[sara] = {};
        }
        if (!groupedTopics[sara][mainTopic]) {
            groupedTopics[sara][mainTopic] = [];
        }
        groupedTopics[sara][mainTopic].push(topic);
    });
    // --- [ END: สิ้นสุดการแก้ไข ] ---

    let html = '';
    // 3. วนลูปแสดงผลโดย "ไม่ใช้ .sort()" อีกต่อไป เพื่อรักษลำดับเดิม
    for (const sara in groupedTopics) {
        html += `<div class="p-4 border rounded-lg bg-gray-50 shadow-sm mb-4"><h4 class="font-bold text-xl text-blue-800 mb-3">${sara}</h4>`;
        
        for (const mainTopic in groupedTopics[sara]) {
            html += `<div class="ml-4 mb-3"><h5 class="font-semibold text-lg text-gray-700 mb-2">${mainTopic}</h5><div class="space-y-1 pl-4 border-l-2 border-gray-200">`;
            
            // ข้อมูลในนี้จะเรียงลำดับถูกต้องอยู่แล้ว
            groupedTopics[sara][mainTopic].forEach(topic => {
                const id = topic.id;
                const linkedQuizzes = topic.linkedQuizIds || [];
                const isLinked = linkedQuizzes.length > 0;
                const isLessonGenerated = topic.status === 'generated';

                let statusBadge = '';
                if (isLinked) {
                    statusBadge = `<span class="text-xs font-semibold px-2 py-1 rounded-full bg-cyan-200 text-cyan-800">เชื่อมโยงแล้ว (${linkedQuizzes.length} ชุด)</span>`;
                } else {
                    statusBadge = `<span class="text-xs font-semibold px-2 py-1 rounded-full ${isLessonGenerated ? 'bg-green-200 text-green-800' : 'bg-gray-200 text-gray-700'}">${isLessonGenerated ? 'สร้างแล้ว' : 'ยังไม่สร้าง'}</span>`;
                }

                const lessonDependentBtnDisabled = !isLessonGenerated ? 'disabled bg-gray-400 cursor-not-allowed' : '';
                const lessonDependentBtnTitle = !isLessonGenerated ? 'กรุณาสร้างบทเรียนก่อน' : '';

                let lessonButtonsHTML = isLessonGenerated
                    ? `<button class="view-bp-lesson-btn text-white bg-blue-600 hover:opacity-80 text-xs font-semibold py-1 px-3 rounded-md">ดูบทเรียน</button>
                       <button class="bp-generate-lesson-btn text-white bg-purple-600 hover:opacity-80 text-xs font-semibold py-1 px-3 rounded-md">สร้างใหม่</button>`
                    : `<button class="bp-generate-lesson-btn text-white bg-teal-600 hover:opacity-80 text-xs font-semibold py-1 px-3 rounded-md">สร้างบทเรียน</button>`;

                html += `
                    <div class="p-2 border-b flex items-center justify-between gap-2 hover:bg-white" data-topic-id="${id}">
                        <div class="flex-grow">
                            <p class="font-semibold" data-field="subTopic">${topic.subTopic}</p>
                        </div>
                        <div class="flex items-center gap-2 shrink-0">
                            ${statusBadge}
                            <button class="bp-open-topic-bank-btn text-purple-700 bg-purple-100 hover:bg-purple-200 text-xs font-semibold py-1 px-3 rounded-md" title="เปิดคลังแบบทดสอบประจำหัวข้อ"><i class="fas fa-book-open"></i> คลัง</button>
                            <button class="bp-create-topic-quiz-btn text-indigo-700 bg-indigo-100 hover:bg-indigo-200 text-xs font-semibold py-1 px-3 rounded-md" title="สร้างแบบทดสอบจากชื่อหัวข้อ">สร้าง (หัวข้อ)</button>
                            <button class="bp-create-content-quiz-btn text-indigo-700 bg-indigo-100 hover:bg-indigo-200 text-xs font-semibold py-1 px-3 rounded-md ${lessonDependentBtnDisabled}" title="สร้างแบบทดสอบทั่วไปจากเนื้อหาบทเรียน ${lessonDependentBtnTitle}">สร้าง (เนื้อหา)</button>
                            
                            <button class="bp-create-onet-quiz-btn text-white bg-indigo-600 hover:bg-indigo-700 text-xs font-semibold py-1 px-3 rounded-md" title="สร้างแบบทดสอบประยุกต์ (O-NET) จากชื่อหัวข้อ">สร้าง (O-NET)</button>
                            
                            ${lessonButtonsHTML}
                            <button class="bp-edit-topic-btn text-gray-500 hover:text-blue-600" title="แก้ไข"><i class="fas fa-edit"></i></button>
                            <button class="bp-delete-topic-btn text-gray-500 hover:text-red-600" title="ลบ"><i class="fas fa-trash-alt"></i></button>
                        </div>
                    </div>
                `;
            });
            html += `</div></div>`;
        }
        html += `</div>`;
    }
    container.innerHTML = html;
}

async function handleDeepDeleteBlueprintProject(projectId) {
    // 1. ดึงข้อมูลโปรเจคเพื่อหาชื่อมายืนยัน
    const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, projectId);
    const projectSnap = await getDoc(projectRef);
    if (!projectSnap.exists()) {
        showMessage("ไม่พบโปรเจคที่ต้องการลบ");
        return;
    }
    const projectName = projectSnap.data().projectName;

    // 2. แสดงหน้าต่างยืนยันที่ชัดเจนและอันตราย
    showConfirmation(
        `คุณแน่ใจ 100% หรือไม่ว่าต้องการลบโปรเจค "${projectName}"? การกระทำนี้จะลบ "บทเรียนทั้งหมด" และ "แบบทดสอบที่เชื่อมโยงอยู่ทั้งหมด" อย่างถาวร ไม่สามารถกู้คืนได้!`,
        async () => {
            showMessage("กำลังลบโปรเจคและข้อมูลที่เกี่ยวข้องทั้งหมด...");
            
            try {
                const batch = writeBatch(db);
                const projectData = projectSnap.data();
                const topics = projectData.topics || {};

                // 3. รวบรวม ID ของบทเรียนทั้งหมดเพื่อสั่งลบ
                for (const topicId in topics) {
                    const lessonRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects/${projectId}/lessons`, topicId);
                    batch.delete(lessonRef);
                }

                // 4. รวบรวม ID ของแบบทดสอบที่เชื่อมโยงทั้งหมด (ใช้ Set เพื่อป้องกันการลบซ้ำ)
                const allLinkedQuizIds = new Set();
                for (const topicId in topics) {
                    if (topics[topicId].linkedQuizIds) {
                        topics[topicId].linkedQuizIds.forEach(id => allLinkedQuizIds.add(id));
                    }
                }

                // 5. สั่งลบแบบทดสอบแต่ละชุด (ต้องทำนอก batch เพราะ handleDeleteQuiz มีกระบวนการซับซ้อนของตัวเอง)
                for (const quizId of allLinkedQuizIds) {
                    // เรียกใช้ฟังก์ชันลบแบบทดสอบเดิม แต่ไม่ต้องแสดงข้อความทุกครั้ง
                    await handleDeleteQuiz(quizId, false); 
                }

                // 6. สั่งลบตัวโปรเจค Blueprint เอง
                batch.delete(projectRef);

                // 7. ยืนยันการลบทั้งหมดในครั้งเดียว
                await batch.commit();

                showMessage(`ลบโปรเจค "${projectName}" และข้อมูลที่เชื่อมโยงทั้งหมดสำเร็จ!`);
                showBlueprintProjects(); // รีเฟรชรายการโปรเจคใน Modal

            } catch (error) {
                console.error("Error during deep delete:", error);
                showMessage("เกิดข้อผิดพลาดร้ายแรงระหว่างการลบข้อมูล");
            }
        }
    );
}

async function openTopicQuizBank(topicId) {
    const modal = document.getElementById('topic-quiz-bank-modal');
    const listEl = document.getElementById('topic-bank-list');
    const clearAllBtn = document.getElementById('clear-all-links-btn'); // [แก้ไข] ดึงปุ่มใหม่
    
    try {
        await ensureGlobalQuizzesLoaded();

        const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
        const projectSnap = await getDoc(projectRef);
        if (!projectSnap.exists()) return;
        const projectData = projectSnap.data();
        const topicData = projectData.topics[topicId];

        document.getElementById('topic-bank-subtopic-name').textContent = topicData.subTopic;
        
        const linkedQuizIds = topicData.linkedQuizIds || [];

        // [แก้ไข] ควบคุมการแสดงผลของปุ่ม "ล้างทั้งหมด"
        clearAllBtn.classList.toggle('hidden', linkedQuizIds.length === 0);
        clearAllBtn.onclick = () => handleClearAllLinksForTopic(topicId);

        if (linkedQuizIds.length === 0) {
            listEl.innerHTML = '<p class="text-center text-gray-500 p-8">คลังนี้ยังว่างอยู่<br>คลิก "เลือกจากคลังรวม" เพื่อเพิ่มแบบทดสอบ</p>';
        } else {
            const linkedQuizzes = allQuizzesGlobal.filter(q => linkedQuizIds.includes(q.id));
            listEl.innerHTML = linkedQuizzes.map(q => `
                <div class="p-3 border-b flex items-center justify-between gap-2 hover:bg-gray-50">
                    <div data-quiz-id="${q.id}" class="bp-view-analysis-btn flex-grow cursor-pointer">
                        <p class="font-semibold pointer-events-none">${q.topic}</p>
                        <p class="text-xs text-gray-500 font-mono pointer-events-none">ID: ${q.id} | ${q.questions.length} ข้อ</p>
                    </div>
                    <div class="flex items-center gap-1 shrink-0">
                        <button data-quiz-id="${q.id}" class="bp-present-btn text-purple-800 bg-purple-100 hover:bg-purple-200 text-xs font-semibold py-1 px-3 rounded-md" title="นำเสนอ"><i class="fas fa-chalkboard-teacher"></i></button>
<button data-quiz-id="${q.id}" class="bp-try-btn text-teal-800 bg-teal-100 hover:bg-teal-200 text-xs font-semibold py-1 px-3 rounded-md" title="ทดลอง"><i class="fas fa-vial"></i></button>
<button data-quiz-id="${q.id}" class="bp-live-btn text-orange-800 bg-orange-100 hover:bg-orange-200 text-xs font-semibold py-1 px-3 rounded-md" title="แข่งขันสด"><i class="fas fa-flag-checkered"></i></button>

<button data-quiz-id="${q.id}" data-mode="sync" class="bp-game-btn text-white bg-indigo-600 hover:bg-indigo-700 text-xs font-semibold py-1 px-3 rounded-md" title="Sync Mode">
    <i class="fas fa-bolt"></i> Sync
</button>

<button data-topic-id="${topicId}" data-quiz-id="${q.id}" class="bp-unlink-quiz-btn text-red-800 bg-red-100 hover:bg-red-200 text-xs font-semibold py-1 px-3 rounded-md" title="นำออกจากคลังนี้"><i class="fas fa-trash-alt"></i></button>
                    </div>
                </div>
            `).join('');
        }

        document.getElementById('add-from-global-bank-btn').onclick = () => {
            openQuizSelectorForBlueprint(topicId);
        };
        
        document.getElementById('close-topic-bank-btn').onclick = () => modal.classList.add('hidden');
        modal.classList.remove('hidden');

    } catch (error) {
        showMessage(error.message);
    }
}

// --- วางทับฟังก์ชัน openQuizSelectorForBlueprint เดิมทั้งหมดด้วยโค้ดนี้ ---
async function openQuizSelectorForBlueprint(topicId) {
    const globalBankModal = document.getElementById('quiz-bank-modal');
    const topicBankModal = document.getElementById('topic-quiz-bank-modal');
    
    // [แก้ไข] 1. ซ่อนหน้าต่าง "คลังประจำหัวข้อ" ก่อนเสมอ
    topicBankModal.classList.add('hidden');

    document.getElementById('confirm-link-quiz-btn')?.remove();

    const confirmBtn = document.createElement('button');
    confirmBtn.id = 'confirm-link-quiz-btn';
    confirmBtn.className = 'bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold hover:bg-purple-700 disabled:bg-gray-400';
    confirmBtn.textContent = 'เพิ่มรายการที่เลือก';
    confirmBtn.disabled = true;

    try {
        await ensureGlobalQuizzesLoaded();

        globalBankModal.classList.remove('hidden');
        renderQuizBankListForMultiSelect('');
        
        document.getElementById('bulk-quiz-settings-btn').style.display = 'none';
        globalBankModal.querySelector('.flex.justify-between.items-center').appendChild(confirmBtn);

        // [แก้ไข] 2. สร้างฟังก์ชัน cleanup ใหม่ให้กลับมาเปิดหน้าต่างเดิม
        const cleanup = (shouldReopenTopicBank = false) => {
            globalBankModal.classList.add('hidden');
            document.getElementById('bulk-quiz-settings-btn').style.display = 'flex';
            confirmBtn.remove();
            
            // ถ้าทำงานเสร็จ (เช่น กดยกเลิก) ให้กลับมาเปิดหน้า "คลังประจำหัวข้อ" อีกครั้ง
            if (shouldReopenTopicBank) {
                openTopicQuizBank(topicId);
            }
        };

        confirmBtn.onclick = async () => {
            const selectedIds = Array.from(document.querySelectorAll('.quiz-bank-checkbox:checked')).map(cb => cb.value);
            if (selectedIds.length === 0) return;
            try {
                const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
                const projectData = (await getDoc(projectRef)).data();
                const currentLinkedIds = projectData.topics[topicId].linkedQuizIds || [];
                const newIds = [...new Set([...currentLinkedIds, ...selectedIds])];
                
                await updateDoc(projectRef, {
                    [`topics.${topicId}.linkedQuizIds`]: newIds
                });
                showMessage(`เพิ่ม ${selectedIds.length} แบบทดสอบลงในคลังสำเร็จ!`);
                cleanup(true); // สั่งให้ cleanup และกลับไปเปิดหน้าต่างเดิม
                displayBlueprintProjectManager(currentBlueprintProjectId);
            } catch (error) { console.error("Error linking quizzes:", error); }
        };
        
        document.getElementById('cancel-quiz-bank-btn').onclick = () => cleanup(true); // กดยกเลิก ให้ cleanup และกลับไปเปิดหน้าต่างเดิม

    } catch (error) {
        showMessage(error.message);
        // หากเกิด Error ให้กลับไปเปิดหน้าต่างเดิมด้วย
        topicBankModal.classList.remove('hidden');
    }
}


function handleClearLinkedQuiz(topicId) {
    showConfirmation("คุณต้องการยกเลิกการเชื่อมโยงแบบทดสอบนี้ใช่หรือไม่?", async () => {
        try {
            const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
            await updateDoc(projectRef, {
                [`topics.${topicId}.linkedQuizId`]: deleteField() // ใช้ deleteField() เพื่อลบ key ออก
            });
            showMessage("ยกเลิกการเชื่อมโยงสำเร็จ");
            displayBlueprintProjectManager(currentBlueprintProjectId); // รีเฟรชหน้าจอ
        } catch (error) {
            console.error("Error clearing linked quiz:", error);
            showMessage("เกิดข้อผิดพลาด");
        }
    });
}

async function addTopicToProject() {
    const newTopicName = prompt("กรุณาป้อนชื่อหัวข้อย่อยใหม่:");
    if (!newTopicName || newTopicName.trim() === '') return;

    const newSara = prompt("อยู่ในสาระการเรียนรู้ใด:", "สาระที่ 1");
    const newMainTopic = prompt("อยู่ในหัวข้อหลักใด:", "หัวข้อหลักใหม่");

    const newTopicId = 'topic_' + Date.now() + Math.random().toString(36).substr(2, 9);
    const newTopicData = {
        sara: newSara,
        mainTopic: newMainTopic,
        subTopic: newTopicName.trim(),
        status: "not_generated",
        lessonContent: null
    };

    try {
        const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
        await updateDoc(projectRef, {
            [`topics.${newTopicId}`]: newTopicData
        });
        displayBlueprintProjectManager(currentBlueprintProjectId); // Refresh
    } catch (error) {
        console.error("Error adding topic:", error);
        showMessage("เกิดข้อผิดพลาดในการเพิ่มหัวข้อ");
    }
}

/**
 * [6] CRUD: แก้ไขชื่อหัวข้อ
 */
async function editTopicInProject(topicId) {
    const topicDiv = document.querySelector(`[data-topic-id="${topicId}"]`);
    const subTopicP = topicDiv.querySelector('[data-field="subTopic"]');
    const currentName = subTopicP.textContent;

    const newName = prompt("แก้ไขชื่อหัวข้อย่อย:", currentName);
    if (!newName || newName.trim() === '' || newName.trim() === currentName) return;

    try {
        const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
        await updateDoc(projectRef, {
            [`topics.${topicId}.subTopic`]: newName.trim()
        });
        subTopicP.textContent = newName.trim(); // อัปเดต UI ทันที
        showMessage("แก้ไขหัวข้อสำเร็จ");
    } catch (error) {
        console.error("Error editing topic:", error);
        showMessage("เกิดข้อผิดพลาดในการแก้ไข");
    }
}

/**
 * [7] CRUD: ลบหัวข้อออกจากโปรเจค
 */
async function deleteTopicFromProject(topicId) {
    if (!confirm("คุณแน่ใจหรือไม่ว่าต้องการลบหัวข้อนี้?")) return;

    try {
        const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
        await updateDoc(projectRef, {
            [`topics.${topicId}`]: deleteField() // ใช้ deleteField() เพื่อลบ key ออกจาก map
        });
        document.querySelector(`[data-topic-id="${topicId}"]`).remove(); // ลบออกจาก UI
        showMessage("ลบหัวข้อสำเร็จ");
    } catch (error) {
        console.error("Error deleting topic:", error);
        showMessage("เกิดข้อผิดพลาดในการลบ");
    }
}

// ▼▼▼ วางทับฟังก์ชัน generateAndSaveLessonForBlueprint เดิมทั้งหมด ▼▼▼
async function generateAndSaveLessonForBlueprint(topicId, topicName, gradeLevel) {
    handleGenerateAndShowLesson(topicName, gradeLevel);

    const checkInterval = setInterval(async () => {
        const lessonModal = document.getElementById('lesson-view-modal');
        const isModalHidden = lessonModal.classList.contains('hidden');

        if (isModalHidden) {
            clearInterval(checkInterval);

if (currentApplicationData && currentApplicationData.length > 0) {
    const lessonContent = {
        point: document.getElementById('pointContent').innerHTML,
        memory: document.getElementById('memoryContent').innerHTML,
        applicationHTML: getCleanApplicationHTML(),
        applicationData: currentApplicationData,
        summary: document.getElementById('summaryContent').innerHTML,
    };

    try {
        // 1. สร้าง Reference ไปยัง 2 ที่ที่เราจะบันทึก
        const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
        const lessonRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects/${currentBlueprintProjectId}/lessons`, topicId);

        // 2. ใช้ "batch" เพื่อสั่งบันทึก 2 ที่พร้อมกัน
        const batch = writeBatch(db);

        //    - คำสั่ง A: บันทึกข้อมูลใหญ่ (lessonContent) ไปที่ไฟล์ใหม่ใน subcollection 'lessons'
        batch.set(lessonRef, { content: lessonContent });

        //    - คำสั่ง B: อัปเดตแค่สถานะ (status) ในไฟล์หลักของโปรเจกต์
        batch.update(projectRef, {
            [`topics.${topicId}.status`]: 'generated'
        });

        // 3. ยืนยันการบันทึกทั้งหมด
        await batch.commit();

        console.log(`บันทึกบทเรียนสำหรับหัวข้อ ID: ${topicId} สำเร็จ`);
        displayBlueprintProjectManager(currentBlueprintProjectId);
    } catch (error) {
        console.error("Error saving lesson to project:", error);
    }
}
        }
    }, 1000);
}

function displayHalfMarkResult(score, totalQuestions) {
    const isAboveHalf = score >= totalQuestions / 2;
    const bgColor = isAboveHalf ? 'bg-green-100' : 'bg-red-100';
    const icon = isAboveHalf ? '<i class="fas fa-check-circle text-5xl text-green-500 mb-4"></i>' : '<i class="fas fa-times-circle text-5xl text-red-500 mb-4"></i>';
    const titleColor = isAboveHalf ? 'text-green-800' : 'text-red-800';
    const titleText = isAboveHalf ? 'ทำคะแนนได้เกินครึ่ง' : 'คะแนนยังไม่ถึงครึ่ง';
    const message = isAboveHalf ? 'ยอดเยี่ยม!' : 'สู้ๆ ลองอีกครั้งนะ';

    let resultHTML = `
        <div class="text-center p-8 ${bgColor} rounded-lg">
            ${icon}
            <h3 class="text-4xl font-bold ${titleColor} mb-2">${titleText}</h3>
            <p class="text-gray-700">${message}</p>
        </div>
    `;
    studentResultArea.innerHTML = resultHTML;
    studentResultArea.classList.remove('hidden');
    studentQuizArea.classList.add('hidden');
    
    setupResultScreenBackButton({ showRankings: false, showImproveButton: !isAboveHalf });
}
		
function displayPerfectScoreResult(score, totalQuestions) {
    const isPerfect = score === totalQuestions;
    const bgColor = isPerfect ? 'bg-yellow-100' : 'bg-blue-100';
    const icon = isPerfect ? '<i class="fas fa-crown text-5xl text-yellow-500 mb-4"></i>' : '<i class="fas fa-award text-5xl text-blue-500 mb-4"></i>';
    const titleColor = isPerfect ? 'text-yellow-800' : 'text-blue-800';
    const titleText = isPerfect ? 'คะแนนเต็ม!' : 'ยังไม่เต็มนะ';
    const message = isPerfect ? `สุดยอด! ตอบถูกทุกข้อ` : `เก่งมาก! พยายามอีกนิดเพื่อคะแนนเต็ม`;

    let resultHTML = `
        <div class="text-center p-8 ${bgColor} rounded-lg">
            ${icon}
            <h3 class="text-4xl font-bold ${titleColor} mb-2">${titleText}</h3>
            <p class="text-gray-700">${message}</p>
        </div>
    `;
    studentResultArea.innerHTML = resultHTML;
    studentResultArea.classList.remove('hidden');
    studentQuizArea.classList.add('hidden');
    
    setupResultScreenBackButton({ showRankings: false, score, totalQuestions });
}

function renderIndividualComparisonTable(data, container) {
    // เรียงลำดับตาม พัฒนาการ T-Score (เหมือนเดิม)
    data.sort((a, b) => (b.tGain ?? -Infinity) - (a.tGain ?? -Infinity));

    let tableHtml = `
        <div class="overflow-x-auto">
            <table class="min-w-full bg-white text-sm">
                <thead class="bg-gray-200">
                    <tr>
                        <th class="py-2 px-3 text-center w-12">อันดับ</th>
                        <th class="py-2 px-3 text-left">ชื่อนักเรียน</th>
                        <th class="py-2 px-3 text-center">คะแนนก่อน</th>
                        <th class="py-2 px-3 text-center">คะแนนหลัง</th>
                        <th class="py-2 px-3 text-center">ผลต่าง (ดิบ)</th>
                        <th class="py-2 px-3 text-center">พัฒนาการ</th>
                        <th class="py-2 px-3 text-center">T-Score (ก่อน)</th>
                        <th class="py-2 px-3 text-center">T-Score (หลัง)</th>
                        <th class="py-2 px-3 text-center">พัฒนาการ (T)</th>
                    </tr>
                </thead>
                <tbody>
    `;

    if (data.length === 0) {
        tableHtml += '<tr><td colspan="9" class="text-center p-4 text-gray-500">ไม่มีข้อมูลนักเรียน</td></tr>';
    } else {
        data.forEach((student, index) => {
            let gainHtml = '-';
            let gainIconHtml = '';

            if (student.gain !== null) {
                const color = student.gain > 0 ? 'text-green-600' : (student.gain < 0 ? 'text-red-600' : 'text-gray-500');
                const sign = student.gain > 0 ? '+' : '';
                gainHtml = `<span class="font-bold ${color}">${sign}${student.gain}</span>`;
                
                // --- ส่วนที่เพิ่มเข้ามา: ไอคอนแสดงสถานะพัฒนาการ ---
                if (student.gain > 0) {
                    gainIconHtml = '<span class="text-green-500" title="พัฒนาขึ้น">⬆️</span>';
                } else if (student.gain < 0) {
                    gainIconHtml = '<span class="text-red-500" title="ลดลง">⬇️</span>';
                } else {
                    gainIconHtml = '<span class="text-gray-500" title="คงที่">↔️</span>';
                }
            }

            let tGainHtml = '-';
            if (student.tGain !== null) {
                const color = student.tGain > 0 ? 'text-green-600' : (student.tGain < 0 ? 'text-red-600' : 'text-gray-500');
                const sign = student.tGain > 0 ? '+' : '';
                tGainHtml = `<span class="font-bold ${color}">${sign}${student.tGain.toFixed(2)}</span>`;
            }

            tableHtml += `
                <tr class="border-b hover:bg-gray-100">
                    <td class="py-2 px-3 text-center font-semibold">${index + 1}</td>
                    <td class="py-2 px-3 text-left">${student.name}</td>
                    <td class="py-2 px-3 text-center">${student.preScore ?? '-'}</td>
                    <td class="py-2 px-3 text-center font-bold">${student.postScore ?? '-'}</td>
                    <td class="py-2 px-3 text-center">${gainHtml}</td>
                    <td class="py-2 px-3 text-center text-xl">${gainIconHtml}</td>
                    <td class="py-2 px-3 text-center text-blue-600">${student.preTScore?.toFixed(2) ?? '-'}</td>
                    <td class="py-2 px-3 text-center text-green-600 font-bold">${student.postTScore?.toFixed(2) ?? '-'}</td>
                    <td class="py-2 px-3 text-center">${tGainHtml}</td>
                </tr>
            `;
        });
    }

    tableHtml += '</tbody></table></div>';
    container.innerHTML = tableHtml;
}

/**
 * จัดการการเปิดหน้าต่าง Modal สำหรับแก้ไขชื่อแบบทดสอบ
 * @param {string} quizId - ID ของแบบทดสอบที่จะแก้ไข
 * @param {string} topic - ชื่อหัวข้อปัจจุบันของแบบทดสอบ
 */
function handleRenameQuiz(quizId, topic) {
    // 1. เก็บ ID ของควิซที่จะแก้ไขไว้ในตัวแปรส่วนกลาง (actionTargetId)
    //    เพื่อให้ปุ่ม "บันทึก" รู้ว่าจะต้องไปอัปเดตข้อมูลของควิซอันไหน
    actionTargetId = quizId;

    // 2. นำชื่อเรื่องเดิม (topic) ที่ได้รับมา ไปใส่ในช่อง Input ของหน้าต่างแก้ไข
    document.getElementById('rename-quiz-input').value = topic;

    // 3. แสดงหน้าต่างแก้ไข (Modal) ขึ้นมา โดยการลบคลาส 'hidden' ออก
    renameQuizModal.classList.remove('hidden');
}

function setupComparisonModalTabs() {
    const overallTab = document.getElementById('comparison-overall-tab');
    const individualTab = document.getElementById('comparison-individual-tab');
    const overallContent = document.getElementById('comparison-overall-content');
    const individualContent = document.getElementById('comparison-individual-content');

    overallTab.addEventListener('click', () => {
        overallTab.classList.add('active');
        individualTab.classList.remove('active');
        overallContent.classList.remove('hidden');
        individualContent.classList.add('hidden');
    });

    individualTab.addEventListener('click', () => {
        individualTab.classList.add('active');
        overallTab.classList.remove('active');
        individualContent.classList.remove('hidden');
        overallContent.classList.add('hidden');
    });
}

// ในฟังก์ชัน setupEventListeners()
// ให้เพิ่มการเรียกใช้ฟังก์ชันนี้เข้าไป 1 บรรทัด
// (วางไว้ตรงไหนก็ได้ภายในฟังก์ชัน setupEventListeners)
setupComparisonModalTabs();


function listenForLiveGameUpdates() {
    if (unsubscribeLiveGameListener) unsubscribeLiveGameListener();

    const gameRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
    unsubscribeLiveGameListener = onSnapshot(gameRef, (docSnap) => {
        if (!docSnap.exists()) {
            // --- [START] นี่คือส่วนที่แก้ไขทั้งหมด ---
            showMessage("เกมสิ้นสุดลงแล้ว");

            if (cameFromBlueprint && currentBlueprintProjectId) {
                displayBlueprintProjectManager(currentBlueprintProjectId);
                cameFromBlueprint = false;
            } else if (currentMode === 'admin') {
                showView('project-detail');
            } else {
                showView('student');
            }
            // --- [END] สิ้นสุดส่วนที่แก้ไข ---
            return;
        }

        const gameData = docSnap.data();

        if (gameData.shuffledQuiz) {
            currentQuizData = gameData.shuffledQuiz;
        }

        if (!currentQuizData && gameData.quizId) {
            (async () => {
                try {
                    const quizDocRef = doc(db, `artifacts/${appId}/public/data/quizzes`, gameData.quizId);
                    const quizDocSnap = await getDoc(quizDocRef);
                    if (quizDocSnap.exists()) {
                        currentQuizData = { id: quizDocSnap.id, ...quizDocSnap.data() };
                    }
                } catch (e) { console.error('Failed to fetch quiz for admin:', e); }
            })();
        }

        switch (gameData.status) {
            case 'lobby':
                if (currentMode === 'admin') {
                    const players = gameData.players ? Object.entries(gameData.players) : [];
                    const activePlayers = players.filter(([name, data]) => data.status === 'active');

                    const playerCountEl = document.getElementById('player-count');
                    if(playerCountEl) playerCountEl.textContent = activePlayers.length;

                    const playerListLobby = document.getElementById('player-list-lobby');
                    if(playerListLobby){
                        playerListLobby.innerHTML = activePlayers.map(([name, data]) => `
                            <div class="bg-white/30 px-3 py-1 rounded-full text-sm flex items-center gap-2">
                                <span>${name}</span>
                                <button data-player-name="${name}" class="kick-player-btn text-red-200 hover:text-white font-bold" title="เตะผู้เล่นนี้ออก">&times;</button>
                            </div>
                        `).join('');
                    }

                    const startGameBtn = document.getElementById('start-game-btn');
                    if (startGameBtn) {
                        startGameBtn.disabled = activePlayers.length === 0;
                    }
                } else {
                    showView('live-game');
                    liveGameView.innerHTML = `<div class="live-game-bg text-white rounded-lg p-8 text-center flex flex-col items-center justify-center h-full">
                        <h2 class="text-3xl font-bold">คุณเข้าร่วมแล้ว!</h2>
                        <p class="text-xl mt-2">ชื่อของคุณคือ: <span class="font-bold">${currentStudentName}</span></p>
                        <p class="mt-8">รอผู้ควบคุมเริ่มเกมสักครู่...</p>
                        <div class="loader mt-4"></div>
                    </div>`;
                }
                break;

            case 'question':
                const questionIndex = gameData.currentQuestionIndex;
                if (currentQuizData && currentQuizData.questions[questionIndex]) {
                    const questionData = currentQuizData.questions[questionIndex];
                    const questionStatus = gameData.questionStatus || 'answering';

                    switch (questionStatus) {
                        case 'summary_chart':
                            if (currentMode === 'admin') {
                                showAdminSummaryView(gameData, questionData);
                            } else {
                                showPlayerSummaryView(gameData, currentStudentName);
                            }
                            break;

                        case 'leaderboard':
                            if (currentMode === 'admin') {
                                showTop5LeaderboardView(gameData);
                            }
                            break;

                        case 'answering':
                        default:
                            if (currentMode === 'admin') {
                                const batch = writeBatch(db);
                                let updatesMade = false;

                                Object.entries(gameData.players).forEach(([playerName, playerData]) => {
                                    if (playerData.status === 'active' && playerData.submittedAt && !playerData.isScored) {
                                        updatesMade = true;

                                        const timeTaken = playerData.submittedAt.toDate() - gameData.questionDisplayedAt.toDate();
                                        let calculatedPoints = 0;

                                        if (playerData.lastAnswerCorrect) {
                                            const maxPoints = 1000;
                                            const bonusPoints = 500; 
                                            const timeLimit = 20000;

                                            let timeRatio = timeTaken / timeLimit;
                                            if (timeRatio > 1) timeRatio = 1;

                                            const pointsLost = Math.round(timeRatio * bonusPoints);
                                            calculatedPoints = maxPoints - pointsLost;
                                        }

                                        const playerRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
                                        batch.update(playerRef, {
                                            [`players.${playerName}.score`]: increment(calculatedPoints),
                                            [`players.${playerName}.pointsLastQuestion`]: calculatedPoints,
                                            [`players.${playerName}.isScored`]: true
                                        });
                                    }
                                });

                                if (updatesMade) {
                                    batch.commit().catch(err => console.error("Error committing score updates:", err));
                                }

                                if (lastRenderedAdminQuestionIndex !== questionIndex) {
                                    showAdminLiveQuestionView(questionData, questionIndex, currentQuizData.questions.length);
                                    lastRenderedAdminQuestionIndex = questionIndex;
                                }

                                const allPlayers = gameData.players || {};
                                const activePlayers = Object.values(allPlayers).filter(p => p.status === 'active');
                                const totalActivePlayers = activePlayers.length;
                                const answeredActivePlayers = activePlayers.filter(p => p.answeredCurrentQuestion === true).length;

                                const answerCounterEl = document.getElementById('answer-counter');
                                if (answerCounterEl) answerCounterEl.textContent = `${answeredActivePlayers}/${totalActivePlayers}`;

                                // --- [START] โค้ดที่เพิ่มเข้ามาใหม่ ---
                                const playerListContainer = document.getElementById('live-player-list');
                                if(playerListContainer) {
                                    let playerListHtml = Object.entries(allPlayers)
                                        .filter(([name, data]) => data.status === 'active') // กรองเฉพาะคนที่ยังอยู่ในเกม
                                        .map(([name, data]) => {
                                            const hasAnswered = data.answeredCurrentQuestion === true;
                                            const bgColor = hasAnswered ? 'bg-green-500' : 'bg-gray-500';
                                            const icon = hasAnswered ? '<i class="fas fa-check-circle"></i>' : '<i class="fas fa-hourglass-half"></i>';

                                            return `
                                                <div class="flex items-center gap-2 px-3 py-1 rounded-full text-white text-sm ${bgColor}">
                                                    ${icon}
                                                    <span>${name}</span>
                                                    <button data-player-name="${name}" class="kick-player-btn text-red-200 hover:text-white font-bold" title="นำผู้เล่นนี้ออก">&times;</button>
                                                </div>
                                            `;
                                        }).join('');

                                    playerListContainer.innerHTML = playerListHtml || '<p class="text-xs text-gray-300">ไม่มีผู้เล่นที่ใช้งานอยู่</p>';
                                }
                                // --- [END] สิ้นสุดโค้ดที่เพิ่มเข้ามา ---

                                if (totalActivePlayers > 0 && answeredActivePlayers === totalActivePlayers) {
                                    revealAnswerForAdmin(questionIndex, currentQuizData.questions.length);
                                }
                            } else {
                                const playerData = gameData.players[currentStudentName];
                                if (playerData && !playerData.answeredCurrentQuestion) {
                                    showStudentLiveQuestionView(questionData, questionIndex, currentQuizData.questions.length);
                                }
                            }
                            break;
                    }
                }
                break;

            case 'podium':
                showPodiumView(gameData.players, 'live-race');
                break;       
        }
    });
}
		
// ✅ โค้ดใหม่ที่แก้ไขแล้ว

// 1. เปลี่ยนชื่อฟังก์ชันให้สื่อความหมายมากขึ้น
async function openGlobalActivityModal() {
  if (allQuizzesGlobal.length === 0) {
    const qs = await getDocs(collection(db, `artifacts/${appId}/public/data/quizzes`));
    allQuizzesGlobal = qs.docs.map(d => ({ id: d.id, ...d.data() }));
  }
  renderGlobalActivityList(''); // เรียกฟังก์ชัน render ใหม่
  document.getElementById('global-activity-modal').classList.remove('hidden');
}

function renderGlobalActivityList(filterText = '') {
  const listEl = document.getElementById('global-activity-quiz-list');
  const term = filterText.toLowerCase().trim();

  const rows = allQuizzesGlobal
    .map(q => ({
      ...q,
      projectName: (allProjects.find(p => p.id === q.projectId)?.projectName) || 'N/A'
    }))
    .filter(q =>
      (q.topic || '').toLowerCase().includes(term) ||
      (q.projectName || '').toLowerCase().includes(term)
    );

  document.getElementById('global-quiz-count').textContent = `(${rows.length} ชุด)`;

  listEl.innerHTML = rows.length
    ? rows.map(q => `
        <div class="p-3 border-b flex items-center justify-between gap-4 hover:bg-gray-50">
          <div class="flex-grow">
            <p class="font-semibold text-indigo-700">${q.topic || '(ไม่มีชื่อ)'}
              <span class="text-sm font-normal text-gray-500">(${q.questions?.length || 0} ข้อ)</span>
            </p>
            <p class="text-xs text-gray-600">โปรเจค: ${q.projectName}</p>
          </div>

          <div class="flex items-center gap-2 flex-shrink-0">
            <button data-id="${q.id}" data-mode="live-race" class="game-start-btn bg-orange-100 text-orange-800 hover:bg-orange-200 font-semibold py-2 px-3 rounded-lg text-sm" title="แข่งขันสด (Live Race)">
                <i class="fas fa-flag-checkered pointer-events-none"></i>
            </button>
            
            <button data-id="${q.id}" data-mode="sync" class="game-start-btn bg-indigo-600 text-white hover:bg-indigo-700 font-semibold py-2 px-3 rounded-lg text-sm flex items-center gap-1">
                <i class="fas fa-bolt pointer-events-none"></i> Sync Mode
            </button>
            </div>
        </div>
      `).join('')
    : `<div class="p-4 text-center text-gray-500">ไม่พบแบบทดสอบ</div>`;
}

        async function handleKickPlayer(playerName) {
            if (!currentLiveGameId || !playerName) return;

            const gameRef = doc(db, `artifacts/${appId}/public/data/liveGames`, currentLiveGameId);
            const updatePayload = {};
            updatePayload[`players.${playerName}.status`] = 'inactive';

            try {
                await updateDoc(gameRef, updatePayload);
                // ไม่ต้องทำอะไรต่อ onSnapshot จะ re-render หน้าจอให้อัตโนมัติ
            } catch (error) {
                console.error(`Failed to kick player ${playerName}:`, error);
                showMessage("เกิดข้อผิดพลาดในการนำผู้เล่นออก");
            }
        }

        async function authenticateUser() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
                showMessage("การยืนยันตัวตนล้มเหลว");
            }
        }

// --- วางทับฟังก์ชัน showView เดิมทั้งหมดด้วยโค้ดนี้ ---
function showView(view) {
    // --- 1. ซ่อน View หลักทั้งหมดก่อน ---
    adminView.classList.add('hidden');
    studentView.classList.add('hidden');
    projectDashboardView.classList.add('hidden');
    projectDetailView.classList.add('hidden');
    quizResultsView.classList.add('hidden');
    liveGameView.classList.add('hidden');
    
    // [แก้ไข] เพิ่มบรรทัดนี้เพื่อซ่อนหน้า Blueprint Manager เสมอ
    document.getElementById('blueprint-project-manager-view').classList.add('hidden');

    // --- 2. ซ่อน View ย่อยของฝั่ง Student ---
    studentInitialView.classList.add('hidden');
    studentJoinGameView.classList.add('hidden');
    studentNameSelectionView.classList.add('hidden');
    studentQuizArea.classList.add('hidden');
    studentResultArea.classList.add('hidden');
    studentReadingArea.classList.add('hidden');
    
    // --- 3. ซ่อน View ย่อยอื่นๆ ที่เพิ่มเข้ามา ---
    const teamSelectionView = document.getElementById('student-team-selection-view');
    const studentProgressView = document.getElementById('student-progress-view');

    if (teamSelectionView) teamSelectionView.classList.add('hidden');
    if (studentProgressView) studentProgressView.classList.add('hidden');

    // --- 4. แสดง View ที่ต้องการตามชื่อที่ส่งมา ---
    switch (view) {
        case 'admin-dashboard':
            adminView.classList.remove('hidden');
            projectDashboardView.classList.remove('hidden');
            break;
        case 'project-detail':
            adminView.classList.remove('hidden');
            projectDetailView.classList.remove('hidden');
            break;
        case 'quiz-results':
            adminView.classList.remove('hidden');
            quizResultsView.classList.remove('hidden');
            break;
        case 'student':
            studentView.classList.remove('hidden');
            studentInitialView.classList.remove('hidden');
            break;
        case 'live-game':
            liveGameView.classList.remove('hidden');
            break;
        case 'student-team-join':
             studentView.classList.remove('hidden');
             if (teamSelectionView) teamSelectionView.classList.remove('hidden');
             break;
        case 'student-progress':
             studentView.classList.remove('hidden');
             if (studentProgressView) studentProgressView.classList.remove('hidden');
             break;
        default:
            studentView.classList.remove('hidden');
            studentInitialView.classList.remove('hidden');
            break;
    }
}
        
        function showJoinGameView() {
            studentInitialView.classList.add('hidden');
            studentJoinGameView.classList.remove('hidden');
        }
		
		// --- [ เพิ่มฟังก์ชันนี้เข้าไปใหม่ทั้งหมด ] ---

// --- [ วางทับฟังก์ชันนี้ทั้งหมด ] ---
async function handleSaveVisibilitySettings() {
    if (!currentProjectId) return;

    const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, currentProjectId);
    try {
        await updateDoc(projectRef, {
            'settings.showInStudentDashboard': document.getElementById('show-in-student-dashboard-checkbox').checked,
            'settings.isPasscodeEnabled': document.getElementById('enable-passcode-checkbox').checked,
            'settings.passcode': document.getElementById('project-passcode-input').value.trim()
        });
        showMessage("บันทึกการตั้งค่าการแสดงผลสำเร็จ");
    } catch (error) {
        console.error("Error saving visibility settings:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึก");
    }
}
        
        function setupEventListeners() {
		
		const scanImgInput = document.getElementById('scan-text-image-input');
    const scanImgBtn = document.getElementById('scan-text-image-btn');

    if (scanImgInput && scanImgBtn) {
        // เมื่อกดปุ่ม -> ให้คลิก input file
        scanImgBtn.addEventListener('click', () => scanImgInput.click());

        // เมื่อเลือกไฟล์เสร็จ -> เรียกฟังก์ชันสแกน
        scanImgInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleScanImageForText(e.target.files[0]);
            }
        });
    }
		
		const allInBtn = document.getElementById('wager-all-in-btn');
    if (allInBtn) {
        allInBtn.addEventListener('click', () => {
            const slider = document.getElementById('wager-slider');
            const display = document.getElementById('wager-amount-display');
            
            if (slider) {
                // 1. ตั้งค่า Slider ให้สุดแม็กซ์
                slider.value = slider.max;
                
                // 2. อัปเดตตัวเลขที่แสดง
                if (display) {
                    display.textContent = slider.value;
                    // เอฟเฟกต์ตัวเลขเด้งเล็กน้อย
                    display.classList.remove('scale-125'); // รีเซ็ต class
                    void display.offsetWidth; // trigger reflow
                    display.classList.add('transform', 'transition-transform', 'scale-125', 'text-red-600');
                    setTimeout(() => display.classList.remove('scale-125', 'text-red-600'), 200);
                }
            }
        });
    }
		
		document.getElementById('cancel-wager-btn').addEventListener('click', () => {
    document.getElementById('wager-modal').classList.add('hidden');
});

document.getElementById('confirm-wager-btn').addEventListener('click', () => {
    const wagerModal = document.getElementById('wager-modal');
    const hiddenInput = document.getElementById('selected-answer-index-hidden-wager');
    const wagerAmount = document.getElementById('wager-slider').value;

    // ดึงข้อมูลที่เก็บไว้
    const answerValue = hiddenInput.dataset.answerValue;
    const question = JSON.parse(hiddenInput.dataset.question);
    const gameData = JSON.parse(hiddenInput.dataset.gameData);
    const playerName = hiddenInput.dataset.playerName;

    wagerModal.classList.add('hidden'); // ซ่อน Modal

    // ส่งคำตอบ + จำนวนเงินที่เดิมพัน
    handleSyncAnswerSubmit(answerValue, question, gameData, playerName, false, wagerAmount);
});
		
		document.querySelectorAll('input[name="syncVariant"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        const anonSettings = document.getElementById('anon-settings-container');
        if (e.target.value === 'anonymous') {
            anonSettings.classList.remove('hidden');
        } else {
            anonSettings.classList.add('hidden');
        }
    });
});
		
		document.getElementById('sync-timer-enable-checkbox').addEventListener('change', (e) => {
    document.getElementById('sync-timer-duration-container').classList.toggle('hidden', !e.target.checked);
});
		
		const cancelConfidenceBtn = document.getElementById('cancel-confidence-btn');
const confidenceModalForCancel = document.getElementById('confidence-modal');
if (cancelConfidenceBtn && confidenceModalForCancel) {
    cancelConfidenceBtn.addEventListener('click', () => {
        confidenceModalForCancel.classList.add('hidden');
        confidenceModalForCancel.dataset.currentMode = ''; // เคลียร์สถานะ
    });
}
		
		const overlay = document.getElementById('dim-overlay');
    if (overlay) {
        // ใช้ mousedown และ touchstart เพื่อจับ Event ให้เร็วที่สุดก่อนที่มันจะทะลุ
        overlay.addEventListener('mousedown', wakeUpScreen);
        overlay.addEventListener('touchstart', wakeUpScreen);
    }
		
// ในฟังก์ชัน setupEventListeners()
document.getElementById('save-bp-reference-btn').addEventListener('click', async () => {
    if (!currentBlueprintProjectId) return;
    const url = document.getElementById('bp-reference-file-url').value.trim();
    const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
    try {
        await updateDoc(projectRef, { referenceFileUrl: url });
        showMessage("บันทึกลิงก์ไฟล์อ้างอิงสำเร็จ");
    } catch (error) {
        console.error("Error saving reference URL:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึก");
    }
});

document.getElementById('add-parallel-shortcut-tab-btn').addEventListener('click', handleAddParallelShortcutTab);

document.getElementById('parallel-test-input-area').addEventListener('click', (e) => {
    if (e.target.closest('#open-additional-parallel-shortcuts-btn')) {
        activeParallelShortcutTabId = 'all';
        renderAdditionalParallelShortcutsModal();
        document.getElementById('additional-parallel-shortcuts-modal').classList.remove('hidden');
    }
});

document.getElementById('close-additional-parallel-shortcuts-btn').addEventListener('click', () => {
    document.getElementById('additional-parallel-shortcuts-modal').classList.add('hidden');
});

document.addEventListener('click', (e) => {
    if (!e.target.closest('.group\\/dropdown-parallel')) {
         document.querySelectorAll('.move-parallel-shortcut-dropdown').forEach(d => d.classList.add('hidden'));
    }
});
// ▲▲▲ สิ้นสุดส่วนที่เพิ่ม ▲▲▲
		
		// ▼▼▼ ในฟังก์ชัน setupEventListeners() ให้เพิ่มโค้ดส่วนนี้เข้าไป ▼▼▼

// --- [File Shortcut Tab System] ---
document.getElementById('add-file-shortcut-tab-btn').addEventListener('click', handleAddFileShortcutTab);

document.getElementById('file-input-area').addEventListener('click', (e) => {
    if (e.target.closest('#open-additional-file-shortcuts-btn')) {
        activeFileShortcutTabId = 'all';
        renderAdditionalFileShortcutsModal();
        document.getElementById('additional-file-shortcuts-modal').classList.remove('hidden');
    }
});

document.getElementById('close-additional-file-shortcuts-btn').addEventListener('click', () => {
    document.getElementById('additional-file-shortcuts-modal').classList.add('hidden');
});

document.addEventListener('click', (e) => {
    if (!e.target.closest('.group\\/dropdown-file')) { // ใช้ Selector ที่ถูกต้อง
         document.querySelectorAll('.move-file-shortcut-dropdown').forEach(d => d.classList.add('hidden'));
    }
});
// ▲▲▲ สิ้นสุดส่วนที่เพิ่ม ▲▲▲
		
		document.getElementById('add-shortcut-tab-btn').addEventListener('click', handleAddShortcutTab);
		
document.getElementById('parallel-shortcut-container').addEventListener('click', (e) => {
    const shortcutBtn = e.target.closest('.parallel-shortcut-btn');
    const editBtn = e.target.closest('.edit-parallel-shortcut-btn');
    const deleteBtn = e.target.closest('.delete-parallel-shortcut-btn');

    if (editBtn) {
        openParallelTestShortcutEditor(editBtn.dataset.id);
    } else if (deleteBtn) {
        const shortcutId = deleteBtn.dataset.id;
        showConfirmation(`คุณแน่ใจว่าต้องการลบปุ่มลัดนี้?`, async () => {
            const updatedShortcuts = parallelTestShortcuts.filter(s => s.id !== shortcutId);
            const prefRef = doc(db, "globalSettings", "parallelTestShortcutsConfig");
            await setDoc(prefRef, { shortcuts: updatedShortcuts }, { merge: true });
        });
    } else if (shortcutBtn) {
        handleParallelTestShortcutClick(shortcutBtn.dataset.id);
    }
});

document.getElementById('add-parallel-shortcut-btn').addEventListener('click', () => openParallelTestShortcutEditor(null));

document.getElementById('cancel-parallel-shortcut-edit-btn').addEventListener('click', () => {
    document.getElementById('parallel-shortcut-editor-modal').classList.add('hidden');
});

document.getElementById('save-parallel-shortcut-btn').addEventListener('click', saveParallelTestShortcutChanges);

document.getElementById('parallel-test-input-area').addEventListener('click', (e) => {
    if (e.target.closest('#open-additional-parallel-shortcuts-btn')) {
        document.getElementById('additional-parallel-shortcuts-modal').classList.remove('hidden');
    }
});

document.getElementById('close-additional-parallel-shortcuts-btn').addEventListener('click', () => {
    document.getElementById('additional-parallel-shortcuts-modal').classList.add('hidden');
});

document.getElementById('additional-parallel-shortcuts-list').addEventListener('click', (e) => {
    const modal = document.getElementById('additional-parallel-shortcuts-modal');
    const useBtn = e.target.closest('.use-hidden-parallel-shortcut-btn');
    const editBtn = e.target.closest('.edit-hidden-parallel-shortcut-btn');
    const deleteBtn = e.target.closest('.delete-hidden-parallel-shortcut-btn');

    if (useBtn) {
        modal.classList.add('hidden');
        handleParallelTestShortcutClick(useBtn.dataset.id);
    } else if (editBtn) {
        modal.classList.add('hidden');
        openParallelTestShortcutEditor(editBtn.dataset.id);
    } else if (deleteBtn) {
        const shortcutId = deleteBtn.dataset.id;
        showConfirmation(`คุณแน่ใจว่าต้องการลบปุ่มลัดนี้?`, async () => {
           const updatedShortcuts = parallelTestShortcuts.filter(s => s.id !== shortcutId);
           const prefRef = doc(db, "globalSettings", "parallelTestShortcutsConfig");
           await setDoc(prefRef, { shortcuts: updatedShortcuts }, { merge: true });
       });
    }
});

document.getElementById('file-shortcut-container').addEventListener('click', (e) => {
    const shortcutBtn = e.target.closest('.file-shortcut-btn');
    const editBtn = e.target.closest('.edit-file-shortcut-btn');
    const deleteBtn = e.target.closest('.delete-file-shortcut-btn');

    if (editBtn) {
        openFileShortcutEditor(editBtn.dataset.id);
    } else if (deleteBtn) {
        const shortcutId = deleteBtn.dataset.id;
        showConfirmation(`คุณแน่ใจว่าต้องการลบปุ่มลัดนี้?`, async () => {
            const updatedShortcuts = fileShortcuts.filter(s => s.id !== shortcutId);
            const prefRef = doc(db, "globalSettings", "fileShortcutsConfig");
            await setDoc(prefRef, { shortcuts: updatedShortcuts }, { merge: true });
        });
    } else if (shortcutBtn) {
        handleFileShortcutClick(shortcutBtn.dataset.id);
    }
});

document.getElementById('add-file-shortcut-btn').addEventListener('click', () => openFileShortcutEditor(null));

document.getElementById('cancel-file-shortcut-edit-btn').addEventListener('click', () => {
    document.getElementById('file-shortcut-editor-modal').classList.add('hidden');
});
document.getElementById('save-file-shortcut-btn').addEventListener('click', saveFileShortcutChanges);

document.getElementById('file-input-area').addEventListener('click', (e) => {
    if (e.target.closest('#open-additional-file-shortcuts-btn')) {
        document.getElementById('additional-file-shortcuts-modal').classList.remove('hidden');
    }
});

document.getElementById('close-additional-file-shortcuts-btn').addEventListener('click', () => {
    document.getElementById('additional-file-shortcuts-modal').classList.add('hidden');
});

document.getElementById('additional-file-shortcuts-list').addEventListener('click', (e) => {
    const modal = document.getElementById('additional-file-shortcuts-modal');
    const useBtn = e.target.closest('.use-hidden-file-shortcut-btn');
    const editBtn = e.target.closest('.edit-hidden-file-shortcut-btn');
    const deleteBtn = e.target.closest('.delete-hidden-file-shortcut-btn');

    if (useBtn) {
        modal.classList.add('hidden');
        handleFileShortcutClick(useBtn.dataset.id);
    } else if (editBtn) {
        modal.classList.add('hidden');
        openFileShortcutEditor(editBtn.dataset.id);
    } else if (deleteBtn) {
        const shortcutId = deleteBtn.dataset.id;
        showConfirmation(`คุณแน่ใจว่าต้องการลบปุ่มลัดนี้?`, async () => {
           const updatedShortcuts = fileShortcuts.filter(s => s.id !== shortcutId);
           const prefRef = doc(db, "globalSettings", "fileShortcutsConfig");
           await setDoc(prefRef, { shortcuts: updatedShortcuts }, { merge: true });
       });
    }
});
// ▲▲▲ END: สิ้นสุดส่วน Event Listeners ▲▲▲

// จัดการการคลิกปุ่ม "เพิ่มเติม" เพื่อเปิด Modal
document.getElementById('blueprint-input-area').addEventListener('click', (e) => {
    // ปุ่ม "ปุ่มลัดเพิ่มเติม"
    if (e.target.closest('#open-additional-shortcuts-btn')) {
        activeShortcutTabId = 'all'; // รีเซ็ตให้เปิดที่แท็บ "ทั้งหมด" เสมอ
        renderAdditionalShortcutsModal(); // เรียกใช้ฟังก์ชันวาด Modal ใหม่ของเรา
        document.getElementById('additional-shortcuts-modal').classList.remove('hidden');
    }
});

// จัดการการคลิกปุ่มปิด (X) ใน Modal
document.getElementById('close-additional-shortcuts-btn').addEventListener('click', () => {
    document.getElementById('additional-shortcuts-modal').classList.add('hidden');
});

// จัดการการคลิกปุ่มต่างๆ (ใช้งาน, แก้ไข, ลบ) ที่อยู่ใน Modal
document.getElementById('additional-shortcuts-list').addEventListener('click', (e) => {
    const useBtn = e.target.closest('.use-hidden-shortcut-btn');
    const editBtn = e.target.closest('.edit-hidden-shortcut-btn');
    const deleteBtn = e.target.closest('.delete-hidden-shortcut-btn');
    const modal = document.getElementById('additional-shortcuts-modal');

    if (useBtn) {
        modal.classList.add('hidden'); // ซ่อน Modal ก่อน
        handleShortcutClick(useBtn.dataset.id); // เรียกใช้ฟังก์ชันเดิม
    } else if (editBtn) {
        modal.classList.add('hidden'); // ซ่อน Modal ก่อน
        openShortcutEditor(editBtn.dataset.id); // เรียกใช้ฟังก์ชันเดิม
    } else if (deleteBtn) {
        const shortcutId = deleteBtn.dataset.id;
        const shortcutName = blueprintShortcuts.find(s => s.id === shortcutId)?.name;
        showConfirmation(`คุณแน่ใจว่าต้องการลบปุ่มลัด "${shortcutName}"?`, async () => {
            const updatedShortcuts = blueprintShortcuts.filter(s => s.id !== shortcutId);
            try {
                const prefRef = doc(db, "globalSettings", "dashboardConfig");
                await setDoc(prefRef, { blueprintShortcuts: updatedShortcuts }, { merge: true });
            } catch (error) { console.error("Error deleting shortcut:", error); }
        });
    }
});
// ▲▲▲ สิ้นสุด Event Listener ใหม่ ▲▲▲

// จัดการการคลิกบน Container ของปุ่มลัดทั้งหมด
document.getElementById('blueprint-shortcut-container').addEventListener('click', (e) => {
    const shortcutBtn = e.target.closest('.shortcut-btn');
    const editBtn = e.target.closest('.edit-shortcut-btn');
    const deleteBtn = e.target.closest('.delete-shortcut-btn');

    if (editBtn) {
        openShortcutEditor(editBtn.dataset.id);
    } else if (deleteBtn) {
        const shortcutId = deleteBtn.dataset.id;
        const shortcutName = blueprintShortcuts.find(s => s.id === shortcutId)?.name;
        showConfirmation(`คุณแน่ใจว่าต้องการลบปุ่มลัด "${shortcutName}"?`, async () => {
            const updatedShortcuts = blueprintShortcuts.filter(s => s.id !== shortcutId);
            try {
                // *** แก้ไข path ให้เป็นตำแหน่งสาธารณะที่ถูกต้อง ***
                const prefRef = doc(db, "globalSettings", "dashboardConfig");
                await setDoc(prefRef, { blueprintShortcuts: updatedShortcuts }, { merge: true });
            } catch (error) { console.error("Error deleting shortcut:", error); }
        });
    } else if (shortcutBtn) {
        handleShortcutClick(shortcutBtn.dataset.id);
    }
});

// ปุ่มเพิ่มทางลัดใหม่
document.getElementById('add-shortcut-btn').addEventListener('click', () => openShortcutEditor(null));

// ปุ่มใน Modal แก้ไข
document.getElementById('cancel-shortcut-edit-btn').addEventListener('click', () => {
    document.getElementById('shortcut-editor-modal').classList.add('hidden');
});
document.getElementById('save-shortcut-btn').addEventListener('click', saveShortcutChanges);

// แก้ไข Event ของปุ่ม "สร้างแบบทดสอบตาม Blueprint" ให้รองรับไฟล์ที่อัปโหลด
document.getElementById('generate-from-blueprint-btn').addEventListener('click', async () => {
    const blueprintInput = document.getElementById('blueprint-upload-input');
    const referenceInput = document.getElementById('reference-pdf-upload');
    if (blueprintInput.files.length > 0) {
        await handleGenerateFromBlueprintWithFiles(blueprintInput.files[0], referenceInput.files[0] || null);
    } else {
        showMessage("กรุณาอัปโหลดไฟล์ Blueprint หรือใช้ปุ่มลัด");
    }
});

// ▲▲▲ สิ้นสุดส่วนที่เพิ่ม ▲▲▲
		
// --- วางทับ Event Listener ของ topic-quiz-bank-modal เดิมทั้งหมด ---
// --- วางทับ Event Listener ของ topic-quiz-bank-modal เดิมทั้งหมด ---
document.getElementById('topic-quiz-bank-modal').addEventListener('click', async (e) => {
    const modal = document.getElementById('topic-quiz-bank-modal');

    // ดึงตัวแปรปุ่มทั้งหมดที่อยู่ใน Modal นี้
    const viewAnalysisBtn = e.target.closest('.bp-view-analysis-btn');
    const unlinkBtn = e.target.closest('.bp-unlink-quiz-btn');
    const presentBtn = e.target.closest('.bp-present-btn');
    const tryBtn = e.target.closest('.bp-try-btn');
    const liveBtn = e.target.closest('.bp-live-btn');
    const gameBtn = e.target.closest('.bp-game-btn');

    // --- Logic การทำงานของปุ่มทั้งหมด ---

    if (viewAnalysisBtn) {
        // ตั้งค่า "ความจำ" ก่อนไปหน้าวิเคราะห์ผล
        cameFromBlueprint = true; 
        
        const quizId = viewAnalysisBtn.dataset.quizId;
        showQuizDetailView(quizId);
        modal.classList.add('hidden'); // ซ่อนหน้าต่าง
    }
    else if (unlinkBtn) {
        // เพิ่มหน้าต่างยืนยันก่อนลบ
        const topicId = unlinkBtn.dataset.topicId;
        const quizIdToRemove = unlinkBtn.dataset.quizId;
        const quizData = allQuizzesGlobal.find(q => q.id === quizIdToRemove);
        const quizTopic = quizData ? quizData.topic : 'รายการนี้';

        showConfirmation(
            `คุณแน่ใจหรือไม่ว่าต้องการนำแบบทดสอบ "${quizTopic}" ออกจากคลังนี้?`,
            async () => {
                try {
                    const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
                    // ใช้ arrayRemove เพื่อความปลอดภัยและแม่นยำ
                    await updateDoc(projectRef, {
                        [`topics.${topicId}.linkedQuizIds`]: arrayRemove(quizIdToRemove)
                    });
                    showMessage("นำแบบทดสอบออกจากคลังนี้แล้ว");
                    openTopicQuizBank(topicId); // รีเฟรช Modal
                    displayBlueprintProjectManager(currentBlueprintProjectId); // รีเฟรชหน้าหลัก
                } catch (error) { 
                    console.error("Error unlinking quiz:", error);
                    showMessage("เกิดข้อผิดพลาดในการนำแบบทดสอบออก");
                }
            }
        );
    } 
    else if (presentBtn) {
        cameFromBlueprint = true; // ตั้งค่า "ความจำ"
        const quizId = presentBtn.dataset.quizId;
        const quizData = allQuizzesGlobal.find(q => q.id === quizId);
        if (quizData) {
            startPresentation(quizData);
            modal.classList.add('hidden'); // ซ่อนหน้าต่าง
        }
    } 
    else if (tryBtn) {
        cameFromBlueprint = true; // ตั้งค่า "ความจำ"
        const quizId = tryBtn.dataset.quizId;
        const quizData = allQuizzesGlobal.find(q => q.id === quizId);
        if (quizData) {
            currentQuizData = quizData;
            startAdminTest();
            modal.classList.add('hidden'); // ซ่อนหน้าต่าง
        }
    } 
    else if (liveBtn) {
        cameFromBlueprint = true; // ตั้งค่า "ความจำ"
        handleStartLiveRace(liveBtn.dataset.quizId);
        modal.classList.add('hidden'); // ซ่อนหน้าต่าง
    } 
    else if (gameBtn) {
        cameFromBlueprint = true; // ตั้งค่า "ความจำ"
        const quizId = gameBtn.dataset.quizId;
        const mode = gameBtn.dataset.mode;
        const quizData = allQuizzesGlobal.find(q => q.id === quizId);
        if (quizData) {
            showGameStartConfirmationModal(quizId, mode, quizData.topic);
            modal.classList.add('hidden'); // ซ่อนหน้าต่าง
        }
    }
});
				document.getElementById('manual-create-blueprint-btn').addEventListener('click', () => {
    document.getElementById('manual-blueprint-modal').classList.remove('hidden');
    // Clear previous input
    document.getElementById('manual-bp-project-name').value = '';
    document.getElementById('manual-bp-grade-level').value = '';
    document.getElementById('manual-bp-content').value = '';
});

document.getElementById('cancel-manual-bp-btn').addEventListener('click', () => {
    document.getElementById('manual-blueprint-modal').classList.add('hidden');
});

document.getElementById('confirm-manual-bp-btn').addEventListener('click', handleManualBlueprintSave);
		
		document.getElementById('cancel-bp-settings-btn').addEventListener('click', () => document.getElementById('blueprint-settings-modal').classList.add('hidden'));
		document.getElementById('save-bp-settings-btn').addEventListener('click', handleSaveBlueprintPageSettings);
		
		// ในฟังก์ชัน setupEventListeners()
document.getElementById('bp-quiz-settings-btn').addEventListener('click', openBlueprintQuizSettings);
		
		// ในฟังก์ชัน setupEventListeners()

// ... (โค้ด Event Listener เดิม) ...

// === [ใหม่] Blueprint Project Manager Listeners ===

// 1. ปุ่ม "บันทึก" หลังจากวิเคราะห์ Blueprint
document.getElementById('save-blueprint-as-project-btn').addEventListener('click', saveBlueprintProject);

// 2. ปุ่มเปิด Modal รายการโปรเจค
document.getElementById('open-blueprint-projects-btn').addEventListener('click', showBlueprintProjects);
document.getElementById('cancel-blueprint-projects-btn').addEventListener('click', () => {
    document.getElementById('blueprint-projects-modal').classList.add('hidden');
});

// 3. จัดการการคลิกใน Modal รายการโปรเจค (Open/Delete)
document.getElementById('blueprint-project-list').addEventListener('click', (e) => {
    const openBtn = e.target.closest('.open-bp-project-btn');
    const deleteBtn = e.target.closest('.delete-bp-project-btn');
    
    if (openBtn) {
        displayBlueprintProjectManager(openBtn.dataset.id);
    } else if (deleteBtn) {
        // --- [ จุดแก้ไขที่สำคัญ ] ---
        // เปลี่ยนจากการลบธรรมดา มาเรียกใช้ฟังก์ชันลบแบบล้างบางที่เราสร้างขึ้น
        handleDeepDeleteBlueprintProject(deleteBtn.dataset.id);
    }
});

// 4. ปุ่ม "กลับ" จากหน้า Manager
document.getElementById('back-to-dashboard-from-bp-btn').addEventListener('click', () => {
    currentBlueprintProjectId = null;
    currentProjectId = null; // <-- เพิ่มบรรทัดนี้เข้าไป
    document.getElementById('blueprint-project-manager-view').classList.add('hidden');
    showView('admin-dashboard');
});

// 5. ปุ่ม "เพิ่มหัวข้อ" ในหน้า Manager
document.getElementById('bp-add-topic-btn').addEventListener('click', addTopicToProject);

// 6. จัดการการคลิกในรายการหัวข้อ (Generate/Edit/Delete)
// ▼▼▼ วางทับ event listener ของ bp-topic-list-container เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼

// --- วางทับ Event Listener ของ bp-topic-list-container เดิมทั้งหมด ---
// ▼▼▼ วางทับ event listener ของ bp-topic-list-container เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
document.getElementById('bp-topic-list-container').addEventListener('click', async (e) => {
    const topicRow = e.target.closest('[data-topic-id]');
    if (!topicRow) return;
    const topicId = topicRow.dataset.topicId;

    const onetQuizBtn = e.target.closest('.bp-create-onet-quiz-btn');
    const contentQuizBtn = e.target.closest('.bp-create-content-quiz-btn');
    const topicQuizBtn = e.target.closest('.bp-create-topic-quiz-btn');
    const openTopicBankBtn = e.target.closest('.bp-open-topic-bank-btn');
    const viewBtn = e.target.closest('.view-bp-lesson-btn');
    const generateBtn = e.target.closest('.bp-generate-lesson-btn');
    const editBtn = e.target.closest('.bp-edit-topic-btn');
    const deleteBtn = e.target.closest('.bp-delete-topic-btn');

    // --- [START] ส่วนแก้ไข: สร้างฟังก์ชันสำหรับดึงหัวข้อแบบเต็ม ---
    const getFullTopicName = (rowElement) => {
        const subTopicText = rowElement.querySelector('[data-field="subTopic"]').textContent.trim();
        // ไต่ระดับ DOM ขึ้นไปหา h5 ที่เป็นหัวข้อหลัก
        const mainTopicElement = rowElement.closest('.space-y-1.pl-4').previousElementSibling;
        const mainTopicText = mainTopicElement ? mainTopicElement.textContent.trim() : '';
        
        // รวมหัวข้อหลักและหัวข้อย่อยเข้าด้วยกัน
        return `${mainTopicText}: ${subTopicText}`;
    };
    // --- [END] สิ้นสุดส่วนแก้ไข ---

    if (openTopicBankBtn) {
        openTopicQuizBank(topicId);
    }
    else if (onetQuizBtn) {
        const fullTopicName = getFullTopicName(topicRow);
        selectProjectAndGenerateBlueprintQuiz(fullTopicName, null, topicId, true);
    }
    else if (contentQuizBtn) {
        const fullTopicName = getFullTopicName(topicRow);
        try {
            const lessonRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects/${currentBlueprintProjectId}/lessons`, topicId);
            const lessonSnap = await getDoc(lessonRef);
            if (lessonSnap.exists()) {
                const lesson = lessonSnap.data().content;
                const tempDiv = document.createElement('div');
                const extractText = (html) => { if (!html) return ''; tempDiv.innerHTML = html; return tempDiv.textContent || tempDiv.innerText || ''; };
                const lessonText = `${extractText(lesson.point)} ${extractText(lesson.memory)} ${extractText(lesson.summary)}`.trim();
                selectProjectAndGenerateBlueprintQuiz(fullTopicName, lessonText, topicId, false);
            } else {
                showMessage("ไม่พบข้อมูลเนื้อหาบทเรียนที่บันทึกไว้");
            }
        } catch (error) { 
            console.error("Error preparing content quiz:", error); 
            showMessage("เกิดข้อผิดพลาดในการเตรียมข้อมูลสำหรับสร้างแบบทดสอบ");
        }
    }
    else if (topicQuizBtn) {
        const fullTopicName = getFullTopicName(topicRow);
        selectProjectAndGenerateBlueprintQuiz(fullTopicName, null, topicId, false);
    }
    else if (viewBtn) {
        const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
        const docSnap = await getDoc(projectRef);
        if (docSnap.exists()) {
            const projectData = docSnap.data();
            const topicData = projectData.topics[topicId];
            if (topicData && topicData.status === 'generated') {
                try {
                    const lessonRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects/${currentBlueprintProjectId}/lessons`, topicId);
                    const lessonSnap = await getDoc(lessonRef);
                    if (lessonSnap.exists()) {
                        const lessonContent = lessonSnap.data().content;
                        document.getElementById('lesson-view-title').textContent = `บทเรียนเรื่อง: ${getFullTopicName(topicRow)}`;
                        document.getElementById('pointContent').innerHTML = lessonContent.point;
                        document.getElementById('memoryContent').innerHTML = lessonContent.memory;
                        document.getElementById('summaryContent').innerHTML = lessonContent.summary;
                        const applicationContentEl = document.getElementById('applicationContent');
                        if (lessonContent.applicationData) {
                            currentApplicationData = lessonContent.applicationData;
                            applicationContentEl.innerHTML = currentApplicationData.map((q, index) => `<div class="application-question mb-4"><p class="font-semibold">${index + 1}. ${marked.parseInline(q.question)}</p><div class="application-options mt-2" id="q${index}-options">${q.options.map((opt, optIndex) => `<button class="w-full text-left p-2 border rounded-md mt-1 hover:bg-gray-100" onclick="checkAnswer(${index}, ${optIndex})">${String.fromCharCode(97 + optIndex)}. ${marked.parseInline(opt)}</button>`).join('')}</div></div>`).join('');
                        } else {
                            currentApplicationData = [];
                            applicationContentEl.innerHTML = lessonContent.applicationHTML || lessonContent.application;
                        }
                        document.getElementById('lesson-loader').classList.add('hidden');
                        document.getElementById('lesson-sections-container').classList.remove('hidden');
                        document.getElementById('lesson-view-modal').classList.remove('hidden');
                        if (window.MathJax) { MathJax.typesetPromise([document.getElementById('lesson-view-content')]); }
                    } else { showMessage("ไม่พบข้อมูลบทเรียนที่บันทึกไว้ (อาจถูกลบไปแล้ว)"); }
                } catch (fetchError) { console.error("Error fetching lesson content:", fetchError); showMessage("เกิดข้อผิดพลาดในการดึงข้อมูลบทเรียน"); }
            } else { showMessage("ยังไม่มีข้อมูลบทเรียนที่สร้างไว้, กรุณากด 'สร้างใหม่'"); }
        }
    }
    else if (generateBtn) {
        const fullTopicName = getFullTopicName(topicRow);
        const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
        const docSnap = await getDoc(projectRef);
        if (docSnap.exists()) {
            const projectData = docSnap.data();
            generateAndSaveLessonForBlueprint(topicId, fullTopicName, projectData.gradeLevel);
        }
    }
    else if (editBtn) {
        editTopicInProject(topicId);
    }
    else if (deleteBtn) {
        deleteTopicFromProject(topicId);
    }
});
		
		document.getElementById('fix-lesson-latex-btn').addEventListener('click', handleFixLessonLatex);
		
		document.getElementById('export-lesson-to-pdf-btn').addEventListener('click', handleExportLessonToPDF);
		
		document.getElementById('close-lesson-view-btn').addEventListener('click', () => {
    document.getElementById('lesson-view-modal').classList.add('hidden');
});
		
const bulkConfidenceCheckbox = document.getElementById('bulk-confidence-scoring-checkbox');
const bulkConfidenceModeContainer = document.getElementById('bulk-confidence-mode-container');
bulkConfidenceCheckbox.addEventListener('change', () => {
    bulkConfidenceModeContainer.classList.toggle('hidden', !bulkConfidenceCheckbox.checked);
});

// Logic สำหรับหน้าตั้งค่าหลัก
const confidenceCheckbox = document.getElementById('confidence-scoring-checkbox');
const confidenceModeContainer = document.getElementById('confidence-mode-container');
confidenceCheckbox.addEventListener('change', () => {
    confidenceModeContainer.classList.toggle('hidden', !confidenceCheckbox.checked);
});

// Logic สำหรับ Modal
const modalConfidenceCheckbox = document.getElementById('modal-confidence-scoring-checkbox');
const modalConfidenceModeContainer = document.getElementById('modal-confidence-mode-container');
modalConfidenceCheckbox.addEventListener('change', () => {
    modalConfidenceModeContainer.classList.toggle('hidden', !modalConfidenceCheckbox.checked);
});

// ▲▲▲ สิ้นสุดส่วนที่เพิ่ม ▲▲▲
		
		// ▼▼▼ [START] เพิ่ม Event Listeners สำหรับ Confidence Modal ▼▼▼
const confidenceModal = document.getElementById('confidence-modal');
const handleConfidenceChoice = async (isConfident) => {
    const modal = document.getElementById('confidence-modal');
    const mode = modal.dataset.currentMode; // อ่านโหมดปัจจุบัน
    const hiddenInput = document.getElementById('selected-answer-index-hidden');
    
    modal.classList.add('hidden'); // ซ่อน Modal ก่อน

    if (mode === 'timed') {
        // === Logic สำหรับโหมดจับเวลารายข้อ ===
        const answerValue = hiddenInput.value;
        const answerData = {
            answer: answerValue,
            wasConfident: isConfident
        };
        // เรียกใช้ฟังก์ชันสำหรับไปข้อต่อไป
        proceedToNextQuestion(answerData);

    } else if (mode === 'sync') {
        // === Logic สำหรับ Sync Mode (โค้ดเดิมที่แก้ไขไปครั้งก่อน) ===
        const answerValue = hiddenInput.dataset.answerValue;
        const question = JSON.parse(hiddenInput.dataset.question);
        const gameData = JSON.parse(hiddenInput.dataset.gameData);
        const playerName = hiddenInput.dataset.playerName;

        // เรียกใช้ฟังก์ชันสำหรับส่งคำตอบใน Sync Mode
        handleSyncAnswerSubmit(answerValue, question, gameData, playerName, isConfident);
    }
    
    // เคลียร์ค่าโหมดหลังจากทำงานเสร็จ
    modal.dataset.currentMode = ''; 
};

document.getElementById('confirm-confident').addEventListener('click', () => handleConfidenceChoice(true));
document.getElementById('confirm-not-confident').addEventListener('click', () => handleConfidenceChoice(false));
// ▲▲▲ [END] สิ้นสุด Event Listeners สำหรับ Confidence Modal ▲▲▲
		
		liveGameView.addEventListener('click', (e) => {
    // ตรวจสอบว่าเป็นปุ่มลบผู้เล่นของ Sync Mode หรือไม่
    const kickBtn = e.target.closest('.kick-player-btn-sync');
    if (kickBtn) {
        const playerName = kickBtn.dataset.playerName;
        if (playerName) {
            handleKickPlayerSync(playerName);
        }
    }
});
		
		// ▼▼▼ วางโค้ดส่วนนี้ไว้บนสุดของฟังก์ชัน setupEventListeners ▼▼▼
const confirmGameStartBtn = document.getElementById('confirm-game-start-btn');
const cancelGameStartBtn = document.getElementById('cancel-game-start-btn');

cancelGameStartBtn.addEventListener('click', () => {
    document.getElementById('confirm-game-start-modal').classList.add('hidden');
});

confirmGameStartBtn.addEventListener('click', () => {
    const quizId = document.getElementById('game-start-quiz-id').value;
    const gameMode = document.getElementById('game-start-mode').value;
    const shouldSave = document.getElementById('save-game-results-checkbox').checked;

    // ซ่อน Modal ก่อนเริ่มเกม
    document.getElementById('confirm-game-start-modal').classList.add('hidden');

    // เรียกฟังก์ชันเริ่มเกมตาม mode ที่เก็บไว้
    switch(gameMode) {
        case 'live-race':
            handleStartLiveRace(quizId, shouldSave);
            break;
        case 'team':
            handleStartTeamQuiz(quizId, shouldSave);
            break;
        case 'group':
            handleStartGroupMode(quizId, shouldSave);
            break;
        case 'sync':
            // --- [ ส่วนที่แก้ไข ] ---
            // 1. อ่านค่าจาก Radio Button
            const selectedVariant = document.querySelector('input[name="syncVariant"]:checked').value || 'classic';
            // 2. ส่งค่า variant ไปด้วย
            handleStartSyncMode(quizId, shouldSave, selectedVariant); 
            // --- [ สิ้นสุดส่วนที่แก้ไข ] ---
            break;
    }
});
		
		document.getElementById('join-group-activity-btn').addEventListener('click', handleJoinGroupActivity);

liveGameView.addEventListener('click', (e) => {
    const barItem = e.target.closest('.summary-bar-item');

    // ซ่อน Tooltip อื่นๆ ทั้งหมดก่อน
    document.querySelectorAll('.live-summary-tooltip.visible').forEach(visibleTooltip => {
        // ถ้า tooltip ที่แสดงอยู่ไม่ใช่เป้าหมายของ bar ที่เพิ่งคลิก ให้ซ่อนมันไป
        if (!barItem || visibleTooltip.id !== barItem.dataset.tooltipTarget) {
            visibleTooltip.classList.remove('visible');
        }
    });

    // ถ้าไม่ได้คลิกที่แท่งกราฟ ก็ไม่ต้องทำอะไรต่อ
    if (!barItem) {
        return;
    }

    // หา ID ของ tooltip เป้าหมายจาก data attribute
    const tooltipId = barItem.dataset.tooltipTarget;
    const tooltip = document.getElementById(tooltipId);

    if (tooltip) {
        // สลับการแสดงผลของ tooltip ที่ถูกคลิก
        tooltip.classList.toggle('visible');
    }
});
		
		        liveGameView.addEventListener('click', (e) => {
            // ตรวจสอบว่าปุ่มที่ถูกคลิกคือปุ่ม "เตะ" หรือไม่
            if (e.target.classList.contains('kick-player-btn')) {
                const playerName = e.target.dataset.playerName;
                if (playerName) {
                    handleKickPlayer(playerName);
                }
            }
        });
		
		document.getElementById('project-title').addEventListener('focus', () => document.getElementById('save-project-name-btn').classList.remove('hidden'));
document.getElementById('save-project-name-btn').addEventListener('click', handleSaveProjectName);
document.getElementById('project-title').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); e.target.blur(); handleSaveProjectName(); } });
		
		document.getElementById('bulk-quiz-settings-btn').addEventListener('click', () => {
    document.getElementById('bulk-quiz-settings-modal').classList.remove('hidden');
});
document.getElementById('cancel-bulk-quiz-settings-btn').addEventListener('click', () => {
    document.getElementById('bulk-quiz-settings-modal').classList.add('hidden');
});
document.getElementById('confirm-bulk-quiz-settings-btn').addEventListener('click', handleBulkUpdateQuizSettings);
		
            // New unified mode switcher
            document.getElementById('mode-switcher-btn').addEventListener('click', handleModeSwitch);

document.getElementById('update-old-quizzes-btn').addEventListener('click', handleUpdateOldQuizzes);			
			document.getElementById('reset-project-order-btn').addEventListener('click', handleResetProjectOrder);
			document.getElementById('save-visibility-settings-btn').addEventListener('click', handleSaveVisibilitySettings);
			document.getElementById('add-custom-math-topic-btn').addEventListener('click', handleAddCustomMathTopic);
			
			document.getElementById('select-all-topics-btn').addEventListener('click', handleSelectAllTopics);
            document.getElementById('deselect-all-topics-btn').addEventListener('click', handleDeselectAllTopics);

// --- วางทับ Event Listener ของ back-to-dashboard-btn เดิมทั้งหมด ---
document.getElementById('back-to-dashboard-btn').addEventListener('click', () => {
    // [แก้ไข] เพิ่มเงื่อนไขเพื่อตรวจสอบ "ความจำ"
    if (cameFromBlueprint && currentBlueprintProjectId) {
        // ถ้ามาจาก Blueprint ให้กลับไปหน้า Blueprint Manager
        displayBlueprintProjectManager(currentBlueprintProjectId);
        cameFromBlueprint = false; // ล้างความจำทิ้ง
    } else {
        // ถ้าไม่ได้มาจาก Blueprint ให้ทำงานตามปกติ
        currentProjectId = null;
        currentProjectData = null;
        if (unsubscribeStudentsListener) unsubscribeStudentsListener();
        if (unsubscribeQuizzesListener) unsubscribeQuizzesListener();
        if (unsubscribeStudentProfilesListener) unsubscribeStudentProfilesListener();
        showView('admin-dashboard');
    }
});
// --- วางทับ Event Listener ของ back-to-project-btn เดิมทั้งหมด ---
document.getElementById('back-to-project-btn').addEventListener('click', () => {
    // [แก้ไข] เพิ่มเงื่อนไขเพื่อตรวจสอบ "ความจำ"
    if (cameFromBlueprint && currentBlueprintProjectId) {
        // ถ้ามาจาก Blueprint ให้กลับไปหน้า Blueprint Manager
        displayBlueprintProjectManager(currentBlueprintProjectId);
        cameFromBlueprint = false; // ล้างความจำทิ้ง
    } else {
        // ถ้าไม่ได้มาจาก Blueprint ให้ทำงานตามปกติ
        if (unsubscribeSubmissionsListener) unsubscribeSubmissionsListener();
        showView('project-detail');
    }
});

            document.getElementById('back-to-dashboard-from-results-btn').addEventListener('click', () => {
                showView('admin-dashboard');
            });
            
            // Modals
            // --- วางทับบรรทัดเดิม ---
document.getElementById('modal-close-btn').addEventListener('click', () => {
    // 1. ซ่อนหน้าต่าง Pop-up (ทำงานเหมือนเดิม)
    messageModal.classList.add('hidden');

    // 2. ตรวจสอบว่ามี "คำสั่งพิเศษ" ที่ต้องทำต่อหรือไม่
    if (typeof modalConfirmAction === 'function') {
        modalConfirmAction(); // 3. ถ้ามี ให้เรียกใช้คำสั่งนั้น!
        modalConfirmAction = null; // 4. ล้างคำสั่งทิ้ง เพื่อไม่ให้ทำงานซ้ำในครั้งต่อไป
    }
});
            document.getElementById('create-project-btn').addEventListener('click', () => createProjectModal.classList.remove('hidden'));
            document.getElementById('cancel-create-project-btn').addEventListener('click', () => createProjectModal.classList.add('hidden'));
            
            // Admin Password Modal
            document.getElementById('cancel-admin-login-btn').addEventListener('click', () => adminPasswordModal.classList.add('hidden'));
            document.getElementById('confirm-admin-login-btn').addEventListener('click', handleAdminLogin);
            document.getElementById('admin-password-input').addEventListener('keyup', (e) => {
                if (e.key === 'Enter') handleAdminLogin();
            });

            // Confirmation Modal
            document.getElementById('cancel-delete-btn').addEventListener('click', () => {
                confirmationModal.classList.add('hidden');
                if (typeof cancelAction === 'function') { // <-- เพิ่ม 2 บรรทัดนี้
                    cancelAction();
                }
                confirmAction = null;
                cancelAction = null; // <-- เพิ่มบรรทัดนี้
            });
            document.getElementById('confirm-delete-btn').addEventListener('click', () => {
                if (confirmAction) {
                    confirmAction();
                }
                confirmationModal.classList.add('hidden');
                confirmAction = null;
                cancelAction = null; // <-- เพิ่มบรรทัดนี้
            });

            // Modal Listeners
            document.getElementById('cancel-rename-quiz-btn').addEventListener('click', () => renameQuizModal.classList.add('hidden'));
            document.getElementById('confirm-rename-quiz-btn').addEventListener('click', confirmRenameQuiz);
            document.getElementById('cancel-move-quiz-btn').addEventListener('click', () => moveQuizModal.classList.add('hidden'));
            document.getElementById('confirm-move-quiz-btn').addEventListener('click', confirmMoveQuiz);
            document.getElementById('cancel-quiz-settings-btn').addEventListener('click', () => quizSettingsModal.classList.add('hidden'));
            document.getElementById('confirm-quiz-settings-btn').addEventListener('click', confirmQuizSettings);
            document.getElementById('cancel-quiz-status-btn').addEventListener('click', () => quizStatusModal.classList.add('hidden'));
            document.getElementById('confirm-quiz-status-btn').addEventListener('click', confirmQuizStatus);
			
			// ▼▼▼ นำโค้ดที่ถามมาวางต่อท้ายตรงนี้ได้เลยครับ ▼▼▼
const exportPdfModal = document.getElementById('export-pdf-modal');
// ปุ่มยกเลิก
document.getElementById('cancel-export-pdf-btn').addEventListener('click', () => {
    exportPdfModal.classList.add('hidden');
});
// ปุ่ม Export แบบกระชับ (2 คอลัมน์)
document.getElementById('export-compact-pdf-btn').addEventListener('click', async () => {
    const quizData = allQuizzes.find(q => q.id === actionTargetId);
    if (quizData) {
        currentQuizData = quizData; // ตั้งค่า quiz ที่จะ export
        exportQuizAsWorksheetPDF(); // เรียกใช้ฟังก์ชันเดิม
    } else {
        showMessage("ไม่พบข้อมูลแบบทดสอบ");
    }
    exportPdfModal.classList.add('hidden');
});
// ปุ่ม Export แบบติว (ข้อละหน้า)
document.getElementById('export-tutor-pdf-btn').addEventListener('click', async () => {
    const quizData = allQuizzes.find(q => q.id === actionTargetId);
    if (quizData) {
        currentQuizData = quizData; // ตั้งค่า quiz ที่จะ export
        exportQuizAsTutorPDF(); // เรียกใช้ฟังก์ชันใหม่
    } else {
        showMessage("ไม่พบข้อมูลแบบทดสอบ");
    }
    exportPdfModal.classList.add('hidden');
});
			
// ✅ โค้ดใหม่ที่แก้ไขแล้ว

// 1. เปลี่ยนปุ่มหน้า Dashboard หลักให้เรียกฟังก์ชันใหม่
const openGlobalActivityBtn = document.getElementById('open-global-live-btn');
openGlobalActivityBtn.innerHTML = '<i class="fas fa-play-circle mr-2"></i>เริ่มกิจกรรม'; // เปลี่ยนชื่อปุ่ม
openGlobalActivityBtn.addEventListener('click', openGlobalActivityModal); // เรียกฟังก์ชันใหม่

// 2. Event Listener สำหรับปุ่มปิดและช่องค้นหาใน Modal ใหม่
document.getElementById('cancel-global-activity-btn').addEventListener('click', () => {
    document.getElementById('global-activity-modal').classList.add('hidden');
});
document.getElementById('global-quiz-search-input').addEventListener('input', (e) => {
    renderGlobalActivityList(e.target.value);
});

// ✅ โค้ดที่แก้ไขแล้ว
// 3. Event Listener หลักสำหรับจัดการการคลิกปุ่มโหมดเกมทั้งหมด
document.getElementById('global-activity-quiz-list').addEventListener('click', (e) => {
    const gameBtn = e.target.closest('.game-start-btn');
    if (!gameBtn) return; // ถ้าไม่ได้คลิกที่ปุ่ม ให้หยุดทำงาน

    const quizId = gameBtn.dataset.id;
    const gameMode = gameBtn.dataset.mode;
    const quizData = allQuizzesGlobal.find(q => q.id === quizId);

    if (quizData) {
        // ซ่อนหน้าต่าง "เริ่มกิจกรรม" ก่อนเสมอ
        document.getElementById('global-activity-modal').classList.add('hidden');

        // --- [ ส่วนที่แก้ไข ] ---
        // 1. ตรวจสอบว่าปุ่มที่กดคือ 'live-race' หรือไม่
        if (gameMode === 'live-race') {
            // ถ้าใช่: ให้เริ่มเกมสดทันที โดยไม่ถามเรื่องการบันทึกคะแนน
            handleStartLiveRace(quizId);
        } else {
            // ถ้าเป็นโหมดอื่น (Team, Group, Sync): ให้แสดงหน้าต่างยืนยันตามปกติ
            showGameStartConfirmationModal(quizId, gameMode, quizData.topic);
        }
        // --- [ สิ้นสุดส่วนที่แก้ไข ] ---
    }
});
            // Search and Sort Listeners
            document.getElementById('project-search-input').addEventListener('input', renderProjects);
            // ในฟังก์ชัน setupEventListeners()
// โค้ดใหม่
document.getElementById('project-sort-select').addEventListener('change', async () => {
    const newSortValue = document.getElementById('project-sort-select').value;
    const settingsRef = doc(db, "globalSettings", "dashboardConfig");
    try {
        // อัปเดตค่าใน Firestore
        await setDoc(settingsRef, { projectSort: newSortValue }, { merge: true });
        // ไม่ต้องเรียก renderProjects() ที่นี่แล้ว เพราะ onSnapshot จะทำงานให้เอง
    } catch (error) {
        console.error("Error updating sort preference:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึกการจัดเรียง");
    }
});
            document.getElementById('quiz-search-input').addEventListener('input', renderQuizzes);

// ▼▼▼ เพิ่มโค้ดส่วนนี้เข้าไปใหม่ทั้งหมด ▼▼▼
document.getElementById('grid-view-btn').addEventListener('click', () => {
    globalDashboardSettings.projectView = 'grid';
    saveUserPreference('projectView', 'grid'); // บันทึกการตั้งค่า
    renderProjects(); // วาดหน้าจอใหม่
});

document.getElementById('list-view-btn').addEventListener('click', () => {
    globalDashboardSettings.projectView = 'list';
    saveUserPreference('projectView', 'list'); // บันทึกการตั้งค่า
    renderProjects(); // วาดหน้าจอใหม่
});
// ▲▲▲ สิ้นสุดส่วนที่เพิ่ม ▲▲▲

            // Project Detail Tabs
            manageTab.addEventListener('click', () => switchProjectTab('manage'));
            resultsTab.addEventListener('click', () => switchProjectTab('results'));
            leaderboardTab.addEventListener('click', () => switchProjectTab('leaderboard'));

            // Quiz Results Tabs
            document.getElementById('analytics-tab-btn').addEventListener('click', () => switchQuizDetailTab('analytics'));
            document.getElementById('scores-tab-btn').addEventListener('click', () => switchQuizDetailTab('scores'));
            document.getElementById('leaderboard-quiz-tab-btn').addEventListener('click', () => switchQuizDetailTab('leaderboard-quiz'));
			
			document.getElementById('behavior-log-tab-btn').addEventListener('click', () => switchQuizDetailTab('behavior-log')); // <-- เพิ่มบรรทัดนี้
			
            document.getElementById('analyze-strengths-btn').addEventListener('click', handleAnalyzeClass);
            generateWorksheetBtn.addEventListener('click', generateWorksheet);
            
            // --- START: โค้ดที่เพิ่มสำหรับฟีเจอร์ "สร้างจากลิงก์" ---
            const linkTab = document.getElementById('link-tab');
            const linkInputArea = document.getElementById('link-input-area');
            
            // --- ▼▼▼ [ประกาศตัวแปร UI ใหม่] ▼▼▼ ---
            const blueprintTab = document.getElementById('blueprint-tab');
            const blueprintInputArea = document.getElementById('blueprint-input-area');
            // --- ▲▲▲ [สิ้นสุดการประกาศตัวแปร] ▲▲▲ ---
			
            // --- ▼▼▼ [START OF FIX] ประกาศตัวแปรสำหรับ "สร้างข้อสอบคู่ขนาน" ---
			const parallelTestTab = document.getElementById('parallel-test-tab');
            const parallelTestInputArea = document.getElementById('parallel-test-input-area');
            // --- [END OF FIX] ---

            // Generation Tabs
            topicTab.addEventListener('click', () => {
                // Activate this tab
                topicTab.classList.add('active');
                // Deactivate others
                textTab.classList.remove('active');
                fileTab.classList.remove('active');
                worksheetTab.classList.remove('active');
                if(linkTab) linkTab.classList.remove('active');
                if(blueprintTab) blueprintTab.classList.remove('active');
                if(parallelTestTab) parallelTestTab.classList.remove('active'); // ▼▼▼ [FIX] Deactivate parallel tab

                // Show this panel
                topicInputArea.classList.remove('hidden');
                // Hide others
                textInputArea.classList.add('hidden');
                fileInputArea.classList.add('hidden');
                worksheetInputArea.classList.add('hidden');
                if(linkInputArea) linkInputArea.classList.add('hidden');
                if(blueprintInputArea) blueprintInputArea.classList.add('hidden');
                if(parallelTestInputArea) parallelTestInputArea.classList.add('hidden'); // ▼▼▼ [FIX] Hide parallel panel
            });

            textTab.addEventListener('click', () => {
                // Activate this tab
                textTab.classList.add('active');
                // Deactivate others
                topicTab.classList.remove('active');
                fileTab.classList.remove('active');
                worksheetTab.classList.remove('active');
                if(linkTab) linkTab.classList.remove('active');
                if(blueprintTab) blueprintTab.classList.remove('active');
                if(parallelTestTab) parallelTestTab.classList.remove('active'); // ▼▼▼ [FIX] Deactivate parallel tab

                // Show this panel
                textInputArea.classList.remove('hidden');
                // Hide others
                topicInputArea.classList.add('hidden');
                fileInputArea.classList.add('hidden');
                worksheetInputArea.classList.add('hidden');
                if(linkInputArea) linkInputArea.classList.add('hidden');
                if(blueprintInputArea) blueprintInputArea.classList.add('hidden');
                if(parallelTestInputArea) parallelTestInputArea.classList.add('hidden'); // ▼▼▼ [FIX] Hide parallel panel
            });

            fileTab.addEventListener('click', () => {
                // Activate this tab
                fileTab.classList.add('active');
                // Deactivate others
                topicTab.classList.remove('active');
                textTab.classList.remove('active');
                worksheetTab.classList.remove('active');
                if(linkTab) linkTab.classList.remove('active');
                if(blueprintTab) blueprintTab.classList.remove('active');
                if(parallelTestTab) parallelTestTab.classList.remove('active'); // ▼▼▼ [FIX] Deactivate parallel tab
                
                // Show this panel
                fileInputArea.classList.remove('hidden');
                // Hide others
                topicInputArea.classList.add('hidden');
                textInputArea.classList.add('hidden');
                worksheetInputArea.classList.add('hidden');
                if(linkInputArea) linkInputArea.classList.add('hidden');
                if(blueprintInputArea) blueprintInputArea.classList.add('hidden');
                if(parallelTestInputArea) parallelTestInputArea.classList.add('hidden'); // ▼▼▼ [FIX] Hide parallel panel
            });
            
            worksheetTab.addEventListener('click', () => {
                // Activate this tab
                worksheetTab.classList.add('active');
                // Deactivate others
                topicTab.classList.remove('active');
                textTab.classList.remove('active');
                fileTab.classList.remove('active');
                if(linkTab) linkTab.classList.remove('active');
                if(blueprintTab) blueprintTab.classList.remove('active');
                if(parallelTestTab) parallelTestTab.classList.remove('active'); // ▼▼▼ [FIX] Deactivate parallel tab

                // Show this panel
                worksheetInputArea.classList.remove('hidden');
                // Hide others
                topicInputArea.classList.add('hidden');
                textInputArea.classList.add('hidden');
                fileInputArea.classList.add('hidden');
                if(linkInputArea) linkInputArea.classList.add('hidden');
                if(blueprintInputArea) blueprintInputArea.classList.add('hidden');
                if(parallelTestInputArea) parallelTestInputArea.classList.add('hidden'); // ▼▼▼ [FIX] Hide parallel panel
            });

            const bankTab = document.getElementById('bank-tab');
            const bankInputArea = document.getElementById('bank-input-area');

            if(bankTab) {
                bankTab.addEventListener('click', () => {
                    // Deactivate other tabs
                    topicTab.classList.remove('active');
                    textTab.classList.remove('active');
                    fileTab.classList.remove('active');
                    worksheetTab.classList.remove('active');
                    if(linkTab) linkTab.classList.remove('active');
                    if(blueprintTab) blueprintTab.classList.remove('active');
                    if(parallelTestTab) parallelTestTab.classList.remove('active'); // ▼▼▼ [FIX] Deactivate parallel tab
                    
                    // Activate this tab
                    bankTab.classList.add('active');

                    // Hide other input areas
                    topicInputArea.classList.add('hidden');
                    textInputArea.classList.add('hidden');
                    fileInputArea.classList.add('hidden');
                    worksheetInputArea.classList.add('hidden');
                    if(linkInputArea) linkInputArea.classList.add('hidden');
                    if(blueprintInputArea) blueprintInputArea.classList.add('hidden');
                    if(parallelTestInputArea) parallelTestInputArea.classList.add('hidden'); // ▼▼▼ [FIX] Hide parallel panel

                    // Show this input area and load the questions
                    bankInputArea.classList.remove('hidden');
                    displayQuestionBank(); 
                });
            }

            if(linkTab) {
                linkTab.addEventListener('click', () => {
                    // Activate this tab
                    linkTab.classList.add('active');
                    // Deactivate others
                    topicTab.classList.remove('active');
                    textTab.classList.remove('active');
                    fileTab.classList.remove('active');
                    worksheetTab.classList.remove('active');
                    if(blueprintTab) blueprintTab.classList.remove('active');
                    if(parallelTestTab) parallelTestTab.classList.remove('active'); // ▼▼▼ [FIX] Deactivate parallel tab

                    // Show this panel
                    linkInputArea.classList.remove('hidden');
                    // Hide others
                    topicInputArea.classList.add('hidden');
                    textInputArea.classList.add('hidden');
                    fileInputArea.classList.add('hidden');
                    worksheetInputArea.classList.add('hidden');
                    if(blueprintInputArea) blueprintInputArea.classList.add('hidden');
                    if(parallelTestInputArea) parallelTestInputArea.classList.add('hidden'); // ▼▼▼ [FIX] Hide parallel panel
                });
                document.getElementById('generate-from-link-btn').addEventListener('click', handleGenerateFromLink);
            }
            // --- END: โค้ดที่เพิ่มสำหรับฟีเจอร์ "สร้างจากลิงก์" ---

            // --- ▼▼▼ [เพิ่ม Event Listener สำหรับแท็บ Blueprint ใหม่ทั้งหมด] ▼▼▼ ---
            if(blueprintTab) {
                blueprintTab.addEventListener('click', () => {
                    // Activate this tab
                    blueprintTab.classList.add('active');
                    // Deactivate other tabs
                    topicTab.classList.remove('active');
                    textTab.classList.remove('active');
                    fileTab.classList.remove('active');
                    worksheetTab.classList.remove('active');
                    if(linkTab) linkTab.classList.remove('active');
                    if(bankTab) bankTab.classList.remove('active');
                    if(parallelTestTab) parallelTestTab.classList.remove('active'); // ▼▼▼ [FIX] Deactivate parallel tab
                    
                    // Show this input area
                    blueprintInputArea.classList.remove('hidden');
                    // Hide other input areas
                    topicInputArea.classList.add('hidden');
                    textInputArea.classList.add('hidden');
                    fileInputArea.classList.add('hidden');
                    worksheetInputArea.classList.add('hidden');
                    if(linkInputArea) linkInputArea.classList.add('hidden');
                    if(bankInputArea) bankInputArea.classList.add('hidden');
                    if(parallelTestInputArea) parallelTestInputArea.classList.add('hidden'); // ▼▼▼ [FIX] Hide parallel panel
                });
            }
			
			// --- ▼▼▼ [START OF FIX] แก้ไข Event Listener ของ "สร้างข้อสอบคู่ขนาน" ---
            if(parallelTestTab) {
                parallelTestTab.addEventListener('click', () => {
                    // Activate this tab
                    parallelTestTab.classList.add('active');
                    // Deactivate other tabs
                    topicTab.classList.remove('active');
                    textTab.classList.remove('active');
                    fileTab.classList.remove('active');
                    worksheetTab.classList.remove('active');
                    if(linkTab) linkTab.classList.remove('active');
                    if(blueprintTab) blueprintTab.classList.remove('active');
                    if(bankTab) bankTab.classList.remove('active');

                    // Show this input area
                    parallelTestInputArea.classList.remove('hidden');
                    // Hide other input areas
                    topicInputArea.classList.add('hidden');
                    textInputArea.classList.add('hidden');
                    fileInputArea.classList.add('hidden');
                    worksheetInputArea.classList.add('hidden');
                    if(linkInputArea) linkInputArea.classList.add('hidden');
                    if(blueprintInputArea) blueprintInputArea.classList.add('hidden');
                    if(bankInputArea) bankInputArea.classList.add('hidden');
                });
            }
            // --- [END OF FIX] ---

            const blueprintUploadInput = document.getElementById('blueprint-upload-input');
            const generateFromBlueprintBtn = document.getElementById('generate-from-blueprint-btn');
            
            if (blueprintUploadInput) {
// ▼▼▼ START: วางทับ Event Listener ของ blueprintUploadInput เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
const blueprintUploadInput = document.getElementById('blueprint-upload-input');
const generateFromBlueprintBtn = document.getElementById('generate-from-blueprint-btn');
const blueprintOptionsContainer = document.getElementById('blueprint-options-container');
const separateContentCheckbox = document.getElementById('separate-by-content-checkbox');
const topicsListContainer = document.getElementById('blueprint-topics-list-container');
const topicsListDiv = document.getElementById('blueprint-topics-list');

if (blueprintUploadInput) {
    blueprintUploadInput.addEventListener('change', async (event) => {
        // ซ่อนตัวเลือกเก่าเมื่อมีการอัปโหลดไฟล์ใหม่
        blueprintOptionsContainer.classList.add('hidden');
        topicsListContainer.classList.add('hidden');
        separateContentCheckbox.checked = false;
        generateFromBlueprintBtn.disabled = true;

        const file = event.target.files[0];
        if (file) {
            // เปิดปุ่มสร้างหลัก
            generateFromBlueprintBtn.disabled = false;
            try {
                // เริ่มกระบวนการวิเคราะห์หัวข้อจากไฟล์ PDF
                const pdfText = await extractTextFromPdf(file);
                await analyzeBlueprintForTopics(pdfText); // ฟังก์ชันใหม่
            } catch (e) {
                showMessage('ไม่สามารถอ่านไฟล์ PDF เพื่อวิเคราะห์หัวข้อได้');
                blueprintOptionsContainer.classList.add('hidden');
            }
        }
    });
}

// Event Listener สำหรับ Checkbox "สร้างแยกตามเนื้อหา"
if (separateContentCheckbox) {
    separateContentCheckbox.addEventListener('change', (event) => {
        const isChecked = event.target.checked;
        // แสดง/ซ่อนรายการหัวข้อ
        topicsListContainer.classList.toggle('hidden', !isChecked);
        // ปิด/เปิดปุ่มสร้างหลัก
        generateFromBlueprintBtn.disabled = isChecked;
    });
}

// Event Listener (Delegation) สำหรับปุ่มเลือกหัวข้อ
if (topicsListDiv) {
// ▼▼▼ START: วางทับ Event Listener ของ topicsListDiv เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
if (topicsListDiv) {
    topicsListDiv.addEventListener('click', (event) => {
        const quizBtn = event.target.closest('.topic-selection-btn');
        const contentBtn = event.target.closest('.generate-content-btn');

        if (quizBtn) {
            // ถ้าคลิกปุ่ม "สร้างแบบทดสอบ"
            const topic = unescape(quizBtn.dataset.topic);
            generateQuizForSingleTopic(topic);
        } else if (contentBtn) {
            // ถ้าคลิกปุ่ม "สร้างเนื้อหาสำหรับสอน"
            const topic = unescape(contentBtn.dataset.topic);
            handleGenerateTeachingContent(topic);
        }
    });
}
// ▲▲▲ END: สิ้นสุดการวางทับ ▲▲▲
}
// ▲▲▲ END: สิ้นสุดการวางทับ ▲▲▲
            }
        
            if (generateFromBlueprintBtn) {
                generateFromBlueprintBtn.addEventListener('click', handleGenerateFromBlueprint);
            }
            // --- ▲▲▲ [สิ้นสุดส่วนของ Blueprint] ▲▲▲ ---
			
			// === เพิ่มโค้ดส่วนนี้เข้าไปใหม่ทั้งหมด ===
            const parallelTestUploadInput = document.getElementById('parallel-test-upload-input');
            const generateFromParallelTestBtn = document.getElementById('generate-from-parallel-test-btn');

            if (parallelTestUploadInput) {
                parallelTestUploadInput.addEventListener('change', (event) => {
                    // เปิด/ปิดปุ่มตามการเลือกไฟล์
                    generateFromParallelTestBtn.disabled = event.target.files.length === 0;
                });
            }

            if (generateFromParallelTestBtn) {
                generateFromParallelTestBtn.addEventListener('click', () => {
                    // เรียกใช้ฟังก์ชันโดยไม่ส่งค่าใดๆ เข้าไป
                    handleGenerateParallelTest(); 
                });
            }

            // Student flow buttons
            loadQuizBtn.addEventListener('click', handleLoadQuiz);
// ▼▼▼ วางทับ event listener ของปุ่ม startQuizBtn เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
startQuizBtn.addEventListener('click', async () => {
    const studentNameSelect = document.getElementById('student-name-select');
    currentStudentName = studentNameSelect.value;
    if (!currentStudentName) {
        showMessage("กรุณาเลือกชื่อของคุณ");
        return;
    }

    try {
        const quizId = currentQuizData.id;
        const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`, currentStudentName);
        
        // --- ส่วนที่แก้ไข ---
        // 1. ตรวจสอบก่อนว่ามีข้อมูลการส่งเก่าอยู่แล้วหรือไม่
        const submissionSnap = await getDoc(submissionRef);

        if (!submissionSnap.exists()) {
            // 2. ถ้ายังไม่เคยส่งเลย ให้สร้างเอกสารใหม่พร้อม attempts: []
            await setDoc(submissionRef, {
                studentName: currentStudentName,
                startedAt: new Date().toISOString(),
                behaviorLog: [],
                attempts: []
            });
        } else {
            // 3. ถ้าเคยส่งแล้ว ให้อัปเดตแค่เวลาที่เริ่มล่าสุด โดยไม่ไปยุ่งกับ array 'attempts'
            await updateDoc(submissionRef, {
                startedAt: new Date().toISOString()
            });
        }
        // --- สิ้นสุดส่วนที่แก้ไข ---

    } catch (error) {
        console.error("Failed to create/update submission record:", error);
        showMessage("เกิดข้อผิดพลาดในการเริ่มทำข้อสอบ กรุณาลองใหม่อีกครั้ง");
        return;
    }

    studentNameSelectionView.classList.add('hidden');
    quizStartTime = new Date();
    displayQuizForStudent(currentQuizData);
});
            // NEW: Live Game Listeners
            document.getElementById('join-live-game-btn').addEventListener('click', showJoinGameView);
            document.getElementById('confirm-join-game-btn').addEventListener('click', handleJoinLiveGame);
            document.getElementById('back-to-student-initial-btn').addEventListener('click', () => showView('student'));


            // === START: อัปเดตส่วน Event Listeners ของปุ่ม Export ทั้งหมด ===
            
            // Helper function for Scores Table filename
            const getResultsFilename = () => {
                const quizTitle = document.getElementById('results-quiz-title').textContent.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                return `results_${quizTitle || 'quiz'}`;
            };
			
			// เพิ่ม Event Listener สำหรับช่องค้นหาหัวข้อคณิตศาสตร์
            // ▼▼▼ นำโค้ดบล็อกนี้ไปแทนที่ของเดิมทั้งหมด ▼▼▼
const topicSearchInput = document.getElementById('math-topic-search-input');
if (topicSearchInput) {
    topicSearchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase().trim();
        const checkboxContainer = document.getElementById('math-topics-checkbox-container');
        
        // วนลูปจัดการแต่ละหมวดหมู่
        const categories = checkboxContainer.querySelectorAll('.topic-category');
        categories.forEach(category => {
            let categoryHasVisibleTopic = false;
            
            // วนลูปจัดการแต่ละ "บรรทัด" ของหัวข้อ
            const topicRows = category.querySelectorAll('.topic-row');
            topicRows.forEach(row => {
                const topicName = row.querySelector('.topic-name-display').textContent.toLowerCase();
                
                if (topicName.includes(searchTerm)) {
                    row.style.display = 'flex'; // แสดงทั้งบรรทัด
                    categoryHasVisibleTopic = true;
                } else {
                    row.style.display = 'none'; // ซ่อนทั้งบรรทัด
                }
            });

            // ซ่อน/แสดงชื่อหมวดหมู่
            if (categoryHasVisibleTopic) {
                category.style.display = 'block';
            } else {
                category.style.display = 'none';
            }
        });
    });
}
// ▲▲▲ สิ้นสุดการแทนที่ ▲▲▲

            // Export buttons for Scores Table (CHANGED)
            document.getElementById('export-image-btn').addEventListener('click', () => exportTableAsImage('results-table-container', getResultsFilename()));
            document.getElementById('export-pdf-btn').addEventListener('click', () => exportTableAsPDF('results-table', getResultsFilename()));
            document.getElementById('export-word-btn').addEventListener('click', () => exportTableAsWord('results-table-container', getResultsFilename()));
            document.getElementById('export-excel-btn').addEventListener('click', () => exportTableAsExcel('results-table', getResultsFilename()));
            
            // Helper function for Leaderboard Table filename
            const getLeaderboardFilename = () => {
                const quizTitle = document.getElementById('results-quiz-title').textContent.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                return `leaderboard_${quizTitle || 'quiz'}`;
            };
            
            // Export buttons for Leaderboard Table (NEW)
            document.getElementById('export-leaderboard-image-btn').addEventListener('click', () => exportTableAsImage('quiz-leaderboard-table-container', getLeaderboardFilename()));
            document.getElementById('export-leaderboard-pdf-btn').addEventListener('click', () => exportTableAsPDF('quiz-leaderboard-table', getLeaderboardFilename()));
            document.getElementById('export-leaderboard-word-btn').addEventListener('click', () => exportTableAsWord('quiz-leaderboard-table-container', getLeaderboardFilename()));
            document.getElementById('export-leaderboard-excel-btn').addEventListener('click', () => exportTableAsExcel('quiz-leaderboard-table', getLeaderboardFilename()));
            
            // === END: อัปเดตส่วน Event Listeners ของปุ่ม Export ทั้งหมด ===



// ▼▼▼ วางทับ event listener ของ projectQuizzesList เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
projectQuizzesList.addEventListener('click', async (e) => {
    // 1. ประกาศตัวแปรสำหรับปุ่มทั้งหมด
    const mainCard = e.target.closest('.quiz-result-card');
    const postTestBtn = e.target.closest('.generate-post-test-btn');
    const compareBtn = e.target.closest('.compare-results-btn');
    const lessonBtn = e.target.closest('.generate-lesson-btn');
    const starBtn = e.target.closest('.star-quiz-btn');
    const copyBtn = e.target.closest('.copy-quiz-id-list-btn');
    const editBtn = e.target.closest('.edit-quiz-btn');
    const settingsBtn = e.target.closest('.quiz-settings-btn');
    const duplicateBtn = e.target.closest('.duplicate-quiz-btn');
    const renameBtn = e.target.closest('.rename-quiz-btn');
    const parallelBtn = e.target.closest('.parallel-quiz-btn');
    const moveBtn = e.target.closest('.move-quiz-btn');
    const pairBtn = e.target.closest('.pair-quiz-btn');
    const unpairBtn = e.target.closest('.unpair-quiz-btn');
    const presentBtn = e.target.closest('.start-presentation-list-btn');
    const tryQuizBtn = e.target.closest('.admin-try-quiz-list-btn');
    const exportPdfBtn = e.target.closest('.export-pdf-list-btn');
    const deleteBtn = e.target.closest('.delete-quiz-btn');
    const statusBtn = e.target.closest('.quiz-status-btn');
    const toggleBtn = e.target.closest('.toggle-actions-btn');
    const easyBtn = e.target.closest('.generate-easy-version-btn');
	const easyParallelBtn = e.target.closest('.generate-easy-parallel-btn');
    
    // ปุ่มสำหรับโหมดเกม
    const gameBtn = e.target.closest('.start-game-btn');
    const liveRaceBtn = e.target.closest('.start-live-race-btn');

    // 2. ตรรกะการทำงานของปุ่ม
    if (gameBtn) {
        // --- [START] จุดที่แก้ไข ---
        const quizId = gameBtn.dataset.quizId; // แก้จาก .id เป็น .quizId
        const mode = gameBtn.dataset.mode;
        const quizData = allQuizzes.find(q => q.id === quizId);
        // --- [END] สิ้นสุดจุดที่แก้ไข ---
        if (quizData) {
            showGameStartConfirmationModal(quizId, mode, quizData.topic);
        }
    } 
else if (liveRaceBtn) {
    const quizId = liveRaceBtn.dataset.quizId;
    // เรียกฟังก์ชันเริ่มเกมสดโดยตรง ไม่ต้องแสดงป๊อปอัป
    handleStartLiveRace(quizId);
}
    else if (toggleBtn) {
        const quizId = toggleBtn.dataset.quizId;
        const container = document.getElementById(`actions-container-${quizId}`);
        if (container) {
            container.classList.toggle('hidden');
        }
    }
    else if (postTestBtn) {
        const quizId = postTestBtn.dataset.quizId;
        const quizData = allQuizzes.find(q => q.id === quizId);
        if (quizData) { handleGenerateParallelPostTest(quizData); }
    }
    else if (compareBtn) {
        handleCompareResults(compareBtn.dataset.quizId, compareBtn.dataset.preTestId);
    }
    else if (lessonBtn) {
        const quizId = lessonBtn.dataset.quizId;
        const quizData = allQuizzes.find(q => q.id === quizId);
        if (quizData && quizData.lessonPlan) {
            displayLessonPlan(quizData.lessonPlan, quizData);
            showConfirmation('แสดงแผนการสอนที่บันทึกไว้แล้ว หากต้องการสร้างใหม่เนื่องจากมีผู้สอบเพิ่ม กรุณากด "สร้างใหม่"', () => handleGenerateLessonPlan(quizId));
            document.getElementById('confirmation-modal').querySelector('h3').textContent = 'แผนการสอน';
            document.getElementById('confirm-delete-btn').textContent = 'สร้างใหม่';
        } else {
            handleGenerateLessonPlan(quizId);
        }
    }
    else if (starBtn) { handleToggleStarQuiz(starBtn.dataset.quizId); }
    else if (copyBtn) { copyTextToClipboard(copyBtn.dataset.quizId, "คัดลอกรหัสแล้ว!"); }
    else if (editBtn) { handleOpenQuizEditor(editBtn.dataset.quizId); }
    else if (settingsBtn) { handleQuizSettings(settingsBtn.dataset.quizId); }
    else if (duplicateBtn) { handleDuplicateQuiz(duplicateBtn.dataset.quizId); }
    else if (renameBtn) { handleRenameQuiz(renameBtn.dataset.quizId, renameBtn.dataset.topic); }
    else if (parallelBtn) {
        const quizId = parallelBtn.dataset.quizId;
        const quizData = allQuizzes.find(q => q.id === quizId);
        if (quizData) { handleGenerateParallelFromBank(quizData); }
    }
    else if (moveBtn) { handleMoveQuiz(moveBtn.dataset.quizId); }
    else if (pairBtn) { handleManualQuizPairing(pairBtn.dataset.quizId); }
    else if (unpairBtn) { handleUnpairQuiz(unpairBtn.dataset.quizId); }
    else if (presentBtn) {
        const quizId = presentBtn.dataset.quizId;
        const quizData = allQuizzes.find(q => q.id === quizId);
        if (quizData) startPresentation(quizData);
    }
    else if (tryQuizBtn) {
        const quizId = tryQuizBtn.dataset.quizId;
        const quizData = allQuizzes.find(q => q.id === quizId);
        if (quizData) { currentQuizData = quizData; startAdminTest(); }
    }
    else if (exportPdfBtn) {
        actionTargetId = exportPdfBtn.dataset.quizId;
        document.getElementById('export-pdf-modal').classList.remove('hidden');
    }
    else if (deleteBtn) {
        showConfirmation(`คุณแน่ใจหรือไม่ว่าต้องการลบแบบทดสอบ "${deleteBtn.dataset.topic}"? ข้อมูลทั้งหมดจะถูกลบอย่างถาวร`, () => handleDeleteQuiz(deleteBtn.dataset.quizId));
    }
    else if (statusBtn) { handleQuizStatus(statusBtn.dataset.quizId); }
    else if (easyBtn) {
        handleGenerateEasyVersionQuiz(easyBtn.dataset.quizId);
    }
	
	else if (easyParallelBtn) {
    handleGenerateEasyParallelQuiz(easyParallelBtn.dataset.quizId);
}
	
    else if (mainCard) { showQuizDetailView(mainCard.dataset.quizId); }
});

    // Student: ปุ่มในหน้าเลือกผู้เล่น
    document.getElementById('cancel-team-selection-btn').addEventListener('click', () => showView('student'));
    document.getElementById('confirm-team-players-btn').addEventListener('click', confirmAndStartTeamQuiz);
            document.getElementById('quiz-leaderboard-table').querySelector('thead').addEventListener('click', (e) => {
                const header = e.target.closest('.sortable-header');
                if (!header || !header.dataset.sort) return;

                const newSortBy = header.dataset.sort;
                if (quizLeaderboardSortBy === newSortBy) {
                    // ถ้าคลิกหัวข้อเดิม ให้สลับทิศทาง
                    quizLeaderboardSortOrder = quizLeaderboardSortOrder === 'asc' ? 'desc' : 'asc';
                } else {
                    // ถ้าคลิกหัวข้อใหม่
                    quizLeaderboardSortBy = newSortBy;
                    // ตั้งค่าทิศทางเริ่มต้นสำหรับแต่ละประเภทข้อมูล
                    const textBasedSort = ['studentName'];
                    quizLeaderboardSortOrder = textBasedSort.includes(newSortBy) ? 'asc' : 'desc';
                }
                // สั่งให้วาดตารางใหม่ด้วยข้อมูลล่าสุดและการจัดเรียงใหม่
                renderQuizLeaderboard(currentSubmissions, currentQuizData, 'quiz-leaderboard-table-body');
            });

            // Presentation Mode Listeners
            document.getElementById('close-presentation-btn').addEventListener('click', closePresentation);
            document.getElementById('prev-question-btn').addEventListener('click', () => {
                if (currentPresentationSlide > 0) {
                    currentPresentationSlide--;
                    renderPresentationSlide(currentPresentationSlide);
                }
            });
            document.getElementById('next-question-btn').addEventListener('click', () => {
                if (currentQuizData.questions && currentPresentationSlide < currentQuizData.questions.length - 1) {
                    currentPresentationSlide++;
                    renderPresentationSlide(currentPresentationSlide);
                }
            });
            // Handle exiting fullscreen with ESC key
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    presentationModal.style.display = 'none';
                }
            });
            
            // Student Deletion Listeners
            document.getElementById('delete-all-students-btn').addEventListener('click', handleDeleteAllStudents);
            studentList.addEventListener('click', (e) => {
                const deleteBtn = e.target.closest('.delete-student-btn');
                if (deleteBtn) {
                    const studentName = deleteBtn.dataset.studentName;
                    handleDeleteStudent(studentName);
                }
            });
            
            // --- โค้ดใหม่สำหรับจัดการการเลือกไฟล์และคลิกปุ่ม ---

            // 1. เพิ่ม Listener ให้กับปุ่ม "สร้างแบบทดสอบ" ใหม่ของเรา
            document.getElementById('generate-from-file-btn').addEventListener('click', handleGenerateFromFileClick);

            // 2. เปลี่ยน Listener ของช่องเลือกไฟล์ ให้ทำงานแค่เก็บไฟล์และเปิด/ปิดปุ่ม
// ▼▼▼ START: วางทับ Event Listener ของ fileUploadInput เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
fileUploadInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    const generateBtn = document.getElementById('generate-from-file-btn');
    const topicsListContainer = document.getElementById('file-topics-list-container');
    const separateContentCheckbox = document.getElementById('separate-by-content-from-file-checkbox');
    
    // [เพิ่มใหม่] ตัวแปรช่องเลือกหน้า
    const pageSelector = document.getElementById('pdf-page-selector');

    if (file) {
        selectedFile = file;
        
        // [เพิ่มใหม่] ถ้าเป็น PDF ให้โชว์ช่องเลือกหน้า
        if (file.type === 'application/pdf') {
            pageSelector.classList.remove('hidden');
        } else {
            pageSelector.classList.add('hidden');
            document.getElementById('pdf-page-range').value = ''; // เคลียร์ค่า
        }

        if (separateContentCheckbox.checked) {
            generateBtn.disabled = true;
            analyzeFileForTopics(file);
        } else {
            generateBtn.disabled = false;
            topicsListContainer.classList.add('hidden');
        }
    } else {
        selectedFile = null;
        generateBtn.disabled = true;
        topicsListContainer.classList.add('hidden');
        pageSelector.classList.add('hidden'); // [เพิ่มใหม่] ซ่อนเมื่อไม่มีไฟล์
    }
});

// เพิ่ม Event Listener ให้กับ Checkbox
document.getElementById('separate-by-content-from-file-checkbox').addEventListener('change', (event) => {
    const isChecked = event.target.checked;
    const generateBtn = document.getElementById('generate-from-file-btn');
    const topicsListContainer = document.getElementById('file-topics-list-container');

    if (isChecked) {
        // ถ้าผู้ใช้ติ๊ก checkbox
        generateBtn.disabled = true; // ปิดปุ่มสร้างหลัก
        if (selectedFile) {
            // ถ้ามีไฟล์อัปโหลดอยู่แล้ว ให้เริ่มวิเคราะห์ทันที
            analyzeFileForTopics(selectedFile);
        } else {
            // ถ้ายังไม่มีไฟล์ ให้แสดงข้อความรอ
            topicsListContainer.classList.remove('hidden');
            document.getElementById('file-topics-list').innerHTML = '<p class="text-gray-400 text-center">กรุณาอัปโหลดไฟล์เพื่อเริ่มการวิเคราะห์...</p>';
        }
    } else {
        // ถ้าผู้ใช้เอาติ๊กออก
        topicsListContainer.classList.add('hidden'); // ซ่อนรายการหัวข้อ
        generateBtn.disabled = !selectedFile; // เปิดปุ่มสร้างหลัก (ถ้ามีไฟล์)
    }
});

// โค้ดที่แก้ไขแล้ว
document.getElementById('file-topics-list-container').addEventListener('click', (event) => {
    const quizBtn = event.target.closest('.file-topic-selection-btn');
    const contentBtn = event.target.closest('.generate-content-btn');

    if (quizBtn) {
        const topic = unescape(quizBtn.dataset.topic);
        generateHybridQuizForTopic(topic);

    } else if (contentBtn) {
        // --- นี่คือส่วนที่แก้ไข ---
        const topic = unescape(contentBtn.dataset.topic);
        // ดึงค่าระดับชั้น/ความยากจาก dropdown ที่มีอยู่แล้ว
        const gradeLevel = document.getElementById('difficulty-level-select').value;
        // เรียกใช้ฟังก์ชันที่สร้างบทเรียนเต็มรูปแบบ 4 ส่วน
        handleGenerateAndShowLesson(topic, gradeLevel);
    }
});

            document.getElementById('timer-mode-select').addEventListener('change', (e) => {
                const durationContainer = document.getElementById('timer-duration-container');
                const durationLabel = document.getElementById('timer-duration-label');
                const durationInput = document.getElementById('timer-duration-input');
                if (e.target.value === 'none') {
                    durationContainer.classList.add('hidden');
                } else {
                    durationContainer.classList.remove('hidden');
                    if (e.target.value === 'whole_quiz') {
                        durationLabel.textContent = 'ระยะเวลา (นาที):';
                        durationInput.value = '10';
                    } else { // per_question
                        durationLabel.textContent = 'ระยะเวลา (วินาที):';
                        durationInput.value = '30';
                    }
                }
            });
            
            // Quiz Type Selector Listener
            document.getElementById('quiz-type-select').addEventListener('change', (e) => {
                const numChoicesContainer = document.getElementById('num-choices-container');
                const type = e.target.value;
                const numQuestionsLabel = document.querySelector('label[for="num-questions"]');
                const passingScoreInput = document.getElementById('passing-score-input');
                const numQuestionsInput = document.getElementById('num-questions');

                if (type === 'matching') {
                    numQuestionsLabel.textContent = 'จำนวนคู่:';
                } else {
                    numQuestionsLabel.textContent = 'จำนวนข้อ:';
                }

                if (type === 'multiple_choice' || type === 'fill_in_with_choices' || type === 'mixed') {
                    numChoicesContainer.classList.remove('hidden');
                } else {
                    numChoicesContainer.classList.add('hidden');
                }
                
                // Update max for passing score
                passingScoreInput.max = numQuestionsInput.value;
            });

            document.getElementById('num-questions').addEventListener('input', (e) => {
                document.getElementById('passing-score-input').max = e.target.value;
            });


            // Modal Timer Settings Listener
            document.getElementById('modal-timer-mode-select').addEventListener('change', (e) => {
                const durationContainer = document.getElementById('modal-timer-duration-container');
                const durationLabel = document.getElementById('modal-timer-duration-label');
                const durationInput = document.getElementById('modal-timer-duration-input');
                if (e.target.value === 'none') {
                    durationContainer.classList.add('hidden');
                } else {
                    durationContainer.classList.remove('hidden');
                    if (e.target.value === 'whole_quiz') {
                        durationLabel.textContent = 'ระยะเวลา (นาที):';
                    } else { // per_question
                        durationLabel.textContent = 'ระยะเวลา (วินาที):';
                    }
                }
            });
			
			// Event Listeners for Quiz Editor Modal
            document.getElementById('cancel-quiz-edits-btn').addEventListener('click', () => {
                document.getElementById('quiz-editor-modal').classList.add('hidden');
            });
            document.getElementById('cancel-quiz-edits-btn-footer').addEventListener('click', () => {
                document.getElementById('quiz-editor-modal').classList.add('hidden');
            });
			
			document.getElementById('verify-answers-editor-btn').addEventListener('click', handleVerifyAnswersInEditor);
			
            document.getElementById('save-quiz-edits-btn').addEventListener('click', () => {
                // เพิ่มบรรทัดนี้: สั่งให้หน้าต่างแก้ไขหายไปก่อน
                document.getElementById('quiz-editor-modal').classList.add('hidden');

                // จากนั้นค่อยเรียกหน้าต่างยืนยันตามปกติ
                showConfirmation(
                    'การแก้ไขแบบทดสอบจะทำให้ผลการสอบเก่าไม่สอดคล้องกับคำถามและเฉลยชุดใหม่ ซึ่งอาจทำให้การแสดงผลคะแนนเก่าเกิดความสับสนได้ คุณต้องการบันทึกการเปลี่ยนแปลงหรือไม่?',
                    handleSaveChanges
                )
            });
			
			document.getElementById('auto-fix-latex-btn').addEventListener('click', handleAutoFixLatex);
			
			// ▼▼▼ เพิ่มโค้ดส่วนนี้เข้าไปได้เลย ▼▼▼
            const editorContainer = document.getElementById('quiz-editor-questions-container');
            if (editorContainer) {
                editorContainer.addEventListener('click', (e) => {
                    
                    // 1. ตรวจสอบปุ่ม "สร้างโจทย์ใหม่"
                    const regenerateBtn = e.target.closest('.regenerate-question-editor-btn');
                    if (regenerateBtn) {
                        const questionItem = regenerateBtn.closest('.question-editor-item');
                        const index = parseInt(questionItem.dataset.qIndex, 10);
                        handleRegenerateQuestionInEditor(index);
                        return; // ทำงานเสร็จแล้ว ออกจากฟังก์ชัน
                    }
                    
                    // 2. [เพิ่มใหม่] ตรวจสอบปุ่ม "ลบคำถาม"
                    const deleteBtn = e.target.closest('.delete-question-editor-btn');
                    if (deleteBtn) {
                        const questionItem = deleteBtn.closest('.question-editor-item');
                        const index = parseInt(questionItem.dataset.qIndex, 10);
                        handleDeleteQuestionInEditor(index);
                        return; // ทำงานเสร็จแล้ว ออกจากฟังก์ชัน
                    }

                    // 3. [เพิ่มใหม่] ตรวจสอบปุ่ม "เพิ่มคำถาม"
                    const addBtn = e.target.closest('#add-question-editor-btn');
                    if (addBtn) {
                        handleAddQuestionInEditor();
                        return; // ทำงานเสร็จแล้ว ออกจากฟังก์ชัน
                    }

                    // (ส่วนปุ่ม 'ai-fix-question-btn' ถูกจัดการโดย .forEach ด้านล่างอยู่แล้ว ไม่ต้องยุ่ง)
                });
            }
            // 1. Event Listener ให้ปุ่ม "คลังแบบทดสอบ" ที่สร้างใหม่
            document.getElementById('open-quiz-bank-btn')
            .addEventListener('click', openQuizBankModal);

            // 2. Event Listener ให้ปุ่มปิด (X) ของ Modal ใหม่
            document.getElementById('cancel-quiz-bank-btn')
            .addEventListener('click', () => {
                document.getElementById('quiz-bank-modal').classList.add('hidden');
            });

            // 3. Event Listener ให้ช่องค้นหาของ Modal ใหม่
            document.getElementById('bank-quiz-search-input')
            .addEventListener('input', (e) => renderQuizBankList(e.target.value));	

// ▼▼▼ นำโค้ดบล็อกนี้ไปแทนที่ของเดิมทั้งหมด ▼▼▼
const mathTopicsContainer = document.getElementById('math-topics-checkbox-container');
if (mathTopicsContainer) {
    let currentlyEditingContainer = null; // ตัวแปรสำหรับเช็คว่ามีหัวข้อที่กำลังแก้ไขอยู่หรือไม่

    mathTopicsContainer.addEventListener('click', (e) => {
        const target = e.target;
        
        // --- จัดการการคลิกปุ่มต่างๆ ---
        const editBtn = target.closest('.edit-custom-topic-btn');
        const deleteBtn = target.closest('.delete-custom-topic-btn');
        const saveBtn = target.closest('.save-custom-topic-btn');
        const cancelBtn = target.closest('.cancel-edit-topic-btn');

        if (deleteBtn) {
            e.preventDefault();
            const topicId = deleteBtn.dataset.id;
            const topicName = deleteBtn.closest('.group').querySelector('.topic-name-display').textContent;
            showConfirmation(
                `คุณแน่ใจหรือไม่ว่าต้องการลบหัวข้อ "${topicName}"?`,
                () => handleDeleteCustomTopic(topicId)
            );
        } else if (editBtn) {
            e.preventDefault();
            // ถ้ามีอันอื่นที่กำลังแก้ ให้ยกเลิกก่อน
            if (currentlyEditingContainer) {
                toggleTopicEditMode(currentlyEditingContainer, false);
            }
            // เข้าโหมดแก้ไขอันที่เพิ่งคลิก
            const topicContainer = editBtn.closest('[data-topic-container-id]');
            currentlyEditingContainer = topicContainer;
            toggleTopicEditMode(topicContainer, true);

        } else if (saveBtn) {
            e.preventDefault();
            const topicId = saveBtn.dataset.id;
            const topicContainer = saveBtn.closest('[data-topic-container-id]');
            const newName = topicContainer.querySelector('.topic-name-input').value;
            handleUpdateCustomTopic(topicId, newName);
            currentlyEditingContainer = null; // ออกจากโหมดแก้ไข

        } else if (cancelBtn) {
            e.preventDefault();
            const topicContainer = cancelBtn.closest('[data-topic-container-id]');
            toggleTopicEditMode(topicContainer, false);
            currentlyEditingContainer = null; // ออกจากโหมดแก้ไข
        }
    });
	
	// Event Listeners สำหรับ Modal แผนการสอน
document.getElementById('close-lesson-plan-modal-btn').addEventListener('click', () => {
    document.getElementById('lesson-plan-modal').classList.add('hidden');
});
document.getElementById('close-lesson-plan-modal-footer-btn').addEventListener('click', () => {
    document.getElementById('lesson-plan-modal').classList.add('hidden');
});
document.getElementById('export-lesson-pdf-btn').addEventListener('click', handleExportLessonPDF);}

  // Event Listeners สำหรับ Modal เปรียบเทียบผล
    document.getElementById('close-comparison-modal-btn').addEventListener('click', () => {
        document.getElementById('comparison-modal').classList.add('hidden');
    });
    document.getElementById('close-comparison-modal-footer-btn').addEventListener('click', () => {
        document.getElementById('comparison-modal').classList.add('hidden');
    });

setupComparisonModalTabs();

document.body.addEventListener('click', function(event) {
    if (event.target.classList.contains('practice-topic-btn')) {
        const topic = unescape(event.target.dataset.topic);
        startSkillPractice(topic); // เรียกฟังก์ชันหลักที่จะสร้างในขั้นตอนที่ 2
    }
});

document.getElementById('scores-tab-content').addEventListener('click', (e) => {
    // 1. ปุ่มลบ (Delete)
    const deleteBtn = e.target.closest('.delete-submission-btn');
    if (deleteBtn) {
        const studentName = deleteBtn.dataset.studentName;
        handleDeleteSubmission(studentName);
        return;
    }

    // 2. ปุ่มแก้ไขคะแนน (Edit Points) - [ส่วนที่เพิ่มใหม่]
    const editPointsBtn = e.target.closest('.edit-points-btn');
    if (editPointsBtn) {
        const studentName = editPointsBtn.dataset.studentName;
        const currentPoints = editPointsBtn.dataset.currentPoints;
        
        // แสดง Popup ให้กรอกคะแนนใหม่
        const newPointsStr = prompt(`แก้ไขคะแนน Points ของ "${studentName}"\n(ใส่ค่าเดิมที่ถูกต้องลงไป)`, currentPoints);
        
        if (newPointsStr !== null && newPointsStr.trim() !== '') {
            const newPoints = parseInt(newPointsStr, 10);
            if (!isNaN(newPoints)) {
                handleManualEditPoints(studentName, newPoints);
            } else {
                alert("กรุณากรอกเป็นตัวเลขเท่านั้น");
            }
        }
    }
});

document.getElementById('close-pin-modal-btn')?.addEventListener('click', () => {
        document.getElementById('pin-entry-modal').classList.add('hidden');
    });

    // ปุ่มตัวเลข 0-9
    document.querySelectorAll('.pin-key').forEach(btn => {
        btn.addEventListener('click', () => {
            handlePinKeyPress(btn.dataset.val);
        });
    });

    // ปุ่มลบ (Backspace)
    document.getElementById('pin-backspace-btn')?.addEventListener('click', () => {
        handlePinKeyPress('backspace');
    });
	
}

async function handleStartGroupMode(quizId, shouldSave = false) {
    const quiz = allQuizzes.find(q => q.id === quizId) || allQuizzesGlobal.find(q => q.id === quizId);
    if (!quiz) {
        showMessage("ไม่พบข้อมูลแบบทดสอบ");
        return;
    }

    currentQuizData = getShuffledQuiz(quiz);
    const teamPin = Math.floor(1000 + Math.random() * 9000).toString();

    try {
        const teamQuizRef = await addDoc(collection(db, `artifacts/${appId}/public/data/teamQuizzes`), {
            quizId: quiz.id,
            projectId: quiz.projectId,
            status: "lobby",
            pin: teamPin,
            mode: "group", // ระบุว่าเป็น Group Mode
            createdAt: serverTimestamp(),
            currentQuestionIndex: 0,
            groups: {}, // ใช้ "groups" แทน "responses"
            shuffledQuiz: currentQuizData, // เพิ่ม field นี้เข้าไปด้วย
            shouldSaveResults: shouldSave // <-- เพิ่มบรรทัดนี้
        });

        currentTeamQuizId = teamQuizRef.id;
        showView('live-game');
        // เราสามารถใช้ Dashboard เดิมได้ แต่ต้องปรับแก้การแสดงผล
        renderAdminTeamQuizDashboard(teamPin, quiz.topic, "group"); 
        listenForTeamQuizUpdates(); // ใช้ listener เดิมได้ แต่ต้องแก้ update function

    } catch (err) {
        console.error("Error starting group quiz:", err);
        showMessage("เกิดข้อผิดพลาดในการสร้างห้อง Group Quiz");
    }
}

// --- [ วางทับฟังก์ชันนี้ทั้งหมด ] ---
async function showStudentProgressView() {
            studentInitialView.classList.add('hidden');
            document.getElementById('student-progress-view').classList.remove('hidden');

            const projectSelect = document.getElementById('progress-project-select');
            const studentSelect = document.getElementById('progress-student-select');
            const contentDiv = document.getElementById('student-progress-content');
            
            contentDiv.innerHTML = '<p class="text-center text-gray-500">กรุณาเลือกโปรเจคเพื่อดูข้อมูล</p>';
            studentSelect.innerHTML = '<option value="">-- เลือกชื่อ --</option>';
            studentSelect.disabled = true;

            projectSelect.innerHTML = '<option value="">กำลังโหลด...</option>';
            if (allProjects.length === 0) {
                const projectsRef = collection(db, `artifacts/${appId}/public/data/projects`);
                const snapshot = await getDocs(projectsRef);
                allProjects = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            }
            
            const visibleProjects = allProjects.filter(p => p.settings?.showInStudentDashboard !== false);
            visibleProjects.sort((a, b) => a.projectName.localeCompare(b.projectName, 'th'));

            projectSelect.innerHTML = '<option value="">-- เลือกโปรเจค --</option>' + 
                visibleProjects.map(p => `<option value="${p.id}">${p.projectName}</option>`).join('');

            projectSelect.onchange = () => {
                // --- [START] ส่วนแก้ไขใหม่ ---
                const previousStudent = studentSelect.value; // 1. จำชื่อนักเรียนที่เลือกไว้ก่อนหน้า
                // --- [END] ส่วนแก้ไขใหม่ ---

                const selectedProjectId = projectSelect.value;
                studentSelect.disabled = true;
                studentSelect.innerHTML = '<option value="">-- เลือกชื่อ --</option>';
                contentDiv.innerHTML = '<p class="text-center text-gray-500">กรุณาเลือกชื่อของคุณ</p>';
                
                if (!selectedProjectId) return;

                const project = allProjects.find(p => p.id === selectedProjectId);
                if (!project || !project.students) return;
                
                const populateStudentDropdown = () => {
                    studentSelect.innerHTML = '<option value="">-- เลือกชื่อ --</option>' + 
                                              project.students.map(name => `<option value="${name}">${name}</option>`).join('');
                    studentSelect.disabled = false;
                    
                    // --- [START] ส่วนแก้ไขใหม่ ---
                    // 2. พยายามเลือกชื่อเดิมในโปรเจคใหม่ให้อัตโนมัติ
                    const newOptions = Array.from(studentSelect.options).map(opt => opt.value);
                    if (previousStudent && newOptions.includes(previousStudent)) {
                        studentSelect.value = previousStudent;
                        studentSelect.dispatchEvent(new Event('change'));
                    } else if (project.students.length === 1) {
                        studentSelect.value = project.students[0];
                        studentSelect.dispatchEvent(new Event('change'));
                    }
                    // --- [END] ส่วนแก้ไขใหม่ ---
                };

                // (ส่วน passcode เหมือนเดิม ไม่ต้องแก้ไข)
                if (project.settings?.isPasscodeEnabled) {
                    if (sessionStorage.getItem('authed_project_' + selectedProjectId) === 'true') {
                        populateStudentDropdown();
                        return;
                    }
                    const passcodeModal = document.getElementById('project-passcode-modal');
                    const confirmBtn = document.getElementById('confirm-passcode-btn');
                    const cancelBtn = document.getElementById('cancel-passcode-btn');
                    const passcodeInput = document.getElementById('student-passcode-input');
                    const errorMsg = document.getElementById('passcode-error-msg');
                    document.getElementById('passcode-prompt-message').textContent = `สำหรับโปรเจค: ${project.projectName}`;
                    passcodeInput.value = '';
                    errorMsg.classList.add('hidden');
                    passcodeModal.classList.remove('hidden');
                    const handleConfirm = () => {
                        const enteredPasscode = passcodeInput.value.trim();
                        if (enteredPasscode === project.settings.passcode) {
                            sessionStorage.setItem('authed_project_' + selectedProjectId, 'true');
                            passcodeModal.classList.add('hidden');
                            populateStudentDropdown();
                            confirmBtn.removeEventListener('click', handleConfirm);
                        } else {
                            errorMsg.classList.remove('hidden');
                        }
                    };
                    confirmBtn.onclick = handleConfirm;
                    cancelBtn.onclick = () => {
                        passcodeModal.classList.add('hidden');
                        projectSelect.value = '';
                        confirmBtn.removeEventListener('click', handleConfirm);
                    };
                } else {
                    populateStudentDropdown();
                }
            };

            studentSelect.onchange = () => {
                const selectedProjectId = projectSelect.value;
                const selectedStudentName = studentSelect.value;
                if (selectedProjectId && selectedStudentName) {
                    renderStudentProgressDashboard(selectedProjectId, selectedStudentName);
                }
            };
        }
		
async function confirmAndJoinSyncGame() {

    // ล้างค่าในเครื่อง (Session) เพื่อความสะอาด
    lastSeenQuestionIndex = -1;
    sessionStorage.removeItem('pollUsedThisTurn');
    sessionStorage.removeItem('onSecondChance');
    Object.keys(sessionStorage).forEach(key => {
        if (key.startsWith('freeMarketEntryUsed_q') || key.startsWith('powerupUsed_q') || key.startsWith('hiddenOptions_q')) { 
            sessionStorage.removeItem(key);
        }
    });

    // ใช้รายชื่อจากตัวแปรที่เรียงลำดับไว้แล้ว
    const selectedPlayers = [...orderedPlayerSelection];

    if (selectedPlayers.length === 0) {
        showMessage("กรุณาเลือกผู้เล่นอย่างน้อย 1 คน");
        return;
    }

    localTeamPlayers = selectedPlayers; // ลำดับการเล่นจะตามนี้เลย
    localPlayerTurnIndex = 0;
    cachedPlayerData = {}; 

    try {
        const batch = writeBatch(db);
        const timestamp = serverTimestamp();

        // วนลูปเช็คผู้เล่นทีละคน (โค้ดเดิม)
        for (const name of selectedPlayers) {
            const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, name);
            const playerSnap = await getDoc(playerRef);

            if (playerSnap.exists()) {
                batch.update(playerRef, { status: 'active' });
            } else {
                const newPlayerData = {
                    name: name,
                    score: 0,
                    totalPoints: 0,
                    pointsLastRound: 0,
                    powerups: {
                        fiftyFifty: 0, secondChance: 0, buyTime: 0, poll: 0,
                        wagerMultiplier: 0, forceConfident: 0, cutOne: 0, insurance: 0, strategyScan: 0, jinx: 0, revealOptions: 0
                    },
                    answered: false,
                    status: 'active',
                    answers: [],
                    joinedAt: timestamp,
                    isJinxed: false,
                    isForcedConfident: false,
                    timeBonusThisQuestion: 0
                };
                batch.set(playerRef, newPlayerData);
            }
        }

        await batch.commit();

        showView('live-game');
        document.getElementById('student-team-selection-view').classList.add('hidden');
        currentStudentName = selectedPlayers[0]; // คนแรกที่เลือกคือคนเล่นคนแรก
        
        listenForSyncGameUpdates(); 

        const gameState = {
            gameId: currentLiveGameId,
            mode: 'sync',
            players: localTeamPlayers,
            turnIndex: 0
        };
        sessionStorage.setItem('activeGameSession', JSON.stringify(gameState));
		
		//aaaa


    } catch (error) {
        console.error("Error joining sync game:", error);
        showMessage("เกิดข้อผิดพลาดในการเข้าร่วม: " + error.message);
    }
}

async function resumeActiveGameSession() {
    const savedSession = sessionStorage.getItem('activeGameSession');
    if (!savedSession) {
        return; // ไม่มีเกมที่ค้างอยู่
    }

    const gameState = JSON.parse(savedSession);
    
    // ดึงค่าที่เป็นไปได้ทั้งหมดออกมา
    const { gameId, mode, role, players, turnIndex } = gameState;

    try {
        // --- [ 🚀 START: Logic ใหม่สำหรับ Admin ] ---
        if (role === 'admin' && mode === 'sync') {
            // นี่คือ Admin ที่กดรีเฟรชในโหมด Sync
            const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, gameId);
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists() || gameSnap.data().status === 'podium' || gameSnap.data().status === 'finished') {
                sessionStorage.removeItem('activeGameSession');
                return;
            }
            
            console.log(`กำลังกลับเข้าสู่เกม (Admin) (ID: ${gameId})`);

            currentMode = 'admin'; // <-- บรรทัดสำคัญที่ขาดไป!

            currentLiveGameId = gameId;
            currentQuizData = gameSnap.data().shuffledQuiz; 
            showView('live-game');
            listenForSyncGameUpdates(); // ตอนนี้จะเรียก updateAdminSyncView ให้อัตโนมัติ

        } 
        // --- [ 🚀 END: Logic ใหม่สำหรับ Admin ] ---
        
        else if (mode === 'sync' && players) {
            // (โค้ดเดิม) นี่คือ Player ที่กดรีเฟรชในโหมด Sync
            const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, gameId);
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists() || gameSnap.data().status === 'podium' || gameSnap.data().status === 'finished') {
                sessionStorage.removeItem('activeGameSession'); return;
            }
            
            console.log(`กำลังกลับเข้าสู่เกม (Player) (ID: ${gameId})`);
            currentLiveGameId = gameId;
            currentStudentName = players[0];
            
            // ▼▼▼ [ START: นี่คือส่วนที่แก้ไข ] ▼▼▼
            localTeamPlayers = players; // <-- บรรทัดสำคัญที่ขาดไป!
            // ▲▲▲ [ END: สิ้นสุดส่วนที่แก้ไข ] ▲▲▲
            
            showView('live-game');
            listenForSyncGameUpdates();

        } else if ((mode === 'team' || mode === 'group') && players) {
            // (โค้ดเดิม) นี่คือ Player ที่กดรีเฟรชในโหมด Team/Group
            const gameRef = doc(db, `artifacts/${appId}/public/data/teamQuizzes`, gameId);
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists() || gameSnap.data().status === 'podium' || gameSnap.data().status === 'finished') {
                sessionStorage.removeItem('activeGameSession'); return;
            }
            
            console.log(`กำลังกลับเข้าสู่เกม ${mode} (Player) (ID: ${gameId})`);
            currentTeamQuizId = gameId;
            localTeamPlayers = players;
            
            localQuestionIndex = gameState.questionIndex || 0;
            localPlayerIndex = gameState.playerIndex || 0;
            
            const gameData = gameSnap.data();
            const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, gameData.quizId);
            const quizSnap = await getDoc(quizRef);
            if(quizSnap.exists()) {
                 currentQuizData = getShuffledQuiz({ id: quizSnap.id, ...quizSnap.data() });
                 showView('student');
                 studentInitialView.classList.add('hidden');
                 
                 if (mode === 'group') {
                    renderGroupModeQuestion();
                 } else {
                    renderTeamQuizQuestion();
                 }
                 listenForTeamQuizUpdates();
            }
        }
    } catch (error) {
        console.error("Failed to resume game session:", error);
        sessionStorage.removeItem('activeGameSession');
    }
}

async function handleUsePowerup(playerName, itemId, question, gameData, playerData) {
    const qIndex = gameData.currentQuestionIndex;
    const flagName = `powerupUsed_q${qIndex}_p${playerName}`;
    const powerupUsed = sessionStorage.getItem(flagName);

    // 1. ตรวจสอบการกดซ้ำ
    if (powerupUsed && itemId !== 'buyTime' && itemId !== 'strategyScan') { 
        showMessage("คุณสามารถใช้ตัวช่วยได้เพียง 1 ครั้งต่อ 1 ข้อครับ");
        const btn = document.getElementById(`use-powerup-${itemId}`);
        if(btn) btn.disabled = false;
        return;
    }

    // กรณีพิเศษ: คูณเดิมพัน (ทำงานในเครื่อง)
    if (itemId === 'wagerMultiplier') {
        sessionStorage.setItem(flagName, itemId);
        playSystemSound('powerup'); // [เพิ่ม] เสียงใช้ไอเทม
        renderStudentSyncQuestionView(gameData);
        return; 
    }

    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, playerName);
    
    try {
        await runTransaction(db, async (transaction) => {
            const playerDoc = await transaction.get(playerRef);
            if (!playerDoc.exists()) throw "ไม่พบข้อมูลผู้เล่น";
            
            const currentPlayerData = playerDoc.data();
            const playerPowerups = currentPlayerData.powerups || {};
            const currentItemCount = playerPowerups[itemId] || 0;
            
            if (currentItemCount <= 0) {
                throw "คุณไม่มีไอเทมนี้ในคลัง (กรุณาลองรีเฟรชหน้าจอ)";
            }
            
            const updatePayload = {};
            updatePayload[`powerups.${itemId}`] = increment(-1); 

            // รีเซ็ต Streak เมื่อใช้ไอเทม (ยกเว้นเดิมพัน)
            if (itemId !== 'wagerMultiplier') {
                updatePayload['correctStreak'] = 0;
            }

            if (itemId === 'buyTime') {
                const baseDurationMs = (gameData.timerDuration || 240) * 1000;
                const timeBonusMs = baseDurationMs * 0.25;
                updatePayload[`timeBonusThisQuestion`] = increment(timeBonusMs);
            }
            
            transaction.update(playerRef, updatePayload);
        });

        if (itemId === 'poll') {
            sessionStorage.setItem('pollUsedThisTurn', 'true');
        }
        if (itemId !== 'buyTime' && itemId !== 'strategyScan') { 
            sessionStorage.setItem(flagName, itemId);
        }
        
        // [เพิ่ม] เล่นเสียงเมื่อใช้สำเร็จ
        playSystemSound('powerup');

        applyPowerupEffect(playerName, itemId, question, gameData, playerData);
        
        if (itemId === 'cutOne' || itemId === 'fiftyFifty' || itemId === 'insurance' || itemId === 'revealOptions') {
             renderStudentSyncQuestionView(gameData);
        }

        if (itemId !== 'wagerMultiplier' && playerData.correctStreak > 0) {
            showMessage(`คุณใช้ตัวช่วย "${itemId}"! Combo ถูกรีเซ็ตเป็น 0`);
        }

    } catch (error) {
        console.error("Powerup use failed:", error);
        showMessage(typeof error === 'string' ? error : "เกิดข้อผิดพลาดในการใช้ตัวช่วย");
        const btn = document.getElementById(`use-powerup-${itemId}`);
        if(btn) btn.disabled = false;
    }
}

async function getCachedOtherPlayers(gameData, myName) {
    const currentQ = gameData.currentQuestionIndex;
    
    // 1. เช็คว่าเรามีข้อมูลของ "ข้อปัจจุบัน" อยู่แล้วหรือยัง?
    if (cachedOtherPlayersForQuestion && cachedQuestionIndexForPlayers === currentQ) {
        console.log("ใช้ข้อมูลเพื่อนจาก Cache (ประหยัดเน็ต)");
        return cachedOtherPlayersForQuestion;
    }

    // 2. ถ้าไม่มี (หรือเป็นข้อใหม่) ให้ไปโหลดจาก Firebase
    console.log("โหลดข้อมูลเพื่อนใหม่จาก Server...");
    const playersColRef = collection(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`);
    // ดึงเฉพาะคนที่สถานะ active
    const qQuery = query(playersColRef, where("status", "==", "active"));
    const snapshot = await getDocs(qQuery);
    
    const players = [];
    snapshot.forEach(doc => {
        const p = doc.data();
        // เก็บทุกคน (รวมตัวเองด้วยก็ได้ เดี๋ยวไปกรองออกทีหลัง)
        players.push(p);
    });

    // 3. บันทึกลง Cache ไว้ใช้ครั้งหน้า
    cachedOtherPlayersForQuestion = players;
    cachedQuestionIndexForPlayers = currentQ;
    
    return players;
}

async function applyPowerupEffect(playerName, itemId, question, gameData, playerData) {
    const q = question;
    const qIndex = gameData.currentQuestionIndex;
    
    // เราตัดส่วน getCachedOtherPlayers ทิ้งไปเลย เพราะไอเทมที่เหลืออยู่ไม่จำเป็นต้องใช้ข้อมูลเพื่อน
    // (ช่วยประหยัด Reads ได้ 100%)

    switch(itemId) {
        // --- 1. ปุ่มที่มีให้กดฟรีหน้าจอ (ต้องเก็บไว้) ---
        case 'wagerMultiplier': 
            showMessage("💰 โหมดเดิมพันทำงาน! เลือกคำตอบเพื่อเปิดหน้าต่างเดิมพัน"); 
            break;

        // --- 2. ไอเทมที่ซื้อจากตลาดมืด ---
        case 'secondChance': 
            showMessage("🔁 โอกาสครั้งที่สองทำงาน! หากตอบผิด คุณจะได้เลือกใหม่ทันที 1 ครั้ง"); 
            break; 

        case 'buyTime':
            // คำนวณเวลาที่เพิ่มให้ดู (แต่ Logic เพิ่มจริงอยู่ที่ handleUsePowerup แล้ว)
            const timeBonus = (gameData.timerDuration || 240) * 0.25;
            showMessage(`⏳ ซื้อเวลาสำเร็จ! ได้เพิ่ม ${timeBonus} วินาที`);
            break;

        case 'cutOne':
        case 'fiftyFifty':
             // Logic สำหรับการตัดตัวเลือก
             const allButtons = document.querySelectorAll('.live-answer-btn');
             if (allButtons.length === 0) { showMessage("❌ ไอเทมนี้ใช้ได้เฉพาะกับข้อสอบแบบตัวเลือกเท่านั้นครับ"); return; }
             
             const hiddenFlag = `hiddenOptions_q${qIndex}_p${playerName}`;
             const prevHidden = JSON.parse(sessionStorage.getItem(hiddenFlag) || '[]');
             
             let corrIdx;
             // เช็คประเภทคำถามเพื่อหาข้อถูก
             const qType = q.questionType || gameData.shuffledQuiz.quizType;
             if (qType === 'true_false') { 
                 corrIdx = (String(q.correctAnswer).toLowerCase() === 'true') ? 0 : 1; 
             } else { 
                 corrIdx = q.correctAnswerIndex; 
             }

             // หาปุ่มที่เป็นข้อผิด และยังไม่ถูกซ่อน
             const badBtns = Array.from(allButtons).filter(btn => parseInt(btn.dataset.value) !== corrIdx && !prevHidden.includes(btn.dataset.value));
             
             if (badBtns.length === 0) { showMessage("ไม่เหลือตัวเลือกผิดให้ตัดแล้วครับ!"); return; }
             
             shuffleArray(badBtns); // สุ่มข้อผิดที่จะตัด
             
             const count = itemId === 'cutOne' ? 1 : 2;
             const itemsToHide = [];

             // ลูปซ่อนปุ่มตามจำนวน
             for(let i=0; i<count; i++) {
                 if(badBtns[i]) {
                     badBtns[i].classList.add('hidden'); // ซ่อนปุ่มทันที
                     itemsToHide.push(badBtns[i].dataset.value); 
                 }
             }
             
             // บันทึกลง sessionStorage เพื่อให้คงสถานะไว้ถ้ารีเฟรช
             const newHidden = [...prevHidden, ...itemsToHide];
             sessionStorage.setItem(hiddenFlag, JSON.stringify(newHidden));
             
             showMessage(itemId === 'cutOne' ? "⚡️ ตัดตัวเลือกผิดออกไป 1 ข้อแล้ว!" : "⚡️ 50:50 ทำงาน! ตัดตัวเลือกผิดออกไปแล้ว!");
             break;
             
        default: 
            // กรณีเผื่อไว้สำหรับไอเทมอื่นๆ ในอนาคต
            showMessage(`ใช้ไอเทม ${itemId} แล้ว!`);
    }
}

async function handleForceConfident(targetName, displayName) {
    if (!currentLiveGameId || !targetName) return;
    
    // [แก้ไข] ชี้ไปที่ players subcollection
    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, targetName);
    
    try {
        await updateDoc(playerRef, { isForcedConfident: true });
        showMessage(`ใช้ "บังคับมั่นใจ" กับ ${displayName} สำเร็จ!`);
        
    } catch (error) {
        console.error("Failed to apply forceConfident:", error);
        showMessage("เกิดข้อผิดพลาดในการใช้ไอเทม");
    }
}

async function handleRefundPowerup(playerName, itemId) {
    // [แก้ไข] ชี้ไปที่ players subcollection
    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, playerName);
    
    try {
        const updatePayload = {};
        // [แก้ไข] ตัด prefix ออก
        updatePayload[`powerups.${itemId}`] = increment(1); 
        
        await updateDoc(playerRef, updatePayload);
        console.log(`Refunded ${itemId} to ${playerName}`);
    } catch (error) {
        console.error("Failed to refund powerup:", error);
    }
}

async function handleApplyJinx(targetName, displayName) {
    if (!currentLiveGameId || !targetName) return;
    
    // [แก้ไข] ต้องชี้ไปที่ players subcollection
    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, targetName);
    
    try {
        // [แก้ไข] ไม่ต้องมี prefix players.targetName แล้ว
        await updateDoc(playerRef, { isJinxed: true });
        
        showMessage(`ใช้ "คำสาป" กับ ${displayName} สำเร็จ!`);
        
    } catch (error) {
        console.error("Failed to apply jinx:", error);
        showMessage("เกิดข้อผิดพลาดในการใช้ไอเทม");
    }
}

function activateFileInputAreaWithLoadedFile() {
    const generateBtn = document.getElementById('generate-from-file-btn');
    const topicsListContainer = document.getElementById('file-topics-list-container');
    const separateContentCheckbox = document.getElementById('separate-by-content-from-file-checkbox');

    // ตรรกะนี้จะทำงานเหมือนกับการอัปโหลดไฟล์ปกติทุกประการ
    if (selectedFile) {
        if (separateContentCheckbox.checked) {
            generateBtn.disabled = true; // ปิดปุ่มสร้างหลัก เพื่อให้ผู้ใช้เลือกหัวข้อก่อน
            analyzeFileForTopics(selectedFile); // เริ่มวิเคราะห์หัวข้อจากไฟล์ที่โหลดมา
        } else {
            generateBtn.disabled = false; // เปิดปุ่มสร้างหลักให้พร้อมใช้งาน
            topicsListContainer.classList.add('hidden'); // ซ่อนส่วนเลือกหัวข้อ
        }
    } else {
        // ถ้าไม่มีไฟล์ ให้ปิดปุ่มและซ่อนทุกอย่าง
        generateBtn.disabled = true;
        topicsListContainer.classList.add('hidden');
    }
}

async function handleKickPlayerSync(playerName) {
    if (!currentLiveGameId || !playerName) return;

    // [แก้ไข] เปลี่ยนเป้าหมายเป็น Player Subcollection
    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, playerName);
    
    try {
        // เปลี่ยนสถานะในไฟล์ย่อย
        await updateDoc(playerRef, { status: 'inactive' });
        // ไม่ต้องทำอะไรต่อ onSnapshot ของ Admin จะตรวจจับและลบชื่อออกจากหน้าจอเอง
    } catch (error) {
        console.error(`Failed to kick player ${playerName}:`, error);
        showMessage("เกิดข้อผิดพลาดในการนำผู้เล่นออก");
    }
}

async function renderStudentProgressDashboard(projectId, studentName) {
    const contentDiv = document.getElementById('student-progress-content');
    contentDiv.innerHTML = '<div class="loader mx-auto"></div>';

    try {
        // ดึงแบบทดสอบทั้งหมดในโปรเจค
        const quizzesRef = collection(db, `artifacts/${appId}/public/data/quizzes`);
        const q = query(quizzesRef, where("projectId", "==", projectId));
        const quizzesSnap = await getDocs(q);
        const quizzesInProject = quizzesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        // ดึงผลการส่งงานทั้งหมดของนักเรียนคนนี้
        const submissionPromises = quizzesInProject.map(quiz => 
            getDoc(doc(db, `artifacts/${appId}/public/data/quizzes/${quiz.id}/submissions`, studentName))
        );
        const submissionSnaps = await Promise.all(submissionPromises);
        
        const submissions = submissionSnaps
            .filter(snap => snap.exists())
            .map(snap => ({ quizId: snap.ref.parent.parent.id, ...snap.data() }));
            
        if (submissions.length === 0) {
            contentDiv.innerHTML = '<p class="text-center text-gray-500">ยังไม่มีข้อมูลการทำแบบทดสอบในโปรเจคนี้</p>';
            return;
        }

        // สร้าง HTML แสดงผล
        let html = '<div class="space-y-4">';
        submissions.forEach(sub => {
            const quiz = quizzesInProject.find(qz => qz.id === sub.quizId);
            const displaySetting = quiz.settings?.resultsDisplay || 'show_results_and_answers';
            const passingScore = quiz.settings?.passingScore ?? 0;
            const isPass = sub.bestScore >= passingScore;
            
            // --- [ START: นี่คือตรรกะใหม่ที่เพิ่มเข้ามา ] ---
            let scoreHtml = '';
            let cardBgColor = 'bg-gray-50'; // สีพื้นหลังเริ่มต้น

            switch(displaySetting) {
                case 'show_results_and_answers':
                case 'show_results_only':
                    cardBgColor = isPass ? 'bg-green-50' : 'bg-red-50';
                    scoreHtml = `
                        <p class="text-xl font-bold ${isPass ? 'text-green-700' : 'text-red-700'}">${sub.bestScore} / ${sub.totalQuestions}</p>
                        <p class="text-xs font-semibold px-2 py-0.5 rounded-full ${isPass ? 'bg-green-200 text-green-800' : 'bg-red-200 text-red-800'}">${isPass ? 'ผ่าน' : 'ไม่ผ่าน'}</p>
                    `;
                    break;
                case 'show_pass_fail_only':
                    cardBgColor = isPass ? 'bg-green-50' : 'bg-red-50';
                    scoreHtml = `
                        <p class="text-xl font-semibold px-3 py-1 rounded-full ${isPass ? 'bg-green-200 text-green-800' : 'bg-red-200 text-red-800'}">${isPass ? 'ผ่าน' : 'ไม่ผ่าน'}</p>
                    `;
                    break;
                case 'manual_release':
                    cardBgColor = 'bg-yellow-50';
                    scoreHtml = `
                        <p class="text-sm font-semibold px-3 py-1 rounded-full bg-yellow-200 text-yellow-800">รอประกาศผล</p>
                    `;
                    break;
            }
            // --- [ END: สิ้นสุดตรรกะใหม่ ] ---

            html += `
                <div class="p-4 border rounded-lg flex justify-between items-center ${cardBgColor}">
                    <div>
                        <p class="font-semibold">${quiz.topic}</p>
                        <p class="text-sm text-gray-600">ทำไป ${sub.attempts.length} ครั้ง | ส่งล่าสุด: ${new Date(sub.latestSubmittedAt).toLocaleDateString('th-TH')}</p>
                    </div>
                    <div class="text-right">
                        ${scoreHtml}
                    </div>
                </div>
            `;
        });
        html += '</div>';
        contentDiv.innerHTML = html;

    } catch (error) {
        console.error("Error rendering student progress:", error);
        contentDiv.innerHTML = '<p class="text-center text-red-500">เกิดข้อผิดพลาดในการโหลดข้อมูล</p>';
    }
}

function renderQuizBankListForMultiSelect(filterText = '') {
    const listEl = document.getElementById('bank-quiz-list');
    const term = filterText.toLowerCase().trim();

    // --- ส่วนที่เคยย่อไว้: การเตรียมข้อมูล ---
    // 1. วนลูปใน allQuizzesGlobal เพื่อเพิ่มข้อมูล "ชื่อโปรเจค" เข้าไปในแต่ละ object
    const rows = allQuizzesGlobal
        .map(q => ({
            ...q,
            projectName: (allProjects.find(p => p.id === q.projectId)?.projectName) || 'N/A'
        }))
        // 2. กรองข้อมูลตามคำค้นหา (ค้นจาก ชื่อแบบทดสอบ, ชื่อโปรเจค, หรือรหัส ID)
        .filter(q =>
            (q.topic || '').toLowerCase().includes(term) ||
            (q.projectName || '').toLowerCase().includes(term) ||
            (q.id.toString().includes(term))
        );
    // --- สิ้นสุดส่วนที่เคยย่อไว้ ---

    // 3. สร้าง HTML โดยใช้ข้อมูลที่กรองแล้ว
    listEl.innerHTML = rows.length ? rows.map(q => `
        <label class="w-full text-left p-3 border-b hover:bg-gray-100 flex items-center gap-4 cursor-pointer">
            <input type="checkbox" value="${q.id}" class="quiz-bank-checkbox h-5 w-5 rounded border-gray-300 text-purple-600 focus:ring-purple-500">
            <div>
              <p class="font-semibold text-indigo-700">${q.topic || '(ไม่มีชื่อ)'}</p>
              <p class="text-xs text-gray-500">โปรเจค: ${q.projectName} | ID: ${q.id}</p>
            </div>
        </label>
    `).join('') : `<div class="p-4 text-center text-gray-500">ไม่พบแบบทดสอบ</div>`;
    
    // 4. เพิ่ม Event Listener เพื่อเปิด/ปิดปุ่ม "ยืนยัน" เมื่อมีการเลือก
    listEl.onchange = () => {
        const hasSelection = document.querySelector('.quiz-bank-checkbox:checked');
        document.getElementById('confirm-link-quiz-btn').disabled = !hasSelection;
    };
}

function setupStudentProgressListeners() {
    document.getElementById('view-my-progress-btn').addEventListener('click', showStudentProgressView);
    document.getElementById('back-to-student-home-btn').addEventListener('click', () => {
        document.getElementById('student-progress-view').classList.add('hidden');
        document.getElementById('student-initial-view').classList.remove('hidden');
    });
}

/**
 * [ฉบับเต็ม] เริ่มกระบวนการฝึกฝนทักษะ โดยแปลงคำถามดิบเป็นหัวข้อมาตรฐานก่อน
 * @param {string} rawQuestionText - ประโยคคำถามเต็มๆ ที่มาจากปุ่ม "ฝึกฝนเรื่องนี้เพิ่มเติม"
 */
async function startSkillPractice(rawQuestionText) {
    // 1. แสดงสถานะกำลังโหลดให้นักเรียนเห็น
    studentResultArea.classList.add('hidden'); // ซ่อนหน้าผลสอบเดิม
    studentQuizArea.innerHTML = `
        <div class="text-center p-8">
            <div class="loader mx-auto"></div>
            <p class="mt-4 text-gray-600">กำลังวิเคราะห์หัวข้อและเตรียมชุดแบบฝึกพิเศษ...</p>
        </div>
    `;
    studentQuizArea.classList.remove('hidden');

    try {
        // 2. **ขั้นตอนใหม่ที่สำคัญที่สุด**: เรียก AI เพื่อแปลงคำถามดิบให้เป็นหัวข้อมาตรฐาน
        const standardTopic = await getStandardizedTopic(rawQuestionText);
        console.log(`คำถามดิบ: "${rawQuestionText}" -> หัวข้อมาตรฐาน: "${standardTopic}"`);
        
        // อัปเดต UI ให้แสดงหัวข้อที่ถูกต้องแก่นักเรียน
        studentQuizArea.querySelector('p').textContent = `กำลังเตรียมชุดแบบฝึกพิเศษสำหรับหัวข้อ: "${standardTopic}"...`;

        // 3. ค้นหาคำถามใน "คลังแบบฝึกฝน" ด้วย "หัวข้อมาตรฐาน" ที่ได้มา
        const practiceBankRef = collection(db, `artifacts/${appId}/public/data/practiceBank`);
        const q = query(practiceBankRef, where("topic", "==", standardTopic));
        const snapshot = await getDocs(q);

        // 4. ตรวจสอบว่ามีคำถามในคลังเพียงพอหรือไม่
        if (snapshot.docs.length >= 3) {
            // 4.1 --> กรณีเจอ (Cache Hit): ใช้คำถามจากคลัง
            console.log(`พบข้อสอบ ${snapshot.docs.length} ข้อในคลังสำหรับหัวข้อ "${standardTopic}". กำลังสุ่มเลือกมาใช้งาน...`);
            
            let questionsFromBank = snapshot.docs.map(doc => doc.data());
            
            shuffleArray(questionsFromBank);
            
            const drillData = {
                topic: standardTopic,
                questions: questionsFromBank.slice(0, 3) // เลือกมา 3 ข้อ
            };

            displaySkillPracticeDrill(drillData);

        } else {
            // 4.2 --> กรณีไม่เจอ (Cache Miss): เรียก AI สร้างใหม่
            console.log(`ไม่พบข้อสอบในคลังสำหรับหัวข้อ "${standardTopic}". กำลังเรียก AI สร้างใหม่...`);
            
            const drillData = await generatePracticeQuestions(standardTopic);
            
            // **ขั้นตอนสำคัญ:** บันทึกคำถามใหม่ลงคลังด้วย "หัวข้อมาตรฐาน"
            await saveDrillToPracticeBank(drillData, standardTopic);
            
            displaySkillPracticeDrill(drillData);
        }

    } catch (error) {
        console.error("ล้มเหลวในการเริ่มโหมดฝึกฝนทักษะ:", error);
        showMessage("ขออภัย, ไม่สามารถสร้างชุดแบบฝึกได้ในขณะนี้ กรุณาลองใหม่ภายหลัง");
        studentQuizArea.classList.add('hidden');
        studentResultArea.classList.remove('hidden');
    }
}

/**
 * บันทึกคำถามจากชุดแบบฝึกที่ AI สร้างลงใน Practice Bank
 * @param {object} drillData - ข้อมูลชุดแบบฝึกที่ได้จาก AI
 */
async function saveDrillToPracticeBank(drillData, standardTopic) { // <--- เพิ่ม standardTopic ตรงนี้
    const practiceBankRef = collection(db, `artifacts/${appId}/public/data/practiceBank`);
    const batch = writeBatch(db);

    drillData.questions.forEach(q => {
        const newQuestionDoc = doc(practiceBankRef);
        batch.set(newQuestionDoc, {
            topic: standardTopic, // <--- ตอนนี้ฟังก์ชันรู้จักแล้ว
            questionText: q.questionText,
            options: q.options,
            correctAnswerIndex: q.correctAnswerIndex,
            createdAt: serverTimestamp()
        });
    });

    try {
        await batch.commit();
        console.log(`บันทึกคำถามใหม่ ${drillData.questions.length} ข้อลง Practice Bank สำเร็จ`);
    } catch (error) {
        console.error("Error saving questions to practice bank:", error);
    }
}

/**
 * เรียก AI เพื่อแปลงประโยคคำถามให้เป็นหัวข้อมาตรฐาน (Standardized Topic)
 * @param {string} questionText - ประโยคคำถามเต็มๆ
 * @returns {Promise<string>} หัวข้อมาตรฐาน เช่น "การหารทศนิยม"
 */
async function getStandardizedTopic(questionText) {
    const prompt = `
        คุณคือผู้เชี่ยวชาญด้านหลักสูตรคณิตศาสตร์
        วิเคราะห์คำถามต่อไปนี้ และสรุปให้เป็น "หัวข้อ" ทางคณิตศาสตร์ที่สั้นและเป็นมาตรฐานที่สุด

        ตัวอย่าง:
        - คำถาม: "ผลลัพธ์ของ $12.5 \\div 0.5$ คือเท่าใด" -> หัวข้อ: "การหารทศนิยม"
        - คำถาม: "จงหา ค.ร.น. ของ 12 และ 18" -> หัวข้อ: "การหา ค.ร.น."
        - คำถาม: "$\\frac{1}{2} + \\frac{1}{4}$ มีค่าเท่าใด" -> หัวข้อ: "การบวกเศษส่วน"

        คำถามที่ต้องการวิเคราะห์: "${questionText}"

        ให้ตอบกลับมาเป็น JSON object ที่มี key "standardTopic" เท่านั้น
    `;
    const schema = { type: "OBJECT", properties: { standardTopic: { type: "STRING" } }, required: ["standardTopic"] };

    try {
        const result = await callAnalysisApi(prompt, schema);
        return result.standardTopic;
    } catch (error) {
        console.error("Failed to get standardized topic:", error);
        // หากล้มเหลว ให้ใช้คำถามเดิมเป็นหัวข้อไปก่อน (Fallback)
        return questionText;
    }
}

/**
 * [เวอร์ชันแก้ไขล่าสุด - ไม่ต้องยืนยัน]
 * จัดการกระบวนการสร้างแบบทดสอบฉบับง่าย โดยแสดงสถานะในหน้า "ผลลัพธ์" ทันที
 * @param {string} originalQuizId - ID ของแบบทดสอบต้นฉบับ
 */
async function handleGenerateEasyVersionQuiz(originalQuizId) {
    // ลบ showConfirmation() ที่ครอบโค้ดทั้งหมดออกไป
    // ทำให้โค้ดด้านล่างนี้ทำงานทันทีที่กดปุ่ม

    // 1. เตรียม Element สำหรับแสดงผลสถานะ
    const resultsContentContainer = document.getElementById('results-tab-content');
    const quizzesListContainer = document.getElementById('project-quizzes-list');
    
    // 2. ซ่อนรายการเดิมและแสดงตัวหมุนในหน้าเดียวกัน
    quizzesListContainer.classList.add('hidden');
    const loaderHtml = `
        <div id="temp-loader-results" class="text-center py-16">
            <div class="loader mx-auto"></div>
            <p class="mt-4 text-gray-600">AI กำลังวิเคราะห์และสร้างแบบทดสอบฉบับง่าย...</p>
        </div>
    `;
    resultsContentContainer.insertAdjacentHTML('beforeend', loaderHtml);

    try {
        const originalQuizData = allQuizzes.find(q => q.id === originalQuizId);
        if (!originalQuizData) {
            throw new Error("ไม่พบข้อมูลแบบทดสอบต้นฉบับ");
        }

        const prompt = `
            บทบาท: คุณคือผู้เชี่ยวชาญด้านการสร้างสื่อการสอนที่สามารถปรับเนื้อหาให้เหมาะสมกับผู้เรียนที่แตกต่างกัน (Differentiated Instruction)
            ภารกิจ: จากข้อมูล JSON ของแบบทดสอบต้นฉบับที่แนบมานี้ จงสร้างแบบทดสอบชุดใหม่ทั้งชุดให้เป็น "เวอร์ชันง่าย" สำหรับนักเรียนที่ต้องการการทบทวนเป็นพิเศษ
            ข้อมูลต้นฉบับ: ${JSON.stringify(originalQuizData.questions)}
            กฎการปรับแก้โจทย์:
            1. โจทย์คำนวณ: ให้คงเนื้อเรื่องและหลักการทางคณิตศาสตร์ไว้เหมือนเดิมทุกประการ แต่ให้ "เปลี่ยนตัวเลขทั้งหมด" เป็นตัวเลขที่ง่ายต่อการคำนวณมากที่สุด (เช่น เลขหลักเดียว, เลขที่หารลงตัว, หรือเลข 10, 100)
            2. โจทย์เนื้อหา/หลักการ: ให้ "ปรับแก้สำนวนและคำศัพท์" ให้เข้าใจง่ายขึ้น ทำให้ประโยคสั้นลง และถามตรงไปตรงมามากขึ้น แต่ต้องคงเป้าหมายการเรียนรู้เดิมไว้
            3. โครงสร้าง: จำนวนข้อ, ประเภทของคำถาม (ปรนัย/เติมคำ), และจำนวนตัวเลือก ต้องเหมือนกับชุดต้นฉบับทุกประการ
            4. ผลลัพธ์: ให้ตอบกลับมาเป็น JSON object ที่มีโครงสร้างเหมือนกับต้นฉบับทุกประการ
        `;
        const mixedQuestionSchema = { type: "OBJECT", properties: { questionText: { "type": "STRING" }, questionType: { "type": "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" }, idealAnswer: { type: "STRING" },  imageCode: { type: "STRING" } }, required: ["questionText", "questionType"] };
        const finalSchema = { type: "OBJECT", properties: { questions: { type: "ARRAY", items: mixedQuestionSchema } }, required: ["questions"] };

        const easyVersionData = await callAnalysisApi(prompt, finalSchema);
		
		if (easyVersionData && easyVersionData.questions) {
    easyVersionData.questions.forEach(q => {
        // ตรวจสอบว่ามี property imageCode หรือไม่
        if (q.hasOwnProperty('imageCode')) {
            // ใช้ String() เพื่อป้องกัน error หากค่าเป็น null จริงๆ
            const code = String(q.imageCode).trim();

            // ถ้าค่าที่ได้เป็นค่าว่าง, เป็นคำว่า "null", หรือไม่ใช่โค้ด SVG
            if (code === "" || code.toLowerCase() === "null" || !code.startsWith("<svg")) {
                // ให้ลบ property นี้ทิ้งไปเลย
                delete q.imageCode;
            }
        }
    });
}
        
        if (!easyVersionData || !easyVersionData.questions || easyVersionData.questions.length === 0) {
            throw new Error("AI ไม่สามารถสร้างชุดคำถามฉบับง่ายได้ในขณะนี้");
        }

        const questionsWithIds = easyVersionData.questions.map((q, index) => ({
            ...q,
            id: `q_${Date.now()}_${index}`
        }));

        const newQuizData = {
            projectId: originalQuizData.projectId,
            quizType: originalQuizData.quizType,
            settings: originalQuizData.settings,
            createdBy: originalQuizData.createdBy,
            status: 'active',
            topic: `(ฉบับง่าย) ${originalQuizData.topic}`,
            questions: questionsWithIds,
            createdAt: new Date().toISOString(),
            quizMode: 'standard',
            pairedQuizId: null
        };

        let newQuizId;
        while (true) {
            newQuizId = Math.floor(1000 + Math.random() * 9000).toString();
            const existing = await getDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId));
            if (!existing.exists()) break;
        }
        await setDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId), newQuizData);

        showMessage("สร้างแบบทดสอบฉบับง่ายสำเร็จแล้ว!");

    } catch (error) {
        console.error("Error generating easy version quiz:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
    } finally {
        // ไม่ว่าจะสำเร็จหรือล้มเหลว ให้ลบตัวหมุนและแสดงรายการกลับมา
        const tempLoader = document.getElementById('temp-loader-results');
        if (tempLoader) {
            tempLoader.remove();
        }
        quizzesListContainer.classList.remove('hidden');
    }
}

async function handleGenerateEasyParallelQuiz(originalQuizId) {
    // 1. เตรียมหน้าจอสำหรับแสดงสถานะ
    const resultsContentContainer = document.getElementById('results-tab-content');
    const quizzesListContainer = document.getElementById('project-quizzes-list');
    
    quizzesListContainer.classList.add('hidden');
    const loaderHtml = `
        <div id="temp-loader-results" class="text-center py-16">
            <div class="loader mx-auto"></div>
            <p id="temp-loader-text" class="mt-4 text-gray-600">AI กำลังสร้างโจทย์คู่ขนานฉบับปูพื้นฐาน...</p>
        </div>
    `;
    resultsContentContainer.insertAdjacentHTML('beforeend', loaderHtml);

    try {
        const originalQuizData = allQuizzes.find(q => q.id === originalQuizId);
        if (!originalQuizData) throw new Error("ไม่พบข้อมูลแบบทดสอบต้นฉบับ");

        // 2. สร้าง Prompt ที่รวมกฎทั้ง 3 ข้อไว้ด้วยกัน
        const prompt = `
            บทบาท: คุณคือครูผู้เชี่ยวชาญด้านการสอนซ่อมเสริม (Remedial Teaching)
            ภารกิจ: จากข้อสอบต้นฉบับที่ให้มา จงสร้าง **"แบบทดสอบชุดใหม่"** เพื่อปูพื้นฐาน โดยต้องปฏิบัติตามกฎ 3 ข้อนี้อย่างเคร่งครัด:
            
            1. **⭐⭐⭐ กฎความเป็นคู่ขนาน (Parallel Context): ⭐⭐⭐**
               - **ห้ามคัดลอกสถานการณ์เดิม:** ถ้าโจทย์เดิมเป็น "ซื้อปากกา" โจทย์ใหม่ต้องเป็นเรื่องอื่น เช่น "ซื้อขนม", "ปลูกต้นไม้", "สะสมแสตมป์" ฯลฯ
               - **แต่ต้องใช้วิธีคิดเดิม (Concept):** โครงสร้างทางคณิตศาสตร์ต้องเหมือนเดิม (เช่น ถ้าเดิมคือ (A*B)-C โจทย์ใหม่ก็ต้องเป็น (X*Y)-Z)
            
            2. **กฎตัวเลขง่าย (Easy Numbers):** - เปลี่ยนตัวเลขให้เป็นเลขจำนวนเต็ม, เลขน้อยๆ (หลักสิบ), ลงตัว, คำนวณในใจได้ 
               - เพื่อให้นักเรียนโฟกัสที่ "กระบวนการ" ไม่ใช่การคิดเลข
            
            3. **กฎป้องกันการจำคำตอบ (Anti-Pattern Rule):**
               - **ห้าม** ให้คำตอบสุดท้าย (ช้อยส์ที่ถูก) ตรงกับข้อต้นฉบับเสมอไป (เช่น ถ้าข้อเดิมตอบ ก. ข้อใหม่ไม่จำเป็นต้องตอบ ก.)
               - **สำหรับโจทย์ประเภท "พิจารณาข้อความ" (ก ถูก/ผิด):** ให้ปรับเงื่อนไขเล็กน้อยเพื่อเปลี่ยนสถานะความจริง (เช่น จากเดิมจริง ให้กลายเป็นเท็จ) เพื่อวัดความเข้าใจจริงๆ
            
            ข้อมูลต้นฉบับ: ${JSON.stringify(originalQuizData.questions)}

            ผลลัพธ์: ตอบกลับเป็น JSON object ตาม Schema ที่กำหนดเท่านั้น
        `;

        const mixedQuestionSchema = { type: "OBJECT", properties: { questionText: { "type": "STRING" }, questionType: { "type": "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" }, idealAnswer: { type: "STRING" },  imageCode: { type: "STRING" } }, required: ["questionText", "questionType"] };
        const finalSchema = { type: "OBJECT", properties: { questions: { type: "ARRAY", items: mixedQuestionSchema } }, required: ["questions"] };

        // 3. เรียก API
        const newQuizDataFromAI = await callAnalysisApi(prompt, finalSchema);
        
        if (!newQuizDataFromAI || !newQuizDataFromAI.questions) throw new Error("AI ไม่สามารถสร้างข้อมูลได้");

        const questionsWithIds = newQuizDataFromAI.questions.map((q, index) => ({
            ...q,
            id: `q_${Date.now()}_${index}`,
            imageCode: (q.imageCode && q.imageCode.startsWith('<svg')) ? q.imageCode : null 
        }));

        // 4. บันทึกลงฐานข้อมูล
        const newTopic = `(ปูพื้นฐาน) ${originalQuizData.topic}`;
        
        const dataToSave = {
            topic: newTopic,
            questions: questionsWithIds,
            quizType: originalQuizData.quizType,
            projectId: originalQuizData.projectId,
            createdBy: userId,
            createdAt: new Date().toISOString(),
            status: 'active',
            settings: originalQuizData.settings,
            quizMode: 'standard',
            pairedQuizId: originalQuizId 
        };

        let newQuizId;
        while (true) {
            newQuizId = Math.floor(1000 + Math.random() * 9000).toString();
            const existing = await getDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId));
            if (!existing.exists()) break;
        }
        
        await setDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId), dataToSave);

        const originalQuizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, originalQuizId);
        await updateDoc(originalQuizRef, {
            pairedQuizId: newQuizId
        });

        showMessage(`สร้างแบบทดสอบฉบับปูพื้นฐานสำเร็จ! (สถานการณ์ใหม่ + เลขง่าย)`);

    } catch (error) {
        console.error("Error:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
    } finally {
        const tempLoader = document.getElementById('temp-loader-results');
        if (tempLoader) tempLoader.remove();
        quizzesListContainer.classList.remove('hidden');
    }
}

/**
 * เรียกใช้ AI เพื่อสร้างชุดคำถามสำหรับฝึกฝน (Drill Set)
 * @param {string} topic - หัวข้อที่ต้องการ
 * @returns {Promise<object>} ข้อมูลชุดแบบฝึกที่ AI สร้าง
 */
async function generatePracticeQuestions(topic) {
    const prompt = `
        คุณคือติวเตอร์คณิตศาสตร์ที่มีความเชี่ยวชาญและใจดี
        ภารกิจของคุณคือสร้าง "ชุดแบบฝึก (Drill Set)" จำนวน 3 ข้อ สำหรับนักเรียนที่ต้องการฝึกฝนเพิ่มเติมในหัวข้อเฉพาะทาง
        
        หัวข้อที่ต้องการ: "${topic}"

        ข้อกำหนด:
        1.  สร้างโจทย์ปัญหาที่แตกต่างกัน 3 ข้อ โดยไล่ระดับจากง่ายไปยาก
        2.  โจทย์ต้องมีความหลากหลาย อาจมีทั้งโจทย์คำนวณและโจทย์ปัญหาสถานการณ์
        3.  คำถามต้องเป็นแบบ "ปรนัย 4 ตัวเลือก" เท่านั้น

        ${simpleMathPrompt} // ใช้ prompt เดิมที่เรามีอยู่แล้ว
    `;
    
    // ใช้ Schema เดิมสำหรับคำถามปรนัย (mcqSchema)
    const mcqSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" } }, required: ["questionText", "options", "correctAnswerIndex"] };
    const finalSchema = { type: "OBJECT", properties: { topic: { type: "STRING" }, questions: { type: "ARRAY", items: mcqSchema } }, required: ["topic", "questions"] };

    // เรียกใช้ฟังก์ชัน API ที่มีอยู่แล้ว
    return await callAnalysisApi(prompt, finalSchema);
}

// ▼▼▼ เพิ่มฟังก์ชันใหม่นี้เข้าไปทั้งหมด ▼▼▼
/**
 * แสดง Modal แผนการสอนจากข้อมูลที่มีอยู่แล้ว
 * @param {object} lessonPlan ข้อมูลแผนการสอน
 * @param {object} quizData ข้อมูลของแบบทดสอบ
 */
function displayLessonPlan(lessonPlan, quizData) {
    const lessonHtml = `
        <h3 class="text-xl font-bold mb-4 text-gray-800">แผนการสอนแนะนำสำหรับเรื่อง: ${quizData.topic}</h3>
        <div class="space-y-6 text-left text-base">
            <div><h4 class="font-semibold text-red-800 border-b pb-1 mb-2">จุดที่นักเรียนยังไม่เข้าใจ (Learning Gaps)</h4><ul class="list-disc list-inside text-red-900">${lessonPlan.learningGaps.map(gap => `<li>${gap}</li>`).join('')}</ul></div>
            <div><h4 class="font-semibold text-blue-800 border-b pb-1 mb-2">แนวทางการสอนและเนื้อหาทบทวน</h4><p class="text-gray-700 whitespace-pre-wrap">${lessonPlan.teachingContent}</p></div>
            <div><h4 class="font-semibold text-green-800 border-b pb-1 mb-2">โจทย์ตัวอย่างสำหรับฝึกฝน</h4><div class="space-y-3">${lessonPlan.practiceProblems.map(p => `<div class="border-l-4 border-green-200 pl-3"><p><strong>โจทย์:</strong> ${p.question}</p><p><strong>เฉลย:</strong> ${p.solution}</p></div>`).join('')}</div></div>
        </div>`;
    
    document.getElementById('lesson-plan-title').textContent = `แผนการสอน: ${quizData.topic}`;
    document.getElementById('lesson-plan-content').innerHTML = lessonHtml;
    document.getElementById('lesson-plan-modal').classList.remove('hidden');	
    if (window.MathJax) MathJax.typesetPromise();
}
// ▲▲▲ สิ้นสุดฟังก์ชันใหม่ ▲▲▲

/**
 * แสดงผลหน้าจอโหมดฝึกฝนทักษะทีละข้อ
 * @param {object} drillData - ข้อมูลชุดแบบฝึกจาก AI
 */
function displaySkillPracticeDrill(drillData) {
    let currentDrillIndex = 0;
    const questions = drillData.questions;

    const renderDrillQuestion = () => {
        const q = questions[currentDrillIndex];
        const html = `
            <div class="p-4">
                <p class="text-sm text-gray-500 text-center">ฝึกฝนข้อที่ ${currentDrillIndex + 1} / ${questions.length}</p>
                <div class="my-4 p-4 border rounded-lg bg-gray-50">
                    <p class="font-semibold mb-3">${q.questionText}</p>
                    <div id="drill-options" class="space-y-2">
                        ${q.options.map((opt, i) => `
                            <div>
                                <input type="radio" id="drill_opt_${i}" name="drill_answer" value="${i}" class="mr-2 accent-indigo-600">
                                <label for="drill_opt_${i}">${opt}</label>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div id="drill-feedback" class="hidden my-4 p-3 rounded-lg"></div>
                <div class="flex justify-between items-center mt-4">
                    <button id="hint-btn" class="bg-gray-200 text-gray-700 py-2 px-4 rounded-lg hover:bg-gray-300">
                        <i class="fas fa-lightbulb"></i> ขอคำใบ้
                    </button>
                    <button id="check-answer-btn" class="bg-blue-600 text-white py-2 px-5 rounded-lg font-semibold hover:bg-blue-700">
                        ตรวจคำตอบ
                    </button>
                    <button id="next-drill-btn" class="hidden bg-green-600 text-white py-2 px-5 rounded-lg font-semibold hover:bg-green-700">
                        ข้อต่อไป <i class="fas fa-arrow-right"></i>
                    </button>
                </div>
            </div>
        `;
        studentQuizArea.innerHTML = html;
        if (window.MathJax) MathJax.typesetPromise([studentQuizArea]);

        // --- เพิ่ม Event Listeners สำหรับปุ่มในโหมดฝึกฝน ---
        document.getElementById('hint-btn').addEventListener('click', async () => {
             const hint = await getHintForQuestion(q.questionText);
             showMessage(hint); // ใช้ modal เดิมแสดงคำใบ้
        });

        document.getElementById('check-answer-btn').addEventListener('click', () => {
            const userAnswer = document.querySelector('input[name="drill_answer"]:checked');
            if (!userAnswer) {
                showMessage("กรุณาเลือกคำตอบก่อนครับ");
                return;
            }

            const feedbackEl = document.getElementById('drill-feedback');
            const isCorrect = parseInt(userAnswer.value) === q.correctAnswerIndex;

            if (isCorrect) {
                feedbackEl.className = 'my-4 p-3 rounded-lg bg-green-100 text-green-800';
                feedbackEl.innerHTML = `<strong><i class="fas fa-check-circle"></i> ถูกต้องครับ!</strong>`;
            } else {
                feedbackEl.className = 'my-4 p-3 rounded-lg bg-red-100 text-red-800';
                feedbackEl.innerHTML = `<strong><i class="fas fa-times-circle"></i> ยังไม่ถูกนะ</strong>`;
            }
            feedbackEl.classList.remove('hidden');
			if (window.MathJax) MathJax.typesetPromise([feedbackEl]);
            
            // ซ่อน/แสดงปุ่ม
            document.getElementById('check-answer-btn').classList.add('hidden');
            document.getElementById('hint-btn').classList.add('hidden');
            document.getElementById('next-drill-btn').classList.remove('hidden');
        });

        document.getElementById('next-drill-btn').addEventListener('click', () => {
            currentDrillIndex++;
            if (currentDrillIndex < questions.length) {
                renderDrillQuestion();
            } else {
                // จบการฝึกฝน
                studentQuizArea.innerHTML = `
                    <div class="text-center p-8 bg-indigo-100 rounded-lg">
                        <i class="fas fa-award text-5xl text-indigo-500 mb-4"></i>
                        <h3 class="text-2xl font-bold">ฝึกฝนสำเร็จ!</h3>
                        <p class="mt-2">ยอดเยี่ยมมาก! หนูได้ทบทวนและฝึกฝนเพิ่มเติมแล้ว<br>กลับไปที่หน้าผลสอบเพื่อฝึกฝนหัวข้ออื่นต่อได้เลย</p>
                        <button id="back-to-results-btn" class="mt-4 bg-blue-600 text-white py-2 px-5 rounded-lg font-semibold">กลับไปหน้าผลสอบ</button>
                    </div>
                `;
                document.getElementById('back-to-results-btn').addEventListener('click', () => {
                    studentQuizArea.classList.add('hidden');
                    studentResultArea.classList.remove('hidden');
                });
            }
        });
    };

    renderDrillQuestion(); // เริ่มแสดงผลข้อแรก
}

/**
 * เรียก AI เพื่อสร้างคำใบ้สำหรับโจทย์
 * @param {string} questionText - โจทย์คำถามที่ต้องการคำใบ้
 * @returns {Promise<string>} คำใบ้จาก AI
 */
async function getHintForQuestion(questionText) {
    const prompt = `สำหรับโจทย์คณิตศาสตร์ที่ว่า "${questionText}", ช่วยให้คำใบ้สั้นๆ 1-2 ประโยคเพื่อแนะแนวทางการคิด โดยห้ามเฉลยคำตอบโดยตรงเด็ดขาด`;
    const schema = { type: "OBJECT", properties: { hint: { type: "STRING" } }, required: ["hint"] };
    
    try {
        const result = await callAnalysisApi(prompt, schema);
        return result.hint;
    } catch (error) {
        console.error("Failed to get hint:", error);
        return "ขออภัย, ไม่สามารถสร้างคำใบ้ได้ในขณะนี้";
    }
}
		
		/**
 * ดึงข้อความทั้งหมดจากไฟล์ PDF
 * @param {File} file - ไฟล์ PDF ที่ผู้ใช้อัปโหลด
 * @returns {Promise<string>} - Promise ที่จะ resolve เป็นข้อความทั้งหมดในไฟล์
 */
async function extractTextFromPdf(file) {
    // ตั้งค่า worker source สำหรับ pdf.js
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;

    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
    const numPages = pdf.numPages;
    let fullText = '';

    for (let i = 1; i <= numPages; i++) {
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        const pageText = textContent.items.map(item => item.str).join(' ');
        fullText += pageText + '\n\n'; // เพิ่มการเว้นบรรทัดระหว่างหน้า
    }

    return fullText;
}

// ▼▼▼ START: โค้ดฟังก์ชันใหม่ทั้งหมดสำหรับ "สร้างแยกตามเนื้อหา" ▼▼▼

// ตัวแปรสำหรับเก็บหัวข้อที่ดึงมาจาก Blueprint
let extractedBlueprintTopics = [];

// ▼▼▼ คัดลอกโค้ดทั้งหมดนี้ไปวางทับฟังก์ชัน analyzeBlueprintForTopics เดิม ▼▼▼

async function analyzeBlueprintForTopics(pdfText) {
    const optionsContainer = document.getElementById('blueprint-options-container');
    const topicsListDiv = document.getElementById('blueprint-topics-list');
    const saveBtn = document.getElementById('save-blueprint-as-project-btn');
    
    optionsContainer.classList.remove('hidden');
    topicsListDiv.innerHTML = '<p class="text-gray-500 italic">AI กำลังวิเคราะห์หัวข้อจาก Blueprint...</p>';
    saveBtn.classList.add('hidden');

    try {
        const prompt = `วิเคราะห์ข้อความ Test Blueprint วิชาคณิตศาสตร์นี้: "${pdfText}". ภารกิจคือ: 1.ระบุระดับชั้น 2.สกัดโครงสร้างเนื้อหาทั้งหมดออกมาในรูปแบบ nested JSON ที่ชัดเจน 3.แก้ไขคำภาษาไทยที่ผิดเพี้ยน 4.สรุปชื่อหัวข้อย่อยให้สั้นกระชับ. JSON output ต้องมีโครงสร้าง: { gradeLevel: string, curriculum: [ { sara: string, mainTopics: [ { topicName: string, subTopics: [string] } ] } ] }. ตัวอย่าง: 'สาระที่ 1: จำนวนและพีชคณิต' คือ 'sara'. 'เวลา' คือ 'topicName'. 'การอ่านตารางเวลา' คือ 'subTopic'`;
        
        const schema = {
            type: "OBJECT",
            properties: {
                "gradeLevel": { "type": "STRING" },
                "curriculum": {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "sara": { "type": "STRING" },
                            "mainTopics": {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        "topicName": { "type": "STRING" },
                                        "subTopics": { "type": "ARRAY", "items": { "type": "STRING" } }
                                    },
                                    required: ["topicName", "subTopics"]
                                }
                            }
                        },
                        required: ["sara", "mainTopics"]
                    }
                }
            },
            required: ["gradeLevel", "curriculum"]
        };

        const result = await callAnalysisApi(prompt, schema);
        
        if (result && result.curriculum) {
            extractedBlueprintData = result; // เก็บข้อมูลที่วิเคราะห์ได้
            renderBlueprintTopics(result); 
            saveBtn.classList.remove('hidden'); // แสดงปุ่มบันทึก
        } else {
            throw new Error("AI ไม่สามารถแยกโครงสร้างหัวข้อได้");
        }

    } catch (error) {
        console.error("Error analyzing blueprint topics:", error);
        topicsListDiv.innerHTML = '<p class="text-red-500">เกิดข้อผิดพลาดในการวิเคราะห์หัวข้อ</p>';
    }
} // <-- ปีกกาตัวนี้คือตัวที่น่าจะหายไปครับ ทำให้เกิด Error

function renderBlueprintTopics(blueprintData) {
    const topicsListDiv = document.getElementById('blueprint-topics-list');
    const gradeLevel = blueprintData.gradeLevel;

    // เพิ่มการแสดงระดับชั้นที่วิเคราะห์ได้
    const gradeLevelHeader = `<h3 class="text-center font-semibold text-lg text-gray-700 mb-4">ระดับชั้นที่วิเคราะห์ได้: ${gradeLevel}</h3>`;
    let contentHtml = '';

    blueprintData.curriculum.forEach(sara => {
        contentHtml += `
            <div class="p-4 border rounded-lg bg-gray-50 shadow-sm mb-4">
                <h4 class="font-bold text-xl text-blue-800 mb-3">${sara.sara}</h4>`;

        sara.mainTopics.forEach(mainTopic => {
            contentHtml += `
                <div class="ml-4 mb-3">
                    <h5 class="font-semibold text-lg text-gray-700 mb-2">${mainTopic.topicName}</h5>
                    <div class="space-y-1 pl-4 border-l-2 border-gray-200">`;

            mainTopic.subTopics.forEach(subTopic => {
                // *** จุดสำคัญ ***
                // เราจะใส่ onclick เพื่อเรียกฟังก์ชัน "ตัวกลาง" ที่จะสร้างใน Step 5
                // พร้อมส่ง "หัวข้อย่อย" และ "ระดับชั้น" ไปด้วย
contentHtml += `
    <div class="p-2 rounded-md hover:bg-gray-100 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2">

        <p class="font-semibold text-gray-800 flex-grow cursor-pointer" onclick="handleGenerateAndShowLesson('${subTopic.replace(/'/g, "\\'")}', '${gradeLevel.replace(/'/g, "\\'")}')">
            <i class="fas fa-book-open text-blue-500 mr-2"></i> ${subTopic}
        </p>

        <div class="flex items-center gap-2 flex-shrink-0">
<button class="text-indigo-800 bg-indigo-100 hover:bg-indigo-200 text-xs font-semibold py-1.5 px-3 rounded-md flex items-center gap-1.5"
        onclick="handleGenerateQuizFromBlueprintTopic('${subTopic.replace(/'/g, "\\'")}')">
    <i class="fas fa-file-alt"></i>สร้างแบบทดสอบ
</button>
        </div>

    </div>
`;
            });

            contentHtml += `</div></div>`;
        });
        contentHtml += `</div>`;
    });
    
    topicsListDiv.innerHTML = gradeLevelHeader + contentHtml;
}

async function handleGenerateTeachingContent(selectedTopic) {
    // แสดงสถานะกำลังโหลดใน Modal ที่มีอยู่แล้ว
    const lessonModal = document.getElementById('lesson-plan-modal');
    const contentContainer = document.getElementById('lesson-plan-content');
    
    document.getElementById('lesson-plan-title').textContent = `กำลังสร้างเนื้อหา: ${selectedTopic}`;
    contentContainer.innerHTML = `
        <div class="text-center py-16">
            <div class="loader mx-auto"></div>
            <p class="mt-4 text-gray-600">AI กำลังสรุปแนวคิดหลักและสร้างโจทย์ตัวอย่าง... กรุณารอสักครู่</p>
        </div>
    `;
    lessonModal.classList.remove('hidden');

    try {
        const prompt = `
            บทบาท: คุณคือผู้เชี่ยวชาญด้านการออกแบบการสอน (Instructional Designer) สำหรับวิชาคณิตศาสตร์
            ภารกิจ: จงสร้าง "เอกสารสรุปเนื้อหาเพื่อเตรียมการสอน" สำหรับครู ในหัวข้อ "${selectedTopic}"

            ข้อกำหนด:
            เอกสารต้องประกอบด้วย 4 ส่วนหลัก และตอบกลับมาเป็น JSON object ที่มีโครงสร้างตามที่กำหนดเท่านั้น:
            1.  keyConcepts (array of strings): สรุปแนวคิดหลัก, นิยาม, หรือสูตรที่สำคัญที่สุดของหัวข้อนี้ 2-3 ข้อ
            2.  commonMistakes (array of strings): ระบุจุดที่นักเรียนมักเข้าใจผิดหรือทำพลาดบ่อยๆ ในหัวข้อนี้ 2-3 ข้อ
            3.  stepByStepExamples (array of objects): สร้างโจทย์ตัวอย่างที่หลากหลาย 2 ข้อ พร้อมแสดงวิธีทำอย่างละเอียดเป็นขั้นตอน โดยแต่ละ object ต้องมี key: "question" (string) และ "solution" (string)
            4.  teacherTips (array of strings): ให้คำแนะนำเชิงปฏิบัติสำหรับครู 2 ข้อ เพื่อช่วยให้นักเรียนเข้าใจหัวข้อนี้ได้ดียิ่งขึ้น

            คำสั่งเพิ่มเติม:
            - เนื้อหาทั้งหมดต้องเป็นภาษาไทย
            - คำอธิบายต้องกระชับ ชัดเจน และถูกต้องตามหลักคณิตศาสตร์
            - นิพจน์ทางคณิตศาสตร์ทั้งหมดต้องอยู่ในรูปแบบ LaTeX ที่ถูกต้อง และห่อหุ้มด้วยเครื่องหมาย $
        `;
        
        const schema = {
            type: "OBJECT",
            properties: {
                keyConcepts: { type: "ARRAY", items: { type: "STRING" } },
                commonMistakes: { type: "ARRAY", items: { type: "STRING" } },
                stepByStepExamples: {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            question: { type: "STRING" },
                            solution: { type: "STRING" }
                        },
                        required: ["question", "solution"]
                    }
                },
                teacherTips: { type: "ARRAY", items: { type: "STRING" } }
            },
            required: ["keyConcepts", "commonMistakes", "stepByStepExamples", "teacherTips"]
        };

        const teachingContent = await callAnalysisApi(prompt, schema);
        displayTeachingContent(teachingContent, selectedTopic);

    } catch (error) {
        console.error("Error generating teaching content:", error);
        contentContainer.innerHTML = `<p class="text-center text-red-500">ขออภัย, ไม่สามารถสร้างเนื้อหาได้ในขณะนี้: ${error.message}</p>`;
    }
}

/**
 * แสดงผลเนื้อหาสำหรับสอนที่ AI สร้างขึ้นใน Modal
 * @param {object} content - ข้อมูลเนื้อหาที่ได้จาก AI
 * @param {string} topic - ชื่อหัวข้อ
 */
function displayTeachingContent(content, topic) {
    const contentContainer = document.getElementById('lesson-plan-content');
    document.getElementById('lesson-plan-title').textContent = `เนื้อหาสำหรับสอน: ${topic}`;

    const html = `
        <div class="space-y-8 text-left text-base">
            <div class="content-section">
                <h2 class="text-xl font-bold text-indigo-800 mb-2 border-b-2 border-indigo-200 pb-2">🎯 สรุปแนวคิดหลัก (Key Concepts)</h2>
                <ul class="list-disc list-inside text-gray-800 space-y-1 pl-2">${content.keyConcepts.map(item => `<li>${item}</li>`).join('')}</ul>
            </div>

            <div class="content-section">
                <h2 class="text-xl font-bold text-red-800 mb-2 border-b-2 border-red-200 pb-2">⚠️ จุดที่นักเรียนมักผิดพลาด</h2>
                <ul class="list-disc list-inside text-gray-800 space-y-1 pl-2">${content.commonMistakes.map(item => `<li>${item}</li>`).join('')}</ul>
            </div>

            <div class="content-section">
                <h2 class="text-xl font-bold text-green-800 mb-2 border-b-2 border-green-200 pb-2">✍️ โจทย์ตัวอย่างพร้อมวิธีทำ</h2>
                <div class="space-y-6">${content.stepByStepExamples.map(p => `
                    <div class="p-3 bg-green-50 rounded-lg border border-green-200">
                        <p><strong>โจทย์:</strong> ${p.question}</p>
                        <hr class="my-2 border-dashed">
                        <p><strong>วิธีทำ:</strong></p>
                        <div class="whitespace-pre-wrap pl-2">${p.solution}</div>
                    </div>
                `).join('')}</div>
            </div>

            <div class="content-section">
                <h2 class="text-xl font-bold text-blue-800 mb-2 border-b-2 border-blue-200 pb-2">👩‍🏫 คำแนะนำสำหรับครู</h2>
                <ul class="list-disc list-inside text-gray-800 space-y-1 pl-2">${content.teacherTips.map(item => `<li>${item}</li>`).join('')}</ul>
            </div>
        </div>
    `;

    contentContainer.innerHTML = html;
    if (window.MathJax) MathJax.typesetPromise([contentContainer]);
}

async function generateQuizForSingleTopic(selectedTopic) {
    console.log(`กำลังสร้างแบบทดสอบสำหรับติวเฉพาะเรื่อง: "${selectedTopic}"`);

    const referenceInput = document.getElementById('reference-pdf-upload');
    const referenceFile = referenceInput.files.length > 0 ? referenceInput.files[0] : null;
    let referenceParts = null;

    if (referenceFile) {
        try {
            const refReader = new FileReader();
            refReader.readAsDataURL(referenceFile);
            const refBase64 = await new Promise((resolve, reject) => {
                refReader.onload = () => resolve(refReader.result.split(',')[1]);
                refReader.onerror = (error) => reject(error);
            });
            referenceParts = [
                { inlineData: { mimeType: referenceFile.type, data: refBase64 } }
            ];
        } catch (error) {
            console.error("Error reading reference file for single topic:", error);
            showMessage("เกิดข้อผิดพลาดในการอ่านไฟล์อ้างอิง");
            return;
        }
    }

    // [แก้ไข] เพิ่ม true เป็น parameter สุดท้ายเพื่อบังคับใช้สไตล์โจทย์ประยุกต์
    generateQuiz(selectedTopic, null, null, referenceParts, true, null, null, true);
}

async function handleGenerateFromBlueprint(prebuiltParts = null) {
    const loader = document.getElementById('loader');
    const loaderText = document.getElementById('loader-text');

    let parts;
    let extraParts = []; 

    if (prebuiltParts) {
        // (กรณีคลิกปุ่มลัด)
        parts = prebuiltParts;
        // parts[0] = prompt, parts[1] = blueprint, parts[2+] = reference file(s)
        extraParts = parts.slice(2); 

    } else {
        // (กรณีอัปโหลดไฟล์ด้วยตนเอง)
        const blueprintInput = document.getElementById('blueprint-upload-input');
        const referenceInput = document.getElementById('reference-pdf-upload'); 
        
        const blueprintFile = blueprintInput.files[0];
        if (!blueprintFile) { showMessage("กรุณาเลือกไฟล์ Test Blueprint ก่อน"); return; }
        loaderText.textContent = 'กำลังเตรียมไฟล์...';
        
        const blueprintBase64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(blueprintFile);
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = reject;
        });
        parts = [{ text: "PROMPT_PLACEHOLDER" }, { inlineData: { mimeType: blueprintFile.type, data: blueprintBase64 } }];

        if (referenceInput.files.length > 0) {
             const referenceFile = referenceInput.files[0];
             loaderText.textContent = 'กำลังเตรียมไฟล์อ้างอิง...';
             const refBase64 = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(referenceFile);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
             });
             const refPart = { inlineData: { mimeType: referenceFile.type, data: refBase64 } };
             parts.push(refPart);
             extraParts.push(refPart); 
        }
    }

    // === [UPDATED] Sharp Distractor Logic ===
    const applicationStylePrompt = `
**[กฎเพิ่มเติม: ปรัชญาการสร้างโจทย์สไตล์ O-NET]**

**[กฎควบคุมความซับซ้อน (Complexity Control Rule) - สำคัญที่สุด!]**
นี่คือกฎที่สำคัญที่สุด: หากมี "ไฟล์ข้อสอบต้นฉบับ" (ไฟล์อ้างอิง) แนบมาด้วย ภารกิจหลักของคุณคือการสร้างข้อสอบที่มีความซับซ้อน **"เทียบเท่า"** กับไฟล์อ้างอิงนั้น

**ห้าม (DO NOT)** สร้างโจทย์ที่มีความซับซ้อน, มีหลายขั้นตอน, หรือต้องตีความ **"เกินกว่า"** ระดับความยากโดยเฉลี่ยของโจทย์ในไฟล์อ้างอิงโดยเด็ดขาด
ให้ยึดไฟล์อ้างอิงเป็น **"เพดาน" (Ceiling)** ของความซับซ้อน

บทบาท: คุณคือผู้เชี่ยวชาญการสร้างข้อสอบ O-NET ที่เน้นการวัดความเข้าใจเชิงลึก
ภารกิจ: สร้างโจทย์ที่เน้นการคิดวิเคราะห์และการประยุกต์ใช้ (ภายใต้กรอบความซับซ้อนของไฟล์อ้างอิง) โดยอาจมีลักษณะดังนี้:

* **โจทย์ปัญหาหลายขั้นตอน (Multi-step Problems):** (ตราบเท่าที่ยังไม่ยากเกินไฟล์อ้างอิง)
* **โจทย์คิดย้อนกลับ (Reverse Thinking):** (ตราบเท่าที่ยังไม่ยากเกินไฟล์อ้างอิง)
* **การวิเคราะห์ข้อมูล (Data Analysis):** (ตราบเท่าที่ยังไม่ยากเกินไฟล์อ้างอิง)
* **โจทย์แบบประเมินข้อความ (Statement Evaluation):** (ตราบเท่าที่ยังไม่ยากเกินไฟล์อ้างอิง)
    
**กฎของตัวลวงขั้นสูง (Advanced Distractor Rule):** ห้ามใช้ตัวเลขสุ่ม! ตัวเลือกที่ไม่ถูกต้อง (ตัวลวง) ต้องออกแบบมาอย่างจงใจเพื่อดักจับ "Misconception" ของนักเรียน:
1. **Calculation Error:** คำนวณผิดในขั้นตอนสุดท้าย หรือลืมทด
2. **Concept Error:** ใช้สูตรผิด หรือสลับตัวแปร
3. **Unit Error:** ลืมแปลงหน่วย
*ตัวลวงทุกข้อต้องเป็นคำตอบที่นักเรียนที่ "รู้ไม่จริง" มีโอกาสตอบได้*
`;

    const noReferencePrompt = `
    **[กฎควบคุมความซับซ้อน (Complexity Control Rule) - สำคัญที่สุด!]**
    
    **กรณีที่ 2: หากไม่มี "ไฟล์ข้อสอบอ้างอิง" แนบมาด้วย:**
    * ภารกิจหลักของคุณคือการสร้างข้อสอบตาม **"แม่พิมพ์ข้อสอบ O-NET ฉบับสมบูรณ์"** (ที่ระบุไว้ด้านล่าง)
    * ให้สร้างโจทย์ที่มีความซับซ้อนในระดับ O-NET "มาตรฐาน" ทั่วไป (เช่น โจทย์ปัญหา 1-2 ขั้นตอน)
    * **ห้าม (DO NOT)** พยายามสร้างโจทย์ที่ "คิดวิเคราะห์ซับซ้อน" หรือ "หลายขั้นตอน" จนเกินความจำเป็น
    * ให้เน้นความถูกต้องตามหลักสูตรและความชัดเจนของคำถามเป็นหลัก
    `;

    let qualityDirective = "";
    if (extraParts && extraParts.length > 0) {
        qualityDirective = applicationStylePrompt;
    } else {
        qualityDirective = noReferencePrompt;
    }

    const prompt = `
**คำสั่งเริ่มต้น: การวิเคราะห์โครงสร้าง (Initial Directive: Structural Analysis)**
ก่อนเริ่มสร้างโจทย์ใดๆ ภารกิจแรกของคุณคือ:
1. อ่านไฟล์ Test Blueprint ที่แนบมาให้จบ
2. **ระบุจำนวนข้อสอบทั้งหมด** และ **รูปแบบของข้อสอบในแต่ละตอน** ออกมาให้ชัดเจน
3. จดจำโครงสร้างนี้ไว้ เพราะมันคือกฎสูงสุดที่ต้องปฏิบัติตาม

---

**บทบาท:** คุณคือผู้เชี่ยวชาญด้านการวัดผลและประเมินผลทางการศึกษา โดยเชี่ยวชาญด้านการสร้างข้อสอบ O-NET คณิตศาสตร์ (Test Specialist for O-NET Mathematics) ที่ได้รับมอบหมายให้สร้างข้อสอบชุดใหม่ที่มีความสมมูล (Equivalent) กับข้อสอบจริง

**กฎเหล็กสูงสุด: โครงสร้างข้อสอบ (The Ultimate Golden Rule: Test Structure)**
ภารกิจแรกและสำคัญที่สุดของคุณ คือการวิเคราะห์ไฟล์ Test Blueprint ที่แนบมาเพื่อหาโครงสร้างข้อสอบที่ถูกต้อง คุณต้อง:
1.  **วิเคราะห์จำนวนและรูปแบบ:** อ่านข้อมูลจากหน้า "คำชี้แจง" หรือส่วนสรุป เพื่อระบุ **จำนวนข้อสอบทั้งหมด** และ **รูปแบบของข้อสอบในแต่ละตอน** (เช่น ตอนที่ 1: ปรนัย 4 ตัวเลือก, ตอนที่ 2: ระบายตัวเลข, ตอนที่ 3: ถูก/ผิด)
2.  **ยึดตามโครงสร้างนี้เท่านั้น:** ข้อสอบทั้งชุดที่คุณจะสร้าง ต้องมีจำนวนข้อรวมและรูปแบบในแต่ละตอน **ตรงตามที่ระบุไว้ใน Test Blueprint ทุกประการ**
3.  **คำเตือน:** **ห้ามสร้างจำนวนข้อเกินหรือขาดจากที่ระบุใน Blueprint โดยเด็ดขาด** หากจำนวนข้อที่สร้างไม่ตรงตามนี้ ถือว่าภารกิจทั้งหมดล้มเหลว

---

**ภารกิจหลักด้านคุณภาพ: ปรัชญาการสร้างโจทย์ (Quality Directive: Question Generation Philosophy)**

${qualityDirective} 

---

**ลำดับความสำคัญของข้อมูล (Data Priority Directive):** * **กฎสูงสุด (Priority #1): Test Blueprint** (สำหรับโครงสร้างและจำนวนข้อ)
* **ข้อมูลเสริม (Priority #2): ไฟล์ข้อสอบอ้างอิง (ถ้ามี)** (สำหรับสไตล์และความยาก)

**สร้างสรรค์โจทย์ใหม่เสมอ (Novelty Requirement):**
* ไม่ว่าจะกรณีใดก็ตาม ห้ามคัดลอกโจทย์, ตัวเลข, หรือสถานการณ์จากไฟล์อ้างอิง (ถ้ามี) มาโดยเด็ดขาด ต้องสร้างขึ้นมาใหม่ให้มีความ "สมมูล" กันในเชิงการวัดผลเท่านั้น

---

**แม่พิมพ์ข้อสอบ O-NET ฉบับสมบูรณ์ (Definitive Master Test Pattern)**
(ส่วนนี้ AI จะใช้เมื่อ \`qualityDirective\` เป็น \`noReferencePrompt\`)

* **ลักษณะเฉพาะสำหรับ ประถมศึกษาปีที่ 6 (P.6):**
    * **การคำนวณระคน:** สร้างโจทย์ที่มีวงเล็บและการคูณ/หารผสมกับการบวก/ลบ ต้องใช้ลำดับการคำนวณที่ถูกต้อง
    * **โจทย์ปัญหาเศษส่วนและทศนิยม:** สร้างโจทย์ปัญหา 2-3 ขั้นตอน หรือโจทย์เปรียบเทียบและเรียงลำดับเศษส่วน/จำนวนคละที่ตัวส่วนไม่เท่ากัน
    * **อัตราส่วนและร้อยละ:** สร้างโจทย์ปัญหาที่ต้องใช้อัตราส่วนหรือการคำนวณร้อยละ เช่น การหากำไร, การหาส่วนลด, หรือการหาจำนวนทั้งหมด
    * **แบบรูป (Patterns):** สร้างโจทย์ที่ให้นักเรียนวิเคราะห์แบบรูปของจำนวนจากตารางหรือลำดับ แล้วทำนายจำนวนในลำดับถัดไป
    * **การวัด (Measurement):** สร้างโจทย์ปัญหาที่ต้องมีการแปลงหน่วย (เมตรเป็นเซนติเมตร, กิโลกรัมเป็นกรัม, ชั่วโมงเป็นนาที)
    * **เรขาคณิต (Geometry):** สร้างโจทย์หาความยาวรอบรูปหรือพื้นที่ของ **รูปทรงผสม** หรือหาปริมาตรของรูปทรงสามมิติที่ประกอบจากทรงสี่เหลี่ยม และต้องมีคำถามเกี่ยวกับ **สมบัติของรูปสี่เหลี่ยม**
    * **การวิเคราะห์ข้อมูล (Data Analysis):** ต้องมีโจทย์ที่ให้นักเรียนอ่านและตีความข้อมูลจาก **กราฟเส้น** หรือ **แผนภูมิวงกลม**
    * **กฎสำหรับข้อสอบระบายตัวเลข:** คำตอบสุดท้ายต้องเป็นตัวเลขจำนวนเต็มบวกที่มีค่าไม่เกิน 3 หลัก (0-999) เท่านั้น

* **ลักษณะเฉพาะสำหรับ มัธยมศึกษาปีที่ 3 (M.3):**
    * **เลขยกกำลังและราก:** สร้างโจทย์คำนวณที่ซับซ้อนซึ่งต้องใช้ **สมบัติของเลขยกกำลังและราก** ในการจัดรูป
    * **พีชคณิต (Algebra):** สร้างโจทย์ปัญหาที่ต้องแก้ **ระบบสมการเชิงเส้นสองตัวแปร**, **สมการกำลังสอง**, หรือ **อสมการ**
    * **ฟังก์ชันกำลังสอง (Quadratic Functions):** สร้างโจทย์ที่ต้องใช้ความเข้าใจเกี่ยวกับกราฟ **พาราโบลา** ในการหาระยะทางหรือค่าคงที่
    * **เรขาคณิตวิเคราะห์ (Analytic Geometry):** สร้างโจทย์เกี่ยวกับการแปลงทางเรขาคณิต (เลื่อนขนาน, สะท้อน), การหาระยะห่างระหว่างจุด
    * **เรขาคณิตประยุกต์ (Applied Geometry):** สร้างโจทย์ที่ต้องใช้ความรู้เรื่อง **สามเหลี่ยมคล้าย**, **ทฤษฎีบทพีทาโกรัส**, **อัตราส่วนตรีโกณมิติ** (มุมก้ม/มุมเงย), หรือ **ทฤษฎีบทเกี่ยวกับวงกลม**
    * **ปริมาตรและพื้นที่ผิว:** สร้างโจทย์ปัญหาประยุกต์เกี่ยวกับการหาปริมาตรหรือพื้นที่ผิวของ กรวย, ทรงกระบอก, พีระมิด, หรือทรงกลม
    * **สถิติและความน่าจะเป็น:** ต้องมีโจทย์หา **ค่ากลางของข้อมูล** หรือ **พิสัย** จากชุดข้อมูลที่ **มีค่าบางตัวหายไป** และโจทย์ **ความน่าจะเป็น** ของเหตุการณ์
    * **กฎสำหรับข้อสอบระบายตัวเลข (เติมคำ (พิมพ์ตอบเอง)):** คำตอบสุดท้ายต้องเป็นตัวเลขจำนวนเต็มบวกที่มีค่าไม่เกิน 3 หลัก (0-999) เท่านั้น

* **ลักษณะเฉพาะที่ต้องมีในทุกระดับชั้น (Universal Characteristics):**
    * **โจทย์คิดย้อนกลับ (Reverse Thinking):** ต้องมีโจทย์บางข้อที่ให้ผลลัพธ์สุดท้าย แล้วให้นักเรียนหาค่าเริ่มต้น (เช่น ให้กำไร/ส่วนลดเป็นจำนวนเงิน แล้วถามหาราคาเดิม)
    * **การสังเคราะห์ข้อมูล (Information Synthesis):** ในโจทย์กราฟหรือตาราง ต้องมีคำถามที่บังคับให้นำข้อมูลจากหลายๆ จุดมาเปรียบเทียบหรือคำนวณร่วมกัน
    * **โจทย์แบบประเมินข้อความ (Statement Evaluation):** ต้องมีโจทย์ที่ให้ข้อสรุปมา 2-3 ข้อ (ก, ข, ค) แล้วถามว่า "ข้อใดถูกต้อง" หรือ "มีข้อความที่ถูกต้องกี่ข้อความ"
    * **ลักษณะของตัวลวง (Distractor Characteristics):** ตัวเลือกที่ไม่ถูกต้อง ควรเป็นผลลัพธ์ที่เกิดจากการ **คำนวณผิดพลาดในขั้นตอนที่พบบ่อย** (เช่น ลืมทด, คำนวณผิดเครื่องหมาย, ลืมแปลงหน่วย) หรือเกิดจาก **ความเข้าใจผิดในแนวคิด** (เช่น ใช้สูตรพื้นที่แทนความยาวรอบรูป)

---

**ข้อกำหนดด้านโครงสร้างและรูปแบบ (Structural & Formatting Requirements)**

1.  **กฎเหล็กของการกระจายเนื้อหา (The Golden Rule of Content Distribution):** คุณต้องปฏิบัติตามกระบวนการนี้อย่างเคร่งครัด:
    * **ขั้นตอนที่ 1:** ในตาราง Test Blueprint, ให้มองหา **"กลุ่มของแถว"** ที่อยู่ภายใต้ **'มาตรฐาน'** เดียวกัน (เช่น กลุ่มของแถวทั้งหมดที่อยู่ใน 'มาตรฐาน ค 1.3')
    * **ขั้นตอนที่ 2:** สำหรับ "กลุ่มของแถว" นั้นๆ, ให้ดูที่คอลัมน์ **'รูปแบบข้อสอบ (จำนวนข้อ)'** ซึ่งจะถูกระบุไว้เพียง **ชุดเดียว** สำหรับทั้งกลุ่ม เพื่อหาจำนวนข้อสอบที่ต้องสร้างสำหรับมาตรฐานนั้น (เช่น '4 ตัวเลือก (3 ข้อ)', 'ระบายตัวเลข (1 ข้อ)')
    * **ขั้นตอนที่ 3:** จากนั้น, ให้รวบรวมรายการหัวข้อย่อยทั้งหมดในคอลัมน์ **'สาระการเรียนรู้แกนกลาง'** ที่อยู่ใน "กลุ่มของแถว" นั้นๆ
    * **ขั้นตอนที่ 4 (ภารกิจหลัก):** สร้างข้อสอบตามจำนวนและรูปแบบที่ได้จากขั้นตอนที่ 2 โดยต้องกระจายการสร้างโจทย์ให้ครอบคลุมหัวข้อย่อยที่รวบรวมมาในขั้นตอนที่ 3 ให้ได้มากที่สุดเท่าที่จะเป็นไปได้ **ห้ามสร้างโจทย์หลายข้อจากหัวข้อย่อยเดียวกัน หากยังมีหัวข้อย่อยอื่นในกลุ่มเดียวกันที่ยังไม่ได้ใช้**

2.  **ลำดับข้อสอบและรูปแบบ (Item & Format Sequencing - CRITICAL):** **คุณต้องวิเคราะห์ลำดับของ "ตอนที่" (Part 1, Part 2, Part 3, ...) และ "รูปแบบข้อสอบ" ที่ระบุไว้ในแต่ละตอนจาก Test Blueprint ที่แนบมาอย่างละเอียด** ข้อสอบที่คุณสร้างขึ้นทั้งหมด **ต้อง** ถูกจัดเรียงตามลำดับของ "ตอนที่" และมี "รูปแบบ" ตรงตามที่ปรากฏในเอกสาร Test Blueprint ทุกประการ **ห้ามสลับลำดับ, เปลี่ยนแปลงรูปแบบ, หรือใช้ลำดับจากความจำเดิมโดยเด็ดขาด**

---

**คำสั่งสุดท้าย: การตรวจสอบก่อนส่งมอบ (Final Check Directive)**
ก่อนที่คุณจะสร้าง JSON object สุดท้าย ให้ตรวจสอบอีกครั้ง: "จำนวนคำถามและรูปแบบในแต่ละตอนที่ฉันสร้าง ตรงกับที่ระบุไว้ใน Test Blueprint ทุกประการหรือไม่?" หากไม่ตรง ให้เริ่มกระบวนการใหม่ทั้งหมดทันที

---

**กฎเพิ่มเติม:**
-   คำถามทุกข้อต้องเป็นภาษาไทย
-   ผลลัพธ์ต้องเป็น JSON object ที่สมบูรณ์ตาม Schema ที่กำหนดเท่านั้น
-   **กฎการจัดการโจทย์ที่เป็นภาพ (Visual Problem Handling - CRITICAL):** สำหรับโจทย์ที่ต้องอาศัยรูปภาพในการแก้ปัญหา (เช่น มิติสัมพันธ์, เรขาคณิต, การอ่านแผนที่) ซึ่งไม่สามารถอธิบายได้ด้วยข้อความเพียงอย่างเดียว ให้คุณ **"สร้างคำบรรยายรูปภาพ"** ที่ชัดเจนและละเอียดที่สุด แล้วใส่ไว้ในโจทย์แทนการสร้างรูปภาพ
    * **ตัวอย่าง:** แทนที่จะสร้างโจทย์ที่มีภาพลูกบาศก์ ให้สร้างเป็น "กำหนดให้มีรูปทรงสามมิติที่ประกอบจากลูกบาศก์ขนาดเท่ากัน 16 ลูก วางซ้อนกันเป็นฐาน 4x2 และมีส่วนที่ซ้อนขึ้นไปเป็นชั้นที่ 2 ขนาด 2x2 ตรงกลาง..."
    * **ในกรณีที่ "ตัวเลือก" เป็นรูปภาพ:** ให้ใช้วิธีการเดียวกัน คือสร้างเป็นคำบรรยายลักษณะของรูปภาพในแต่ละตัวเลือก
    * **กฎเหล็ก:** ห้ามสร้างโค้ด SVG หรือข้อความ Placeholder (เช่น 'image_code') ใดๆ ทั้งสิ้นโดยเด็ดขาด ให้ใช้คำบรรยายเท่านั้น
-   **Rule for mathematical expressions: Use LaTeX enclosed only within $...$**
`;

    const mixedQuestionSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, questionType: { type: "STRING", "enum": ["multiple_choice", "short_answer", "true_false", "matching_item"] }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" }, idealAnswer: { type: "STRING" }, correctAnswer: { type: "BOOLEAN" },  imageCode: { type: "STRING" } }, required: ["questionType"] };
    const finalSchema = { type: "OBJECT", properties: { topic: { type: "STRING" }, questions: { type: "ARRAY", items: mixedQuestionSchema } }, required: ["topic", "questions"] };

    parts[0].text = prompt; // ใส่ Prompt ที่สมบูรณ์เข้าไปใน placeholder

    await handleApiCall(parts, 'AI กำลังวิเคราะห์ Blueprint และสร้างแบบทดสอบ...', finalSchema);
}

// ▼▼▼ เพิ่มฟังก์ชันใหม่นี้เข้าไปในส่วน <script> ▼▼▼

function proceedToNextQuestion(answerData) {
    // 1. เก็บคำตอบที่สมบูรณ์แล้ว
    studentAnswersPerQuestion.push(answerData);
    
    // 2. เลื่อนไปยังคำถามข้อถัดไป
    currentQuestionIndex++;

    // 3. ตรวจสอบว่าทำครบทุกข้อหรือยัง
    if (currentQuestionIndex >= currentDisplayedQuiz.questions.length) {
        // ถ้าครบแล้ว ให้สรุปผล
        finalizePerQuestionQuiz();
    } else {
        // ถ้ายังไม่ครบ ให้แสดงข้อถัดไป
        renderPerQuestionView();
    }
}

// ฟังก์ชันสร้าง HTML แสดงเงินกองกลาง
function getCentralPotHTML(gameData) {
    const potValue = gameData.centralPot || 0;
    const isMarketMode = gameData.isBlackMarketEnabled === true;

    // ถ้าไม่ได้เปิดโหมดตลาดมืด ไม่ต้องแสดง
    if (!isMarketMode) return '';

    // ถ้ากองกลางเป็น 0 แสดงแบบเรียบๆ
    if (potValue === 0) {
        return `
            <div class="flex items-center gap-2 bg-black/20 px-3 py-1 rounded-full border border-white/10 text-gray-300 text-sm">
                <i class="fas fa-sack-dollar"></i>
                <span>กองกลาง: 0</span>
            </div>
        `;
    }

    // ถ้ามีเงินในกองกลาง ให้แสดงแบบสีทองและมี Animation
    return `
        <div class="flex items-center gap-2 bg-gradient-to-r from-yellow-500 to-amber-600 text-white px-4 py-1 rounded-full border-2 border-yellow-200 shadow-lg shadow-yellow-500/50 animate-pulse transform hover:scale-105 transition-transform cursor-help" title="เงินรางวัลส่วนเกินจากรอบที่แล้ว จะถูกนำมาหารเพิ่มให้ผู้ชนะในรอบนี้!">
            <i class="fas fa-sack-dollar text-xl animate-bounce"></i>
            <span class="font-bold text-lg drop-shadow-md">กองกลาง: ${potValue.toLocaleString()}</span>
        </div>
    `;
}

function renderAdminSyncDashboard(gameData, isAdmin, questionIndexToShow) {
    const players = Object.values(gameData.players || {});
    const totalPlayers = players.length;
    const currentQuestionIndex = questionIndexToShow; 

    const variant = gameData.gameVariant || 'classic';
    
    const isAnonymousMode = (variant === 'anonymous' || variant === 'anonymous_reveal_end');
    const isRevealAtEndMode = (variant === 'reveal_at_end' || variant === 'anonymous_reveal_end');
    const isRevealed = (gameData.isAnonymousRevealed === true);
    const isCompetitionMode = (variant === 'competition');

    const questions = gameData.shuffledQuiz.questions;
    const currentQuestion = questions[currentQuestionIndex]; 
    const toChar = (index) => String.fromCharCode(65 + index);
    
    // 1. เตรียมข้อมูลผู้เล่น และคำนวณคะแนนใหม่
    const playersWithScores = players.map(p => {
        const answersToConsider = (p.answers || []).filter(ans => {
            if (isRevealAtEndMode) {
                return ans.questionIndex <= currentQuestionIndex;
            }
            return true; 
        });
        
        let realScore = 0;
        let points = 0;

        if (isRevealAtEndMode) {
            realScore = answersToConsider.filter(a => a.isCorrect).length;
            points = answersToConsider.reduce((sum, a) => sum + (a.pointsAwarded || 0), 0);
        } else {
            realScore = p.score || 0;
            points = p.totalPoints || 0;
        }

        // --- [FIX LOGIC START] การคำนวณ Streak แบบเข้มงวด ---
        let dynamicStreak = 0;
        
        // วนลูปตรวจสอบตั้งแต่ข้อ 0 จนถึงข้อปัจจุบัน
        for (let i = 0; i <= currentQuestionIndex; i++) {
            // หาคำตอบของข้อที่ i
            const ans = answersToConsider.find(a => a.questionIndex === i);
            
            if (ans) {
                // ถ้ามีคำตอบ
                const isComboBreaker = (ans.powerupUsed && ans.powerupUsed !== 'wagerMultiplier') || ans.usedBuyTime;
                if (ans.isCorrect) {
                     if (isComboBreaker) {
                        dynamicStreak = 0; 
                    } else {
                        dynamicStreak++;
                    }
                } else {
                    dynamicStreak = 0; // ตอบผิด = รีเซ็ต
                }
            } else {
                // [เพิ่มใหม่] ถ้าไม่มีคำตอบในข้อที่ i (หมดเวลา/ไม่ได้ตอบ)
                // ให้ถือว่าผิด และรีเซ็ต Streak ทันที
                dynamicStreak = 0;
            }
        }
        // --- [FIX LOGIC END] ---
        
        return {
            ...p, 
            realScore: realScore,
            totalPoints: points,
            answers: answersToConsider,
            correctStreak: dynamicStreak // ใช้ค่าที่คำนวณใหม่นี้
        };
    });

    const maxPoints = Math.max(...playersWithScores.map(p => p.totalPoints), -Infinity);
    const maxRawScore = Math.max(...playersWithScores.map(p => p.realScore), -Infinity);

    const isMarketMode = gameData.isBlackMarketEnabled === true;

    // 2. จัดเรียง (Sorting)
    const sortedPlayers = [...playersWithScores].sort((a, b) => {
        if (isMarketMode) {
            const pointsDiff = b.totalPoints - a.totalPoints;
            if (pointsDiff !== 0) return pointsDiff;
            const scoreDiff = b.realScore - a.realScore;
            if (scoreDiff !== 0) return scoreDiff;
            return (a.name || '').localeCompare(b.name || '', 'th');
        } else {
            const pointsDiff = b.totalPoints - a.totalPoints;
            if (pointsDiff !== 0) return pointsDiff;
            const scoreDiff = b.realScore - a.realScore;
            if (scoreDiff !== 0) return scoreDiff;
            return (a.name || '').localeCompare(b.name || '', 'th');
        }
    });

    // คำนวณอันดับ
    let currentRank = 1;
    for (let i = 0; i < sortedPlayers.length; i++) {
        if (i > 0) {
            const prev = sortedPlayers[i - 1];
            const curr = sortedPlayers[i];
            
            let isTied = false;
            if (isMarketMode) {
                isTied = (curr.totalPoints === prev.totalPoints) && (curr.realScore === prev.realScore);
            } else {
                isTied = (curr.totalPoints === prev.totalPoints) && (curr.realScore === prev.realScore);
            }

            if (!isTied) {
                currentRank = i + 1;
            }
        }
        sortedPlayers[i].displayRank = currentRank;
    }
    
    // ส่วนแสดงเฉลย
    let currentAnswerDisplayHTML = '';
    const shouldShowAnswer = !isCompetitionMode && !(isAnonymousMode && gameData.showAnswerInAnonymous === false);

    if (currentQuestion && shouldShowAnswer) {
        let correctAnswerText = '';
        let correctAnswerLabel = '';
        const questionType = currentQuestion.questionType || gameData.shuffledQuiz.quizType;
        
        if (questionType === 'multiple_choice' && currentQuestion.options) {
            const idx = currentQuestion.correctAnswerIndex;
            correctAnswerText = currentQuestion.options[idx];
            correctAnswerLabel = toChar(idx) + '.';
        } else if (questionType === 'true_false') {
            const isTrue = (String(currentQuestion.correctAnswer).toLowerCase() === 'true');
            correctAnswerText = isTrue ? 'ใช่ / ถูก' : 'ไม่ใช่ / ผิด';
            correctAnswerLabel = isTrue ? 'ก.' : 'ข.';
        } else if (questionType === 'matching_item') {
            correctAnswerText = currentQuestion.correctResponse || '-';
        } else if (questionType === 'short_answer' || questionType === 'fill_in_no_choices') {
            correctAnswerText = currentQuestion.idealAnswer || '-';
        }

        if (correctAnswerText) {
     currentAnswerDisplayHTML = `
        <div class="text-center my-4 py-4 bg-black/20 rounded-lg shadow-inner relative group">
            <div class="w-11/12 mx-auto" style="border-top: 2px dashed rgba(255, 255, 255, 0.3);"></div>

            <p class="text-xl text-yellow-300 mt-3 font-semibold">
                เฉลยคำตอบข้อที่ ${currentQuestionIndex + 1}:
            </p>

            <div class="flex justify-center items-center gap-3 mt-1">
                <p id="main-correct-answer-display" class="text-4xl font-bold text-white">
                    ${correctAnswerLabel} ${correctAnswerText}
                </p>

                <button id="edit-answer-dashboard-btn" class="bg-gray-700 hover:bg-yellow-500 hover:text-black text-gray-300 p-2 rounded-full transition-all shadow-lg border border-gray-500" title="เฉลยผิด? แก้ไขทันที">
                    <i class="fas fa-wrench"></i>
                </button>
            </div>

            <div class="w-11/12 mx-auto mt-3" style="border-top: 2px dashed rgba(255, 255, 255, 0.3);"></div>
        </div>
    `;
}
    }

    const scoresHtml = sortedPlayers.map((p, index) => {
        const realScoreSoFar = p.realScore;
        const pointsValue = p.totalPoints;
        const currentTurnAnswer = (p.answers || []).find(ans => ans.questionIndex === questionIndexToShow);
        const totalAnswersSoFar = p.answers.length;

        // --- 1. ป้าย Pot Bonus (ปรับให้เด่นขึ้น) ---
        let potBonusHTML = '';
        if (currentTurnAnswer && currentTurnAnswer.potBonus > 0) {
            potBonusHTML = `<div class="text-[10px] bg-yellow-300 text-black px-1.5 rounded-full font-bold inline-block border border-yellow-500 shadow-sm mt-0.5" title="ส่วนแบ่งจากกองกลาง">+${currentTurnAnswer.potBonus} Pot</div>`;
        }

        // --- 2. ไอคอนสถานะ ---
        let turnStatusIconsHTML = '';
        if (currentTurnAnswer) {
            if (currentTurnAnswer.wasForced) turnStatusIconsHTML += '<span title="โดนบังคับมั่นใจ">👻</span>';
            if (currentTurnAnswer.wasJinxed) turnStatusIconsHTML += '<span title="โดนคำสาป">😈</span>';
            if (currentTurnAnswer.usedBuyTime) turnStatusIconsHTML += '<span title="ใช้เวลา">⏳</span>';
            
            const item = currentTurnAnswer.powerupUsed;
            if (item) {
                const icons = { 'poll': '📊', 'cutOne': '✂️', 'insurance': '🛡️', 'fiftyFifty': '🌗', 'wagerMultiplier': '💰', 'secondChance': '🔁', 'revealOptions': '👁️' };
                if (icons[item]) turnStatusIconsHTML += `<span title="ใช้ไอเทม">${icons[item]}</span>`;
            }
        }

        let statusIconHTML = ''; 
        const currentStreak = p.correctStreak || 0; 
        const turnUsedBuyTime = currentTurnAnswer && currentTurnAnswer.usedBuyTime;
        const turnUsedItem = currentTurnAnswer && currentTurnAnswer.powerupUsed && currentTurnAnswer.powerupUsed !== 'wagerMultiplier';

        // ไอคอนไฟ (Fire)
        let fireIconHTML = '';
        if (!isCompetitionMode && currentStreak >= 3 && !turnUsedBuyTime && !turnUsedItem) {
            fireIconHTML = `<span class="text-orange-500 animate-pulse font-bold text-xs ml-1 whitespace-nowrap drop-shadow-sm filter">🔥x${currentStreak}</span>`;
        }

        // ไอคอนมงกุฎ/ดาว
        if (!isCompetitionMode && totalAnswersSoFar > 0) {
            if (isMarketMode) {
                if (pointsValue === maxPoints && maxPoints > 0) statusIconHTML += '<span class="text-yellow-400 ml-1 text-lg drop-shadow-md" title="เจ้าพ่อตลาดมืด">👑</span>';
                if (realScoreSoFar === maxRawScore && maxRawScore > 0) statusIconHTML += '<span class="text-blue-300 ml-1 text-lg drop-shadow-md" title="เทพวิชาการ">🎓</span>';
            } else {
               const isPerfectSoFar = (p.realScore === (questionIndexToShow + 1));
               if (isPerfectSoFar) statusIconHTML += '<span class="text-yellow-400 ml-1 text-lg drop-shadow-md">⭐</span>';
            }
            if (statusIconHTML === '' && pointsValue < 0) statusIconHTML += '<span class="text-red-500 ml-1 text-lg drop-shadow-md">⚠️</span>';
        }
        
        // --- 3. กำหนดสีพื้นหลังแบบเข้ม (Vivid Colors) ---
        let highlightClass = 'bg-white border-l-4 border-gray-300 text-gray-800'; // สีเริ่มต้น (ขาว)
        let subTextColor = 'text-gray-500'; // สีของชื่อรอง (Nickname)
        let isWagerFail = false;

        if (!isCompetitionMode) { 
            const latestAnswer = (p.answers || []).find(ans => ans.questionIndex === currentQuestionIndex);
            
            if (latestAnswer) {
                const isCorrect = latestAnswer.isCorrect;
                const isConfident = (latestAnswer.wasConfident === true || latestAnswer.wasConfident === 'confident');
                const powerupUsed = latestAnswer.powerupUsed;

                if (powerupUsed === 'wagerMultiplier') {
                    if (isCorrect) { 
                        // เดิมพันถูก: สีเหลืองทองเข้ม (ตัวหนังสือดำ)
                        highlightClass = 'bg-yellow-400 border-l-4 border-yellow-600 text-black font-bold shadow-md'; 
                        subTextColor = 'text-yellow-900/70';
                    } else { 
                        // เดิมพันผิด: สีแดงสด (ตัวหนังสือขาว)
                        highlightClass = 'bg-red-600 border-l-4 border-red-800 text-white font-bold shadow-md'; 
                        subTextColor = 'text-red-200';
                        isWagerFail = true;
                    }
                } else if (isCorrect) {
                    if (isConfident) {
                        // ถูก+มั่นใจ: สีเขียวเข้ม (ตัวหนังสือขาว)
                        highlightClass = 'bg-green-600 border-l-4 border-green-800 text-white font-bold shadow-md';
                        subTextColor = 'text-green-200';
                    } else {
                        // ถูกเฉยๆ: สีเขียวอ่อน (ตัวหนังสือเขียวเข้ม)
                        highlightClass = 'bg-green-200 border-l-4 border-green-500 text-green-900';
                        subTextColor = 'text-green-700';
                    }
                } else {
                    if (isConfident) {
                        // ผิด+มั่นใจ: สีส้มแดงเข้ม (ตัวหนังสือขาว)
                        highlightClass = 'bg-orange-600 border-l-4 border-orange-800 text-white font-bold shadow-md';
                        subTextColor = 'text-orange-200';
                    } else {
                        // ผิดเฉยๆ: สีแดงอ่อน (ตัวหนังสือแดงเข้ม)
                        highlightClass = 'bg-red-100 border-l-4 border-red-400 text-red-900';
                        subTextColor = 'text-red-700';
                    }
                }
            } else {
                // ไม่ตอบ/หมดเวลา: สีเทา (ตัวหนังสือเทาเข้ม)
                highlightClass = 'bg-gray-100 border-l-4 border-gray-400 text-gray-500';
            }
        }
        
        // --- 4. จัดการชื่อ (Name Display) ---
        const realName = p.name;
        const nickname = gameData.playerNicknames[p.name] || '???';
        let nameToShow = realName;
        let subNameToShow = '';

        if (isAdmin) {
            if (isAnonymousMode && !isRevealed) {
                nameToShow = nickname;
                subNameToShow = `(${nickname})`; 
                if(isWagerFail) subNameToShow += ` [${realName}]`; 
            } else if (isAnonymousMode && isRevealed) {
                subNameToShow = `(${nickname})`;
            }
        }
        
        // --- 5. จัดการคะแนน (Score Display) ---
        const pointsDisplay = pointsValue >= 0 ? `+${(pointsValue).toLocaleString()}` : `${(pointsValue).toLocaleString()}`;
        
        const scoreBlockHTML = !isCompetitionMode ? `
            <div class="text-right flex-shrink-0 ml-2">
                <div class="font-bold text-lg leading-none">${realScoreSoFar}</div>
                <div class="text-xs opacity-90 font-medium mt-0.5">(${pointsDisplay} P)</div>
                ${potBonusHTML}
            </div>
        ` : '';

        return `
            <div class="flex justify-between items-center p-2.5 mb-2 rounded-lg shadow-sm transition-all duration-300 ${highlightClass}">
                
                <div class="flex items-center gap-3 overflow-hidden">
                    
                    <div class="flex-shrink-0 w-7 h-7 flex items-center justify-center rounded-full bg-black/20 font-bold text-sm">
                        ${p.displayRank}
                    </div>

                    <div class="flex flex-col min-w-0">
                        <div class="flex items-center gap-1">
                            <span class="font-bold text-sm sm:text-base truncate block" title="${nameToShow}">
                                ${nameToShow}
                            </span>
                            ${statusIconHTML}
                            ${fireIconHTML}
                        </div>
                        
                        <div class="flex items-center gap-1 text-xs ${subTextColor} truncate font-normal">
                            ${subNameToShow ? `<span class="mr-1">${subNameToShow}</span>` : ''}
                            ${turnStatusIconsHTML}
                        </div>
                    </div>
                </div>

                ${scoreBlockHTML}

            </div>`;
    }).join('');

    const perQuestionHtml = questions.map((q, index) => {
        if ((isRevealAtEndMode && index > currentQuestionIndex) || isCompetitionMode) { return ''; }
        const correctCount = playersWithScores.filter(p => p.answers && p.answers.find(ans => ans.questionIndex === index && ans.isCorrect)).length;
        const isCurrentQuestion = (index === currentQuestionIndex); 
        const cardClasses = isCurrentQuestion 
            ? 'p-2 rounded-md bg-yellow-400 text-black ring-2 ring-yellow-200 shadow-lg' 
            : 'p-2 bg-black/10 rounded-md';
        return `
            <div class="${cardClasses}">
                <p class="font-semibold text-sm">ข้อ ${index + 1}:</p>
                <p class="text-xs">${correctCount} / ${totalPlayers} คน ตอบถูก</p>
            </div>`;
    }).join('');

    let controlButtonHtml = '';
    let adminHeaderControls = '';
    
    if (isAdmin) {
        const isClassicLast = (variant === 'classic' && gameData.currentQuestionIndex >= questions.length - 1);
        const isRevealLast = (isRevealAtEndMode && gameData.reviewQuestionIndex >= questions.length - 1);
        const isCompetitionLast = (variant === 'competition' && gameData.currentQuestionIndex >= questions.length - 1);
        const isAnonymousLast = (isAnonymousMode && !isRevealAtEndMode && gameData.currentQuestionIndex >= questions.length - 1);
        
        if (isRevealAtEndMode) {
            if (isRevealLast) {
                if (isAnonymousMode && !isRevealed) {
                    controlButtonHtml = `<div class="flex gap-4"><button id="reveal-names-btn" class="w-1/2 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg text-xl"><i class="fas fa-eye"></i> เปิดเผยชื่อจริง</button><button id="next-sync-question-btn" class="w-1/2 bg-gray-800 hover:bg-black text-white font-bold py-3 px-6 rounded-lg text-xl">ดู Podium <i class="fas fa-trophy"></i></button></div>`;
                } else {
                    controlButtonHtml = `<button id="next-sync-question-btn" class="w-full bg-gray-800 hover:bg-black text-white font-bold py-3 px-6 rounded-lg text-xl">ดู Podium <i class="fas fa-trophy"></i></button>`;
                }
            } else {
                controlButtonHtml = `<button id="next-review-question-btn" class="w-full bg-gray-800 hover:bg-black text-white font-bold py-3 px-6 rounded-lg text-xl">เฉลยข้อต่อไป <i class="fas fa-arrow-right"></i></button>`;
            }
        } else if (isClassicLast || isCompetitionLast || isAnonymousLast) { 
             if (isAnonymousMode && !isRevealed) {
                 controlButtonHtml = `<div class="flex gap-4"><button id="reveal-names-btn" class="w-1/2 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg text-xl"><i class="fas fa-eye"></i> เปิดเผยชื่อจริง</button><button id="next-sync-question-btn" class="w-1/2 bg-gray-800 hover:bg-black text-white font-bold py-3 px-6 rounded-lg text-xl">ดู Podium <i class="fas fa-trophy"></i></button></div>`;
             } else {
                 controlButtonHtml = `<button id="next-sync-question-btn" class="w-full bg-gray-800 hover:bg-black text-white font-bold py-3 px-6 rounded-lg text-xl">ดู Podium <i class="fas fa-trophy"></i></button>`;
             }
        } else {
             controlButtonHtml = `<button id="next-sync-question-btn" class="w-full bg-gray-800 hover:bg-black text-white font-bold py-3 px-6 rounded-lg text-xl">ข้อต่อไป <i class="fas fa-arrow-right"></i></button>`;
        }
        adminHeaderControls = `<button id="end-sync-game-btn" class="bg-red-600 text-white py-1 px-3 rounded-md hover:bg-red-700 text-sm shrink-0">จบเกม</button>`;
    }

    const summaryColumnHTML = (isCompetitionMode || (isAnonymousMode && !gameData.showAnswerInAnonymous)) ? '' : `<div class="md:col-span-2"><h4 class="font-bold mb-2">สรุปรายข้อ</h4><div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2">${perQuestionHtml}</div></div>`;
    const scoreColumnClass = (isCompetitionMode || (isAnonymousMode && !gameData.showAnswerInAnonymous)) ? 'md:col-span-3' : 'md:col-span-1';
    
    const potHTML = getCentralPotHTML(gameData); 

    const dashboardHtml = `
        <div class="bg-indigo-700 text-white rounded-lg p-6 flex flex-col h-full">
            <div class="flex justify-between items-center mb-2">
                <div class="flex items-center gap-4">
                    <h2 class="text-2xl font-bold">Dashboard: ${gameData.shuffledQuiz.topic}</h2>
                    <span class="bg-white/20 px-3 py-1 rounded-full text-base font-mono" title="รหัสเข้าร่วมเกม">
                        PIN: <strong class="font-bold">${gameData.pin}</strong>
                    </span>
                    
                    ${potHTML}
                </div>
                ${adminHeaderControls}
            </div>
            ${currentAnswerDisplayHTML}
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 flex-grow overflow-y-auto pr-2">
                <div class="${scoreColumnClass}"><h4 class="font-bold mb-2">สรุปคะแนน (รายบุคคล)</h4><div class="space-y-1 text-lg">${scoresHtml || '<p class="text-sm">ยังไม่มีผู้เล่น</p>'}</div></div>
                ${summaryColumnHTML}
            </div>

            ${isAdmin ? `<div class="mt-4 pt-4 border-t border-white/20">${controlButtonHtml}</div>` : ''}
        </div>
    `;

    liveGameView.innerHTML = dashboardHtml;
    
    if (window.MathJax) {
        const answerDisplayElement = document.getElementById('main-correct-answer-display');
        if (answerDisplayElement) { MathJax.typesetPromise([answerDisplayElement]); }
    }

    if (isAdmin) {
        const nextSyncBtn = document.getElementById('next-sync-question-btn');
        if (nextSyncBtn) {
            nextSyncBtn.onclick = async () => {
                const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
                const nextIndex = gameData.currentQuestionIndex + 1;
                const totalQ = gameData.shuffledQuiz.questions.length;

                if (!isRevealAtEndMode && nextIndex < totalQ) {
                    await updateDoc(gameRef, { 
                        status: 'question', 
                        currentQuestionIndex: nextIndex,
                        questionDisplayedAt: serverTimestamp(),
                        scoresCalculated: false 
                    });
                } else { 
                    await updateDoc(gameRef, { status: 'podium' }); 
                }
            };
        }

        const nextReviewBtn = document.getElementById('next-review-question-btn');
        if (nextReviewBtn) {
            nextReviewBtn.onclick = async () => {
                const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
                await updateDoc(gameRef, { 
                    reviewQuestionIndex: increment(1) 
                });
            };
        }

        document.getElementById('reveal-names-btn')?.addEventListener('click', async () => {
            await updateDoc(doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId), { isAnonymousRevealed: true });
        });
        
        const endBtn = document.getElementById('end-sync-game-btn');
        if (endBtn) {
            endBtn.onclick = () => {
                showConfirmation( 'คุณแน่ใจหรือไม่ว่าต้องการจบเกมนี้ก่อนเวลาอันควร?', async () => {
                    await updateDoc(doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId), { status: 'podium' });
                });
            };
        }
    }
	
	const editAnsDashBtn = document.getElementById('edit-answer-dashboard-btn');
        if (editAnsDashBtn) {
            editAnsDashBtn.onclick = () => {
                const currentQ = gameData.shuffledQuiz.questions[gameData.currentQuestionIndex];
                const qType = currentQ.questionType || gameData.shuffledQuiz.quizType;
                const isShortAnswer = (qType === 'short_answer' || qType === 'fill_in_no_choices');

                if (isShortAnswer) {
                    // กรณีเติมคำ: (เหมือนเดิม)
                    const newCorrectText = prompt(`เฉลยปัจจุบันคือ "${currentQ.idealAnswer}"\n\nกรุณากรอก "คำตอบที่ถูกต้อง" ใหม่ที่ต้องการ:`);
                    if (newCorrectText !== null && newCorrectText.trim() !== "") {
                        handleEmergencyAnswerFix(newCorrectText.trim(), gameData);
                    }
                } else {
                    // กรณีช้อยส์: (แก้ไขข้อความ + สูตรคำนวณ)
                    const newCorrectStr = prompt("เฉลยผิดใช่ไหม? กรุณาระบุตัวเลข Index ของข้อที่ถูกจริง (1=ก, 2=ข, 3=ค, 4=ง):");
                    
                    if (newCorrectStr !== null && newCorrectStr.trim() !== "") {
                        const inputVal = parseInt(newCorrectStr.trim());
                        
                        if (!isNaN(inputVal) && inputVal >= 1) {
                            // แปลงจาก 1-based (มนุษย์) เป็น 0-based (คอมพิวเตอร์)
                            // เช่น กรอก 1 (ก) -> ส่งไป 0
                            // กรอก 2 (ข) -> ส่งไป 1
                            const finalIndex = inputVal - 1;
                            handleEmergencyAnswerFix(finalIndex, gameData);
                        } else {
                            alert("กรุณากรอกเป็นตัวเลขที่ถูกต้อง (เช่น 1, 2, 3, 4)");
                        }
                    }
                }
            };
        }
	
}

async function handleGenerateParallelFromBank(originalQuizData) {
    const resultsContentContainer = document.getElementById('results-tab-content');
    const quizzesListContainer = document.getElementById('project-quizzes-list');
    
    quizzesListContainer.classList.add('hidden');

    const loaderHtml = `
        <div id="temp-loader-results" class="text-center py-16">
            <div class="loader mx-auto"></div>
            <p id="temp-loader-text-results" class="mt-4 text-gray-600">กำลังวิเคราะห์ข้อสอบ "${originalQuizData.topic}"...</p>
        </div>
    `;
    resultsContentContainer.insertAdjacentHTML('beforeend', loaderHtml);
    const loaderText = document.getElementById('temp-loader-text-results');

    try {
        const originalTestText = originalQuizData.questions.map((q, index) => {
            let questionString = `${index + 1}. ${q.questionText || q.stem}\n`;
            if (q.options) {
                questionString += q.options.map((opt, i) => `   - ${i === q.correctAnswerIndex ? '[*]' : ''} ${opt}`).join('\n');
            } else if (q.idealAnswer) {
                questionString += `   - คำตอบ: ${q.idealAnswer}`;
            }
            return questionString;
        }).join('\n\n');

        loaderText.textContent = 'วิเคราะห์สำเร็จ! กำลังสร้างแบบทดสอบคู่ขนาน...';

        const prompt = `
            คุณคือผู้เชี่ยวชาญด้านการวัดผลและประเมินผลทางการศึกษา
            นี่คือข้อมูลของแบบทดสอบต้นฉบับชุดหนึ่งในหัวข้อ "${originalQuizData.topic}":
            ---
            ${originalTestText}
            ---
            ภารกิจของคุณคือ:
            1.  วิเคราะห์ข้อสอบต้นฉบับนี้เพื่อทำความเข้าใจขอบเขตเนื้อหา, รูปแบบคำถาม, และระดับความยาก
            2.  สร้าง "แบบทดสอบคู่ขนาน" (Parallel Test) ขึ้นมา 1 ชุด ซึ่งต้องวัดความรู้ในเรื่องเดียวกันและมีระดับความยากเท่ากัน
            3.  **ห้ามคัดลอกโจทย์, ตัวเลข, หรือสถานการณ์เดิมมาโดยเด็ดขาด** ต้องสร้างขึ้นมาใหม่ทั้งหมดให้มีความ "สมมูล" กัน
            4.  จำนวนข้อและประเภทของคำถามต้องตรงกับต้นฉบับทุกประการ
            5.  สร้างคำถามเป็นภาษาไทยทั้งหมด
            ${simpleMathPrompt}
        `;
        const mixedQuestionSchema = { type: "OBJECT", properties: { questionText: { "type": "STRING" }, questionType: { "type": "STRING", "enum": ["multiple_choice", "short_answer", "true_false", "matching_item"] }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" }, idealAnswer: { type: "STRING" }, correctAnswer: { type: "BOOLEAN" }, stem: { type: "STRING" }, correctResponse: { type: "STRING" }, allResponses: { type: "ARRAY", items: { type: "STRING" } },  imageCode: { type: "STRING" } }, required: ["questionType"] };
        const finalSchema = { type: "OBJECT", properties: { topic: { type: "STRING" }, questions: { type: "ARRAY", items: mixedQuestionSchema } }, required: ["topic", "questions"] };

        const newQuizDataFromAI = await callAnalysisApi(prompt, finalSchema);

        // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        // --- จุดแก้ไข: เพิ่ม ID ให้กับทุกคำถามก่อนบันทึก ---
        const questionsWithIds = newQuizDataFromAI.questions.map((q, index) => ({
            ...q, // คัดลอกข้อมูลคำถามเดิมจาก AI ทั้งหมด
            id: `q_${Date.now()}_${index}` // เพิ่ม property 'id' ที่ไม่ซ้ำกันเข้าไป
        }));
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        const newTopic = `(คู่ขนาน) ${originalQuizData.topic}`;

        const dataToSave = {
            topic: newTopic, 
            questions: questionsWithIds, // <-- ใช้ตัวแปรใหม่ที่มี ID แล้ว
            quizType: originalQuizData.quizType,
            projectId: currentProjectId,
            createdBy: userId,
            createdAt: new Date().toISOString(),
            status: 'active',
            settings: originalQuizData.settings, 
            quizMode: 'standard',
            pairedQuizId: null,
            lessonPlan: null
        };
        
        // สร้าง ID ใหม่แบบสุ่ม 4 หลัก และตรวจสอบว่าไม่ซ้ำกับของเดิม
let newQuizId;
while (true) {
    newQuizId = Math.floor(1000 + Math.random() * 9000).toString();
    const existing = await getDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId));
    if (!existing.exists()) break;
}
// บันทึกแบบทดสอบด้วย ID 4 หลักที่สร้างขึ้น
await setDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId), dataToSave);
        showMessage("สร้างแบบทดสอบคู่ขนานสำเร็จแล้ว!");

    } catch (error) {
        console.error("Error generating parallel test from bank:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
    } finally {
        const tempLoader = document.getElementById('temp-loader-results');
        if (tempLoader) {
            tempLoader.remove();
        }
        quizzesListContainer.classList.remove('hidden');
    }
}

/// ▼▼▼ วางทับฟังก์ชันนี้ทั้งหมด ▼▼▼
async function handleGenerateParallelPostTest(originalPreTestQuizData) {
    const resultsContentContainer = document.getElementById('results-tab-content');
    const quizzesListContainer = document.getElementById('project-quizzes-list');
    
    quizzesListContainer.classList.add('hidden');
    const loaderHtml = `
        <div id="temp-loader-results" class="text-center py-16">
            <div class="loader mx-auto"></div>
            <p id="temp-loader-text-results" class="mt-4 text-gray-600">กำลังวิเคราะห์ Pre-test และสร้าง Post-test คู่ขนาน...</p>
        </div>
    `;
    resultsContentContainer.insertAdjacentHTML('beforeend', loaderHtml);

    try {
        const originalTestText = originalPreTestQuizData.questions.map((q, index) => {
            let qText = `${index + 1}. ${q.questionText || q.stem}`;
            if (q.options) qText += `\n   - ตัวเลือก: ${q.options.join(', ')}`;
            return qText;
        }).join('\n\n');
        
        const prompt = `
            จากข้อสอบก่อนเรียน (Pre-test) ในหัวข้อ "${originalPreTestQuizData.topic}" ต่อไปนี้:
            ---
            ${originalTestText}
            ---
            จงสร้างแบบทดสอบหลังเรียน (Post-test) ที่เป็น "คู่ขนาน" กัน โดยมีข้อกำหนดดังนี้:
            1. ต้องเป็นข้อสอบที่วัดผลในเรื่องเดียวกันและมีระดับความยากเท่ากันทุกประการ
            2. ต้องสร้างโจทย์และตัวเลือกขึ้นมาใหม่ทั้งหมด ห้ามใช้โจทย์หรือตัวเลขเดิม
            3. จำนวนข้อและประเภทคำถามต้องเหมือนกับ Pre-test ทุกประการ
            ${simpleMathPrompt}
        `;
        const schema = { type: "OBJECT", properties: { topic: { type: "STRING" }, questions: { type: "ARRAY", items: { type: "OBJECT", properties: { questionText: { type: "STRING" }, questionType: { type: "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" }, idealAnswer: { type: "STRING" } }, required: ["questionText"] } } }, required: ["topic", "questions"] };

        const postTestQuizDataFromAI = await callAnalysisApi(prompt, schema);

        const baseTopic = originalPreTestQuizData.topic.replace('(ก่อนเรียน)', '').trim();
        const newPostTestTopic = `(หลังเรียน) ${baseTopic}`;

        const postTestDataToSave = {
            ...postTestQuizDataFromAI,
            topic: newPostTestTopic,
            quizType: originalPreTestQuizData.quizType,
            projectId: currentProjectId,
            createdBy: userId,
            createdAt: new Date().toISOString(),
            status: 'active',
            settings: originalPreTestQuizData.settings,
            quizMode: 'post-test',
            pairedQuizId: originalPreTestQuizData.id
        };
        
        // --- ส่วนที่แก้ไข: เปลี่ยนมาใช้การสุ่มรหัส 4 หลัก ---
        let newPostTestId;
        while (true) {
            newPostTestId = Math.floor(1000 + Math.random() * 9000).toString();
            const existing = await getDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newPostTestId));
            if (!existing.exists()) break;
        }
        await setDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newPostTestId), postTestDataToSave);
        
        const originalPreTestRef = doc(db, `artifacts/${appId}/public/data/quizzes`, originalPreTestQuizData.id);
        await updateDoc(originalPreTestRef, {
            pairedQuizId: newPostTestId // อัปเดต Pre-test ให้รู้จัก ID ใหม่
        });
        // --- สิ้นสุดส่วนที่แก้ไข ---

        showMessage("สร้างและจับคู่ Post-test สำเร็จ!");

    } catch (error) {
        console.error("Error generating parallel post-test:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
    } finally {
        const tempLoader = document.getElementById('temp-loader-results');
        if (tempLoader) tempLoader.remove();
        quizzesListContainer.classList.remove('hidden');
    }
}

async function handleGenerateParallelTest(shortcutFile = null) {
    let fileToProcess = shortcutFile;

    // ถ้าไม่ได้มาจากปุ่มลัด ให้ดึงไฟล์จากการอัปโหลดตามปกติ
    if (!fileToProcess) {
        const parallelTestInput = document.getElementById('parallel-test-upload-input');
        if (parallelTestInput.files.length > 0) {
            fileToProcess = parallelTestInput.files[0];
        }
    }
    
    if (!fileToProcess) {
        showMessage("กรุณาเลือกไฟล์ข้อสอบต้นฉบับ หรือใช้ปุ่มลัด");
        return;
    }

    const loader = document.getElementById('loader');
    const loaderText = document.getElementById('loader-text');
    const genQuizContainer = document.getElementById('generated-quiz-container');
    const generateBtn = document.getElementById('generate-from-parallel-test-btn');

    generateBtn.disabled = true;
    document.getElementById('quiz-generation-area').classList.remove('hidden');
    genQuizContainer.innerHTML = '';
    loader.classList.remove('hidden');
    loaderText.textContent = 'กำลังอ่านและเตรียมไฟล์ต้นฉบับ...';

    const reader = new FileReader();
    reader.readAsDataURL(fileToProcess);
    reader.onload = async () => {
        try {
            const base64String = reader.result.split(',')[1];
            const mimeType = fileToProcess.type;
            
            loaderText.textContent = 'วิเคราะห์ไฟล์สำเร็จ! กำลังสร้างแบบทดสอบคู่ขนาน...';
            
            const includeImages = document.getElementById('include-images-checkbox').checked;
            const imageInstruction = includeImages ? `สำหรับคำถามแต่ละข้อ หากจำเป็นต้องมีรูปภาพประกอบ (เช่น รูปเรขาคณิต, กราฟ) ให้สร้างโค้ด SVG ที่สมบูรณ์สำหรับรูปนั้นๆ แล้วใส่ไว้ใน property ชื่อ "imageCode".` : '';
            
            // === [UPDATED] Sharp Distractor Logic ===
            const prompt = `
                **คุณคือผู้เชี่ยวชาญด้านการวัดผลและประเมินผลทางการศึกษา
                ภารกิจของคุณคือวิเคราะห์ "ไฟล์ข้อสอบต้นฉบับที่แนบมานี้" อย่างละเอียด เพื่อทำความเข้าใจโครงสร้าง, ขอบเขตเนื้อหา, และระดับความยาก จากนั้นให้สร้าง "แบบทดสอบคู่ขนาน" (Parallel Test) ขึ้นมา 1 ชุด ซึ่งต้องวัดผลในเรื่องเดียวกันและมีระดับความยากเท่ากัน แต่ต้องสร้างโจทย์และตัวเลือกขึ้นมาใหม่ทั้งหมด ห้ามคัดลอกโจทย์เดิมโดยเด็ดขาด จำนวนข้อและประเภทคำถามต้องตรงกับต้นฉบับทุกประการ

                **คำสั่งพิเศษเรื่องตัวเลือก (Distractors):**
                - ในการสร้างโจทย์ข้อใหม่ ห้ามสุ่มตัวลวงมั่วๆ
                - ตัวลวงต้องมีความ "สมมูล" กับข้อสอบต้นฉบับ คือดักทางผิดในจุดเดียวกัน
                - เช่น ถ้าต้นฉบับดักคนลืมคูณ 2, โจทย์คู่ขนานของคุณก็ต้องมีตัวลวงที่ดักคนลืมคูณ 2 เช่นกัน
								
                **กฎเพิ่มเติม:**
                - คำถามทุกข้อต้องเป็นภาษาไทย
                - กฎสำหรับข้อสอบเติมคำ (พิมพ์ตอบเอง):คำตอบสุดท้ายต้องเป็นตัวเลขจำนวนเต็มบวกที่มีค่าไม่เกิน 3 หลัก (0-999) เท่านั้น
                - ผลลัพธ์ต้องเป็น JSON object ที่สมบูรณ์ตาม Schema ที่กำหนดเท่านั้น
                - **กฎการจัดการโจทย์ที่เป็นภาพ (Visual Problem Handling - CRITICAL):** สำหรับโจทย์ที่ต้องอาศัยรูปภาพในการแก้ปัญหา (เช่น มิติสัมพันธ์, เรขาคณิต, การอ่านแผนที่) ซึ่งไม่สามารถอธิบายได้ด้วยข้อความเพียงอย่างเดียว ให้คุณ **"สร้างคำบรรยายรูปภาพ"** ที่ชัดเจนและละเอียดที่สุด แล้วใส่ไว้ในโจทย์แทนการสร้างรูปภาพ
                    * **ตัวอย่าง:** แทนที่จะสร้างโจทย์ที่มีภาพลูกบาศก์ ให้สร้างเป็น "กำหนดให้มีรูปทรงสามมิติที่ประกอบจากลูกบาศก์ขนาดเท่ากัน 16 ลูก วางซ้อนกันเป็นฐาน 4x2 และมีส่วนที่ซ้อนขึ้นไปเป็นชั้นที่ 2 ขนาด 2x2 ตรงกลาง..."
                    * ในกรณีที่ "ตัวเลือก" เป็นรูปภาพ ให้ใช้วิธีการเดียวกัน คือสร้างเป็นคำบรรยายลักษณะของรูปภาพในแต่ละตัวเลือก
                    * **กฎเหล็ก:** ห้ามสร้างโค้ด SVG หรือข้อความ Placeholder (เช่น 'image_code') ใดๆ ทั้งสิ้นโดยเด็ดขาด ให้ใช้คำบรรยายเท่านั้น
                - **Rule for mathematical expressions: Use LaTeX enclosed only within $...$**
            `;

            const mixedQuestionSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, questionType: { type: "STRING", "enum": ["multiple_choice", "short_answer"] }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" }, idealAnswer: { type: "STRING" },  imageCode: { type: "STRING" } }, required: ["questionText", "questionType"] };
            const finalSchema = { type: "OBJECT", properties: { topic: { type: "STRING" }, questions: { type: "ARRAY", items: mixedQuestionSchema } }, required: ["topic", "questions"] };
            
            const parts = [
                { text: prompt },
                { inlineData: { mimeType: mimeType, data: base64String } }
            ];

            await handleApiCall(parts, 'AI กำลังวิเคราะห์ไฟล์และสร้างแบบทดสอบคู่ขนาน...', finalSchema);

        } catch (error) {
            console.error("Error generating from parallel test file:", error);
            showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
            genQuizContainer.innerHTML = `<p class="text-red-500 text-center">ขออภัย, ไม่สามารถสร้างแบบทดสอบคู่ขนานได้</p>`;
        } finally {
            loader.classList.add('hidden');
            generateBtn.disabled = false;
        }
    };
    reader.onerror = (error) => {
        console.error("FileReader error:", error);
        showMessage("เกิดข้อผิดพลาดในการอ่านไฟล์");
        loader.classList.add('hidden');
        generateBtn.disabled = false;
    };
}
		
		async function handleRegenerateQuestionInEditor(index) {
    if (currentEditingQuizData === null) return;

    // แสดงสถานะกำลังโหลดในข้อที่กำลังจะสร้างใหม่
    const questionItem = document.querySelector(`.question-editor-item[data-q-index="${index}"]`);
    if (questionItem) {
        questionItem.innerHTML = '<div class="flex justify-center items-center h-32"><div class="loader"></div></div>';
    }

    const originalQuestion = currentEditingQuizData.questions[index];
    const quizTopic = currentEditingQuizData.topic;
    const questionType = originalQuestion.questionType;

    // เตรียม Prompt และ Schema สำหรับเรียก AI
    const mcqSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" } }, required: ["questionText", "options", "correctAnswerIndex"] };
    const shortAnswerSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, idealAnswer: { type: "STRING" } }, required: ["questionText", "idealAnswer"] };
    
    let schema;
    let typeDescription = "";
    if (questionType === 'multiple_choice') {
        schema = mcqSchema;
        typeDescription = "แบบปรนัย 4 ตัวเลือก";
    } else {
        schema = shortAnswerSchema;
        typeDescription = "แบบเติมคำตอบ";
    }

    const prompt = `สร้างคำถามใหม่ 1 ข้อ ในหัวข้อ "${quizTopic}" ให้เป็นคำถามประเภท "${typeDescription}" โดยให้มีเนื้อหาใกล้เคียงแต่ไม่ซ้ำกับคำถามเดิมนี้: "${originalQuestion.questionText || originalQuestion.stem}". ${simpleMathPrompt}`;

    try {
        const newQuestionData = await callAnalysisApi(prompt, schema);
        
        // เมื่อได้โจทย์ใหม่มาแล้ว ให้อัปเดตข้อมูลใน State
        currentEditingQuizData.questions[index] = { ...originalQuestion, ...newQuestionData };

        // วาดหน้าต่างแก้ไขใหม่ทั้งหมดพร้อมโจทย์ที่เพิ่งสร้าง
        renderQuizEditor(currentEditingQuizData);
    } catch (error) {
        console.error("Error regenerating question in editor:", error);
        showMessage("เกิดข้อผิดพลาดในการสร้างโจทย์ใหม่");
        
        // หากล้มเหลว ให้วาดหน้าจอเดิมกลับมา
        renderQuizEditor(currentEditingQuizData);
    }
}
        
       function handleModeSwitch() {
            const switcherBtn = document.getElementById('mode-switcher-btn');
            if (currentMode === 'student') {
                // --- โค้ดส่วนที่แก้ไข ---
                // เปลี่ยนจากแสดงหน้าต่าง login เป็นสลับโหมดทันที
                
                // 1. เปลี่ยนสถานะเป็น admin
                currentMode = 'admin';

                // 2. อัปเดตไอคอนและข้อความของปุ่ม
                switcherBtn.innerHTML = `<i class="fas fa-user-graduate fa-lg"></i>`;
                switcherBtn.title = "สลับไปโหมดนักเรียน";
                
                // 3. แสดงหน้า dashboard ของ admin
                showView('admin-dashboard');

            } else {
                // If in admin mode, switch back to student
                currentMode = 'student';
                switcherBtn.innerHTML = `<i class="fas fa-user-shield fa-lg"></i>`;
                switcherBtn.title = "สลับไปโหมดผู้ควบคุม";
                showView('student');
            }
        }

        function handleAdminLogin() {
            const passInput = document.getElementById('admin-password-input');
            const errorMsg = document.getElementById('password-error-msg');
            // This is a simple, non-secure password. In a real app, use a proper auth system.
            if (passInput.value === '27411472') {
                adminPasswordModal.classList.add('hidden');
                passInput.value = '';
                errorMsg.classList.add('hidden');
                
                // Update mode and button
                currentMode = 'admin';
                const switcherBtn = document.getElementById('mode-switcher-btn');
                switcherBtn.innerHTML = `<i class="fas fa-user-graduate fa-lg"></i>`;
                switcherBtn.title = "สลับไปโหมดนักเรียน";
                
                showView('admin-dashboard');
            } else {
                errorMsg.classList.remove('hidden');
                passInput.value = '';
            }
        }

        function switchProjectTab(tabName) {
            ['manage', 'results', 'leaderboard'].forEach(name => {
                document.getElementById(`${name}-tab`).classList.remove('active');
                document.getElementById(`${name}-tab-content`).classList.add('hidden');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');
            document.getElementById(`${tabName}-tab-content`).classList.remove('hidden');
        }

        // --- แก้ไขฟังก์ชัน switchQuizDetailTab ---
function switchQuizDetailTab(tabName) {
    const tabs = {
        'analytics': { btn: 'analytics-tab-btn', content: 'analytics-tab-content' },
        'scores': { btn: 'scores-tab-btn', content: 'scores-tab-content' },
        'leaderboard-quiz': { btn: 'leaderboard-quiz-tab-btn', content: 'leaderboard-quiz-tab-content' },
        'behavior-log': { btn: 'behavior-log-tab-btn', content: 'behavior-log-tab-content' } // <-- เพิ่มบรรทัดนี้
    };

    for (const key in tabs) {
        document.getElementById(tabs[key].btn).classList.remove('active');
        document.getElementById(tabs[key].content).classList.add('hidden');
    }

    document.getElementById(tabs[tabName].btn).classList.add('active');
    document.getElementById(tabs[tabName].content).classList.remove('hidden');
}

function showMessage(message, onConfirm = null) {
    // [แก้ไข] เปลี่ยนจาก .textContent เป็น .innerHTML 
    // และ .replace(/\n/g, '<br>') เพื่อให้รองรับการขึ้นบรรทัดใหม่
    modalMessage.innerHTML = message.replace(/\n/g, '<br>');
    
    modalConfirmAction = onConfirm; 
    messageModal.classList.remove('hidden');
}

        function showConfirmation(message, onConfirm, onCancel = null) { // <-- แก้ไขบรรทัดนี้
            document.getElementById('confirmation-message').textContent = message;
            document.getElementById('confirmation-modal').querySelector('h3').textContent = 'ยืนยันการกระทำ';
            confirmAction = onConfirm;
            cancelAction = onCancel; // <-- เพิ่มบรรทัดนี้
            confirmationModal.classList.remove('hidden');
        }
        
function listenForProjects() {
            const settingsRef = doc(db, "globalSettings", "dashboardConfig");
            onSnapshot(settingsRef, (docSnap) => {
                if (docSnap.exists()) {
                    const settingsData = docSnap.data();
                    globalDashboardSettings.projectSort = settingsData.projectSort || 'date_desc';
                    globalDashboardSettings.pinnedProjects = settingsData.pinnedProjects || [];
                    globalDashboardSettings.projectOrder = settingsData.projectOrder || []; // <-- เพิ่มบรรทัดนี้
                }
                if (allProjects.length > 0) {
                    renderProjects();
                }
            });

            const projectsRef = collection(db, `artifacts/${appId}/public/data/projects`);
            unsubscribeProjectsListener = onSnapshot(projectsRef, (snapshot) => {
                allProjects = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderProjects();
            }, (error) => {
                console.error("Error listening for projects:", error);
                showMessage("เกิดข้อผิดพลาดในการโหลดโปรเจค");
            });
        }

function showColorPalette(button, projectId) {
            // ลบ Palette เก่า (ถ้ามี)
            document.querySelectorAll('.color-palette-popup').forEach(p => p.remove());

            const colors = ['#FFFFFF', '#FEE2E2', '#FEF3C7', '#D1FAE5', '#DBEAFE', '#E0E7FF', '#F3E8FF', '#FCE7F3', '#E5E7EB'];
            const palette = document.createElement('div');
            palette.className = 'color-palette-popup absolute z-10 bg-white p-2 rounded-lg shadow-lg flex gap-2';
            
            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'w-6 h-6 rounded-full cursor-pointer border-2 hover:border-blue-500';
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', () => {
                    handleProjectColorChange(projectId, color);
                    palette.remove();
                });
                palette.appendChild(swatch);
            });

            document.body.appendChild(palette);
            const rect = button.getBoundingClientRect();
            palette.style.top = `${rect.bottom + window.scrollY}px`;
            palette.style.left = `${rect.left + window.scrollX - (palette.offsetWidth / 2)}px`;
        }

        async function handleProjectColorChange(projectId, color) {
            const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, projectId);
            try {
                await updateDoc(projectRef, { color: color });
                // onSnapshot จะ re-render ให้อัตโนมัติ
            } catch (error) {
                console.error("Error updating project color:", error);
                showMessage("เกิดข้อผิดพลาดในการเปลี่ยนสี");
            }
        }
        
async function renderProjects() {
    // อ่านค่าการตั้งค่าล่าสุด
    const sortBy = globalDashboardSettings.projectSort || 'date_desc';
    const pinnedIds = new Set(globalDashboardSettings.pinnedProjects || []);
    const currentView = globalDashboardSettings.projectView || 'grid';

    const gridBtn = document.getElementById('grid-view-btn');
    const listBtn = document.getElementById('list-view-btn');
    gridBtn.classList.toggle('active', currentView === 'grid');
    listBtn.classList.toggle('active', currentView === 'list');
    
    document.getElementById('project-sort-select').value = sortBy;
    const searchTerm = document.getElementById('project-search-input').value.toLowerCase();
    let filteredProjects = allProjects.filter(p => p.projectName.toLowerCase().includes(searchTerm));
    const pinned = filteredProjects.filter(p => pinnedIds.has(p.id));
    const unpinned = filteredProjects.filter(p => !pinnedIds.has(p.id));
    const sortFunction = (a, b) => {
        switch (sortBy) {
            case 'name_asc': return a.projectName.localeCompare(b.projectName, 'th');
            case 'name_desc': return b.projectName.localeCompare(a.projectName, 'th');
            case 'date_asc': return new Date(a.createdAt) - new Date(b.createdAt);
            default: return new Date(b.createdAt) - new Date(a.createdAt);
        }
    };
    pinned.sort(sortFunction);
    unpinned.sort(sortFunction);
    const finalSortedProjects = [...pinned, ...unpinned];
    const customOrder = globalDashboardSettings.projectOrder || [];
    if (customOrder.length > 0 && currentView === 'grid') { 
        finalSortedProjects.sort((a, b) => {
            const indexA = customOrder.indexOf(a.id);
            const indexB = customOrder.indexOf(b.id);
            if (indexA === -1) return 1;
            if (indexB === -1) return -1;
            return indexA - indexB;
        });
    }
    
    // ▼▼▼ [แก้ไข] ใช้วิธีนับแบบประหยัด (Aggregation Query) ▼▼▼
    const quizCounts = {};
    await Promise.all(
        finalSortedProjects.map(async (project) => {
            const qref = query(collection(db, `artifacts/${appId}/public/data/quizzes`), where('projectId', '==', project.id));
            // เปลี่ยนจาก getDocs (โหลดหมด) เป็น getCountFromServer (นับที่เซิร์ฟเวอร์)
            const snapshot = await getCountFromServer(qref);
            quizCounts[project.id] = snapshot.data().count;
        })
    );
    // ▲▲▲ [สิ้นสุดส่วนแก้ไข] ▲▲▲

    const projectListContainer = document.getElementById('project-list');
    let html = '';

    if (currentView === 'grid') {
        projectListContainer.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 xl:grid-cols-5 gap-4';
        
        if (starredQuizzes.length > 0 && searchTerm === '') {
            const starredQuizzesWithProjects = starredQuizzes.map(quiz => {
                const project = allProjects.find(p => p.id === quiz.projectId);
                return {
                    ...quiz,
                    projectName: project ? project.projectName : 'N/A'
                };
            });

            html += `
            <div class="project-card-content cursor-pointer p-4 rounded-lg shadow hover:shadow-lg transition-all duration-300 border-2" 
                 data-id="starred-project" style="background-color: #fffbe6; border-color: #facc15;">
                <div class="flex items-center mb-2">
                    <i class="fas fa-star text-yellow-500 mr-2"></i>
                    <h4 class="font-bold text-lg text-yellow-800">แบบทดสอบที่ติดดาว</h4>
                </div>
                <div class="text-sm space-y-1 pl-1 max-h-24 overflow-y-auto">
                    ${starredQuizzesWithProjects.map(q => `
                        <div class="p-1 hover:bg-yellow-100 rounded-md">
                            <p class="font-semibold text-gray-800 truncate" title="${q.topic}">${q.topic}</p>
                            <p class="text-xs text-gray-500 truncate" title="จากโปรเจค: ${q.projectName}">จาก: ${q.projectName}</p>
                        </div>
                    `).join('')}
                </div>
                <p class="text-xs text-yellow-700 mt-2 text-right">${starredQuizzes.length} รายการ</p>
            </div>`;
        }

        finalSortedProjects.forEach(project => {
            const count = quizCounts[project.id] ?? 0;
            const isPinned = pinnedIds.has(project.id);
            const bgColor = project.color || '#FFFFFF';
            const isDarkBg = ((parseInt(bgColor.substring(1, 3), 16) * 0.299) + (parseInt(bgColor.substring(3, 5), 16) * 0.587) + (parseInt(bgColor.substring(5, 7), 16) * 0.114)) < 186;
            const textColorClass = isDarkBg ? 'text-white' : 'text-indigo-800';
            const subTextColorClass = isDarkBg ? 'text-gray-200' : 'text-gray-500';

            html += `
            <div class="project-card-container p-4 rounded-lg shadow hover:shadow-lg transition-all duration-300 border ${isPinned ? 'border-indigo-400 ring-2 ring-indigo-200' : 'border-gray-200'} flex flex-col justify-between relative" 
                 style="background-color: ${bgColor};" data-id="${project.id}" draggable="true">
                <div class="absolute top-2 right-2 flex items-center gap-1">
                    <button data-id="${project.id}" class="color-palette-btn ${isDarkBg ? 'text-gray-300 hover:text-white' : 'text-gray-400 hover:text-indigo-600'} text-lg p-1" title="เปลี่ยนสี"><i class="fas fa-palette pointer-events-none"></i></button>
                    <button data-id="${project.id}" class="pin-project-btn ${isDarkBg ? 'text-gray-300 hover:text-white' : 'text-gray-400 hover:text-indigo-600'} text-lg p-1" title="ปักหมุด"><i class="fas fa-thumbtack pointer-events-none ${isPinned ? (isDarkBg ? 'text-yellow-300' : 'text-indigo-600') : ''}"></i></button>
                </div>
                <div class="project-card-content cursor-pointer pt-2" data-id="${project.id}">
                    <h4 class="font-bold text-lg ${textColorClass} pointer-events-none">${project.projectName}</h4>
                    <p class="text-sm ${subTextColorClass} pointer-events-none">สร้างเมื่อ: ${new Date(project.createdAt).toLocaleDateString('th-TH')}</p>
                    <p class="text-sm ${isDarkBg ? 'text-gray-100' : 'text-gray-700'} mt-1 pointer-events-none"><i class="fas fa-file mr-1"></i> ${count} แบบทดสอบ</p>
                </div>
                <div class="text-right mt-2">
                    <button data-id="${project.id}" data-name="${project.projectName}" class="delete-project-btn ${isDarkBg ? 'text-red-300 hover:text-red-100' : 'text-red-500 hover:text-red-700'} text-sm p-1"><i class="fas fa-trash-alt"></i> ลบ</button>
                </div>
            </div>`;
        });

    } else {
        projectListContainer.className = 'flex flex-col gap-2';
        
        if (starredQuizzes.length > 0 && searchTerm === '') {
            html += `
            <div class="project-card-content grid grid-cols-12 gap-4 items-center p-3 rounded-lg hover:bg-yellow-100 border-2 cursor-pointer transition-all"
                 data-id="starred-project" style="background-color: #fffbe6; border-color: #facc15;">
                <div class="col-span-12 md:col-span-5 flex items-center pointer-events-none">
                    <i class="fas fa-star text-yellow-500 mr-3 text-lg"></i>
                    <p class="font-bold text-yellow-800">แบบทดสอบที่ติดดาว</p>
                </div>
                <div class="col-span-6 md:col-span-2 text-sm text-yellow-700 pointer-events-none"><i class="fas fa-file-alt mr-2 text-gray-400"></i>${starredQuizzes.length} รายการ</div>
                <div class="col-span-6 md:col-span-5 text-sm text-yellow-700 flex items-center justify-end pointer-events-none">
                    <span>คลิกเพื่อดูทั้งหมด</span>
                    <i class="fas fa-chevron-right ml-2"></i>
                </div>
            </div>`;
        }
        
        html += `<div class="hidden md:grid grid-cols-12 gap-4 text-sm font-semibold text-gray-500 px-4 py-2 border-b">
                    <div class="col-span-5">ชื่อโปรเจค</div>
                    <div class="col-span-2">แบบทดสอบ</div>
                    <div class="col-span-3">สร้างเมื่อ</div>
                    <div class="col-span-2 text-right">เครื่องมือ</div>
                 </div>`;
        
        finalSortedProjects.forEach(project => {
            const count = quizCounts[project.id] ?? 0;
            const isPinned = pinnedIds.has(project.id);
            html += `
                <div class="grid grid-cols-12 gap-4 items-center p-3 rounded-lg hover:bg-gray-100 border transition-all">
                    <div class="col-span-12 md:col-span-5 flex items-center">
                        <span class="w-3 h-3 rounded-full mr-3" style="background-color: ${project.color || '#E5E7EB'}"></span>
                        <div class="project-card-content cursor-pointer flex-grow" data-id="${project.id}">
                             <p class="font-bold text-indigo-700 pointer-events-none">${project.projectName}</p>
                        </div>
                    </div>
                    <div class="col-span-6 md:col-span-2 text-sm text-gray-600"><i class="fas fa-file-alt mr-2 text-gray-400"></i>${count} ชุด</div>
                    <div class="col-span-6 md:col-span-3 text-sm text-gray-600">${new Date(project.createdAt).toLocaleString('th-TH')}</div>
                    <div class="col-span-12 md:col-span-2 flex items-center justify-end gap-3">
                        <button data-id="${project.id}" class="pin-project-btn text-gray-400 hover:text-indigo-600 text-lg" title="ปักหมุด"><i class="fas fa-thumbtack pointer-events-none ${isPinned ? 'text-indigo-600' : ''}"></i></button>
                        <button data-id="${project.id}" data-name="${project.projectName}" class="delete-project-btn text-red-500 hover:text-red-700 text-lg"><i class="fas fa-trash-alt"></i></button>
                    </div>
                </div>
            `;
        });
    }

    projectListContainer.innerHTML = html;
    noProjectsMsg.classList.toggle('hidden', html.length > 0);
	
	const currentSort = globalDashboardSettings.projectSort || 'date_desc';
    // อนุญาตให้ลากได้เสมอ แต่ถ้าจะให้ดีควรลากได้เฉพาะตอนไม่ได้ sort หรือ implement logic เพิ่ม
    // ในที่นี้เพื่อให้ลื่นไหล เราจะเปิดให้ลากได้เลย แต่แนะนำให้ User รู้ว่าถ้ากด Sort ปุ่มอื่น ลำดับจะเปลี่ยน
    
    const el = document.getElementById('project-list');
    
    // ทำลาย instance เก่าก่อนสร้างใหม่ (ป้องกัน memory leak เวลา render ซ้ำ)
    if (window.projectSortableInstance) {
        window.projectSortableInstance.destroy();
    }

    window.projectSortableInstance = new Sortable(el, {
        animation: 150, // ความลื่นในการสลับที่ (ms)
        delay: 100, // (สำคัญ) กดค้าง 0.1 วิถึงจะเริ่มลาก เพื่อกันลั่นเวลาคลิกบนมือถือ
        delayOnTouchOnly: true,
        ghostClass: 'sortable-ghost', // class ของตัวเงา
        chosenClass: 'sortable-chosen', // class ของตัวที่ถูกเลือก
        dragClass: 'sortable-drag', // class ของตัวที่กำลังลอย
        
        onEnd: function (evt) {
            // เมื่อวางเสร็จ ให้บันทึกลำดับใหม่ทันที
            const newOrder = Array.from(el.querySelectorAll('.project-card-container, .grid-cols-12')) // รองรับทั้ง Grid และ List
                .map(item => {
                    // หา data-id (ต้องเจาะหาจาก project-card-content หรือ container)
                    const content = item.querySelector('.project-card-content');
                    return content ? content.dataset.id : item.dataset.id;
                })
                .filter(id => id); // กรองค่าว่าง

            if (newOrder.length > 0) {
                saveProjectOrder(newOrder);
            }
        }
    });
	
}
        document.getElementById('confirm-create-project-btn').addEventListener('click', async () => {
            const projectNameInput = document.getElementById('project-name-input');
            const projectName = projectNameInput.value.trim();
            if (!projectName) {
                showMessage("กรุณาใส่ชื่อโปรเจค");
                return;
            }
            try {
                const newProjectRef = doc(collection(db, `artifacts/${appId}/public/data/projects`));
                await setDoc(newProjectRef, {
                    projectName: projectName,
                    students: [],
                    settings: {
    resultsDisplay: 'show_results_and_answers',
    shuffleSetting: 'none',
    defaultNumQuestions: 5,
    defaultNumChoices: 4,
    defaultPassingScore: 3,
    timerMode: 'none',
    timerDuration: 10,
    showInStudentDashboard: false // <-- เพิ่มบรรทัดนี้
},
                    createdBy: userId, // Keep track of who created it
                    createdAt: new Date().toISOString()
                });
                projectNameInput.value = '';
                createProjectModal.classList.add('hidden');
                showMessage("สร้างโปรเจคสำเร็จ!");
            } catch (error) {
                console.error("Error creating project:", error);
                showMessage("ไม่สามารถสร้างโปรเจคได้");
            }
        });

        // โค้ดใหม่ที่ถูกต้อง (วางทับของเดิม)
// โค้ดใหม่ (วางทับ event listener ของ projectList เดิมทั้งหมด)
projectList.addEventListener('click', async (e) => {
    const cardContent = e.target.closest('.project-card-content');
    const deleteBtn = e.target.closest('.delete-project-btn');
    const pinBtn = e.target.closest('.pin-project-btn');
	const colorBtn = e.target.closest('.color-palette-btn'); // <-- เพิ่มบรรทัดนี้

    if (pinBtn) {
        const projectId = pinBtn.dataset.id;
        const settingsRef = doc(db, "globalSettings", "dashboardConfig");
        const currentPinned = globalDashboardSettings.pinnedProjects;
        let newPinnedIds;
        
        if (currentPinned.includes(projectId)) {
            newPinnedIds = currentPinned.filter(id => id !== projectId);
        } else {
            newPinnedIds = [...currentPinned, projectId];
        }
        
        try {
            await setDoc(settingsRef, { pinnedProjects: newPinnedIds }, { merge: true });
        } catch (error) {
            console.error("Error updating pin status:", error);
            showMessage("เกิดข้อผิดพลาดในการปักหมุด");
        }
		
		} else if (colorBtn) { // <-- เพิ่มบล็อกนี้ทั้งหมด
        const projectId = colorBtn.dataset.id;
        showColorPalette(colorBtn, projectId);
            
    } else if (cardContent) {
        const projectId = cardContent.dataset.id;
        if (projectId === 'starred-project') {
            showStarredProjectView();
        } else {
            currentProjectId = projectId;
            await loadProjectDetails(currentProjectId);
            showView('project-detail');
        }
    } else if (deleteBtn) {
        const projectId = deleteBtn.dataset.id;
        const projectName = deleteBtn.dataset.name;
        showConfirmation(
            `คุณแน่ใจหรือไม่ว่าต้องการลบโปรเจค "${projectName}"? ข้อมูลทั้งหมดจะถูกลบอย่างถาวร`,
            () => handleDeleteProject(projectId)
        );
    }
});
		
		// --- [ เพิ่มฟังก์ชันใหม่นี้เข้าไปทั้งหมด ] ---
/**
 * แสดงผลประวัติพฤติกรรมของนักเรียนในแท็บ
 * @param {Array} submissions ข้อมูลการส่งงานทั้งหมดของแบบทดสอบนี้
 */
function renderBehaviorLog(submissions) {
    const container = document.getElementById('behavior-log-container');
    if (!container) return;

    // กรองเฉพาะนักเรียนที่มีประวัติพฤติกรรม
    const submissionsWithLogs = submissions.filter(sub => sub.behaviorLog && sub.behaviorLog.length > 0);

    if (submissionsWithLogs.length === 0) {
        container.innerHTML = '<p class="text-center text-gray-500">ไม่พบประวัติการออกจากหน้าจอของนักเรียน</p>';
        return;
    }

    let html = '';
    submissionsWithLogs.forEach(sub => {
        html += `
            <div class="p-4 border rounded-lg bg-white">
                <p class="font-semibold text-indigo-800">${sub.studentName}</p>
                <div class="mt-2 pl-4 border-l-2 border-gray-200 space-y-2">
        `;
        // เรียงลำดับเหตุการณ์จากล่าสุดไปเก่าสุด
        sub.behaviorLog.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).forEach(log => {
            const eventTime = new Date(log.timestamp).toLocaleString('th-TH', {
                dateStyle: 'short',
                timeStyle: 'medium'
            });
            html += `
                <div class="text-sm text-gray-700">
                    <i class="fas fa-exclamation-triangle text-yellow-500 mr-2"></i>
                    <strong>ออกจากหน้าจอ (ครั้งที่ ${log.attemptNumber})</strong>
                    <span class="text-xs text-gray-500 ml-2">${eventTime}</span>
                </div>
            `;
        });

        html += `
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
}
	

        async function saveProjectOrder(newOrder) {
            const settingsRef = doc(db, "globalSettings", "dashboardConfig");
            try {
                await setDoc(settingsRef, { projectOrder: newOrder }, { merge: true });
                // ไม่ต้องทำอะไรต่อ UI จะอัปเดตเองในครั้งถัดไปที่ re-render
            } catch (error) {
                console.error("Error saving project order:", error);
                showMessage("เกิดข้อผิดพลาดในการบันทึกลำดับ");
            }
        }
		
async function logBehaviorEvent(eventType, details = {}) {
    if (!currentQuizData || !currentQuizData.id || !currentStudentName) {
        console.warn("ไม่สามารถบันทึกพฤติกรรมได้: ข้อมูลไม่ครบถ้วน");
        return;
    }

    const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${currentQuizData.id}/submissions`, currentStudentName);

    const logEntry = {
        event: eventType,
        timestamp: new Date().toISOString(),
        ...details
    };

    try {
        // พยายามอัปเดตเอกสารที่มีอยู่แล้วเท่านั้น
        await updateDoc(submissionRef, {
            behaviorLog: arrayUnion(logEntry)
        });
        console.log(`อัปเดตพฤติกรรมสำหรับ ${currentStudentName} สำเร็จ`);

    } catch (error) {
        // หากเกิดข้อผิดพลาด (เช่น หาเอกสารไม่เจอ) ให้บันทึกไว้ใน console แต่ไม่ต้องทำอะไรกับ UI
        if (error.code === 'not-found') {
            // นี่คือจุดที่ถูกต้อง: เมื่อหาเอกสารไม่เจอ ก็ไม่ต้องทำอะไรเลย
            // เพราะยังไม่มีการส่งงานให้บันทึกพฤติกรรมได้
            console.warn(`ไม่พบเอกสารการส่งงานของ ${currentStudentName} จึงไม่สามารถบันทึก behavior log ได้ (นี่คือเหตุการณ์ปกติ)`);
        } else {
            // หากเป็นข้อผิดพลาดอื่นๆ
            console.error("เกิดข้อผิดพลาดในการบันทึกพฤติกรรม:", error);
        }
    }
}

function getScoreTier(score, maxScore) {
    if (maxScore === 0) {
        if (score === 0) return { text: '(รอคะแนน)', icon: '⏳' };
        return { text: '(พยายามอยู่)', icon: '😥' }; // กรณีติดลบ
    }
    // (ป้องกันการหารด้วยศูนย์ถ้า maxScore เป็น 0)
    const scoreRatio = score / (maxScore === 0 ? 1 : maxScore);

    if (scoreRatio === 1) {
        return { text: '(นำโด่ง)', icon: '👑' };
    }
    if (scoreRatio >= 0.7) {
        return { text: '(ตามมาติดๆ)', icon: '🔥' };
    }
    if (scoreRatio >= 0.4) {
        return { text: '(กำลังไล่ตาม)', icon: '🏃' };
    }
    return { text: '(พยายามอยู่)', icon: '😥' };
}

function calculateMeanAndStdDev(scores) {
    if (scores.length === 0) return { mean: 0, stdDev: 0 };
    const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
    if (scores.length === 1) return { mean: mean, stdDev: 0 }; // S.D. ของข้อมูล 1 ตัวเป็น 0
    const stdDev = Math.sqrt(scores.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / (scores.length - 1));
    return { mean, stdDev };
}

/**
 * คำนวณ Z-Score
 * @param {number} score - คะแนนดิบของนักเรียน
 * @param {number} mean - ค่าเฉลี่ยของกลุ่ม
 * @param {number} stdDev - ส่วนเบี่ยงเบนมาตรฐานของกลุ่ม
 * @returns {number|null} ค่า Z-Score หรือ null ถ้าคำนวณไม่ได้
 */
function calculateZScore(score, mean, stdDev) {
    if (stdDev === 0) return 0; // ถ้าทุกคนได้คะแนนเท่ากัน Z-score คือ 0
    return (score - mean) / stdDev;
}

/**
 * คำนวณ T-Score
 * @param {number} zScore - ค่า Z-Score
 * @returns {number} ค่า T-Score
 */
function calculateTScore(zScore) {
    return (10 * zScore) + 50;
}

function showStarredProjectView() {
            currentProjectId = 'starred'; // ตั้ง ID พิเศษ
            currentProjectData = null; // ไม่มีข้อมูลโปรเจคจริงๆ

            // ตั้งค่าหัวข้อและแสดง view
            projectTitle.textContent = 'แบบทดสอบที่ติดดาว';
            projectIdDisplay.textContent = 'pinned-items';
            showView('project-detail');

            // ซ่อนแท็บที่ไม่เกี่ยวข้อง
            manageTab.classList.add('hidden');
            leaderboardTab.classList.add('hidden');
            
            // บังคับให้ไปที่แท็บ "ผลลัพธ์" (ซึ่งก็คือรายการแบบทดสอบ)
            switchProjectTab('results');
			renderQuizzes(); // สั่งให้วาดรายการแบบทดสอบใหม่ด้วยข้อมูลที่ถูกต้อง
        }

        // --- [ วางทับฟังก์ชันนี้ทั้งหมด ] ---
async function loadProjectDetails(projectId) {
    const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, projectId);
    const docSnap = await getDoc(projectRef);
    if (docSnap.exists()) {
        manageTab.classList.remove('hidden');
        leaderboardTab.classList.remove('hidden');
        currentProjectData = docSnap.data();
        projectTitle.textContent = currentProjectData.projectName;
        projectIdDisplay.textContent = projectId;
        
        const settings = currentProjectData.settings || {};
        document.getElementById('shuffle-setting-select').value = settings.shuffleSetting || 'none';
        
        const showInDashboardCheckbox = document.getElementById('show-in-student-dashboard-checkbox');
        showInDashboardCheckbox.checked = settings.showInStudentDashboard !== false;

        const enablePasscodeCheckbox = document.getElementById('enable-passcode-checkbox');
        const passcodeContainer = document.getElementById('passcode-input-container');
        const passcodeInput = document.getElementById('project-passcode-input');

        const isPasscodeEnabled = settings.isPasscodeEnabled || false;
        enablePasscodeCheckbox.checked = isPasscodeEnabled;
        passcodeInput.value = settings.passcode || '';
        passcodeContainer.classList.toggle('hidden', !isPasscodeEnabled);

        enablePasscodeCheckbox.onchange = () => {
            passcodeContainer.classList.toggle('hidden', !enablePasscodeCheckbox.checked);
        };
        
        // ▼▼▼ เพิ่มบรรทัดนี้เข้าไปเพื่อโหลดค่าที่บันทึกไว้ ▼▼▼
        document.getElementById('confidence-scoring-checkbox').checked = settings.isConfidenceScoringEnabled || false;

        if (unsubscribeStudentsListener) unsubscribeStudentsListener();
        if (unsubscribeQuizzesListener) unsubscribeQuizzesListener();
        if (unsubscribeStudentProfilesListener) unsubscribeStudentProfilesListener();
        listenForStudents(projectId);
        listenForProjectQuizzes(projectId);
        listenForStudentProfiles(projectId);
    } else {
        showMessage("ไม่พบโปรเจค");
        showView('admin-dashboard');
    }
}

async function handleResetProjectOrder() {
    const settingsRef = doc(db, "globalSettings", "dashboardConfig");
    try {
        await setDoc(settingsRef, { projectOrder: [] }, { merge: true });
        showMessage("รีเซ็ตลำดับโปรเจคแล้ว");
        // onSnapshot จะ re-render หน้าจอให้อัตโนมัติตามการจัดเรียงใน Dropdown
    } catch (error) {
        console.error("Error resetting project order:", error);
        showMessage("เกิดข้อผิดพลาดในการรีเซ็ตลำดับ");
    }
}

async function handleTogglePinProject(projectId) {
    if (!projectId) return;
    const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, projectId);
    try {
        const projectDoc = await getDoc(projectRef);
        if (projectDoc.exists()) {
            const currentStatus = projectDoc.data().isPinned || false;
            await updateDoc(projectRef, {
                isPinned: !currentStatus
            });
            // onSnapshot จะรับค่าที่เปลี่ยนแปลงและวาดหน้าจอใหม่เอง
        }
    } catch (error) {
        console.error("Error toggling pin status:", error);
        showMessage("เกิดข้อผิดพลาดในการปักหมุด");
    }
}

        async function handleDeleteProject(projectId) {
            try {
                const batch = writeBatch(db);
                // 1. Find all quizzes associated with the project
                const quizzesRef = collection(db, `artifacts/${appId}/public/data/quizzes`);
                const q = query(quizzesRef, where("projectId", "==", projectId));
                const quizSnapshot = await getDocs(q);

                // 2. For each quiz, find and delete its submissions, then the quiz itself
                for (const quizDoc of quizSnapshot.docs) {
                    // Delete submissions
                    const submissionsRef = collection(db, `artifacts/${appId}/public/data/quizzes/${quizDoc.id}/submissions`);
                    const submissionsSnapshot = await getDocs(submissionsRef);
                    submissionsSnapshot.forEach(subDoc => {
                        batch.delete(subDoc.ref);
                    });
                    // Delete quiz
                    batch.delete(quizDoc.ref);
                }

                // 3. Delete student profiles subcollection
                const profilesRef = collection(db, `artifacts/${appId}/public/data/projects/${projectId}/studentProfiles`);
                const profilesSnapshot = await getDocs(profilesRef);
                profilesSnapshot.forEach(profDoc => {
                    batch.delete(profDoc.ref);
                });

                // 4. Delete the project document
                const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, projectId);
                batch.delete(projectRef);
                
                await batch.commit();

                showMessage("ลบโปรเจคสำเร็จแล้ว");
                showView('admin-dashboard'); // Go back to dashboard after deletion
            } catch (error) {
                console.error("Error deleting project:", error);
                showMessage("เกิดข้อผิดพลาดในการลบโปรเจค");
            }
        }
        
        // --- Settings & Student Management in Project ---
document.getElementById('save-settings-btn').addEventListener('click', async () => {
    if (!currentProjectId) return;
    const settings = {
        defaultNumQuestions: parseInt(document.getElementById('num-questions').value),
        defaultNumChoices: parseInt(document.getElementById('num-choices').value),
        defaultPassingScore: parseInt(document.getElementById('passing-score-input').value),
        resultsDisplay: document.getElementById('results-display-select').value,
        shuffleSetting: document.getElementById('shuffle-setting-select').value,
        timerMode: document.getElementById('timer-mode-select').value,
        timerDuration: parseInt(document.getElementById('timer-duration-input').value),
        // ▼▼▼ เพิ่ม property นี้เข้าไป ▼▼▼
        isConfidenceScoringEnabled: document.getElementById('confidence-scoring-checkbox').checked,
		confidenceMode: document.getElementById('confidence-mode-select').value
    };
    try {
        const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, currentProjectId);
        await updateDoc(projectRef, { settings });
        showMessage("บันทึกการตั้งค่าแล้ว");
    } catch (error) {
        console.error("Error saving settings:", error);
        showMessage("ไม่สามารถบันทึกการตั้งค่าได้");
    }
});

        function listenForStudents(projectId) {
            const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, projectId);
            unsubscribeStudentsListener = onSnapshot(projectRef, (doc) => {
                if (doc.exists()) {
                    const projectData = doc.data();
                    currentProjectData = projectData; 
                    renderStudentList(projectData.students || []); 
                }
            });
        }

        function renderStudentList(students) {
            const deleteAllBtn = document.getElementById('delete-all-students-btn');
            if (students.length === 0) {
                studentList.innerHTML = `<p class="text-gray-400 text-center p-2">ยังไม่มีนักเรียนในโปรเจคนี้</p>`;
                deleteAllBtn.classList.add('hidden');
            } else {
                studentList.innerHTML = students.map(name => `
                    <div class="flex justify-between items-center p-1 hover:bg-gray-100 rounded">
                        <span>${name}</span>
                        <button data-student-name="${name}" class="delete-student-btn text-red-500 hover:text-red-700 p-1 text-xs">
                            <i class="fas fa-times-circle pointer-events-none"></i>
                        </button>
                    </div>
                `).join('');
                deleteAllBtn.classList.remove('hidden');
            }
        }

        document.getElementById('add-student-btn').addEventListener('click', async () => {
            if (!currentProjectId) return;
            const studentNameInput = document.getElementById('student-name-input');
            const studentNamesText = studentNameInput.value.trim();
            if (!studentNamesText) {
                showMessage("กรุณาใส่ชื่อนักเรียน");
                return;
            }
            
            const newStudents = studentNamesText.split('\n').map(name => name.trim()).filter(name => name);
            if (newStudents.length === 0) return;

            try {
                const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, currentProjectId);
                const docSnap = await getDoc(projectRef);
                if (docSnap.exists()) {
                    const currentStudents = docSnap.data().students || [];
                    const updatedStudents = [...new Set([...currentStudents, ...newStudents])];
                    await updateDoc(projectRef, { students: updatedStudents });
                    studentNameInput.value = '';
                }
            } catch (error) {
                console.error("Error adding students:", error);
                showMessage("ไม่สามารถเพิ่มนักเรียนได้");
            }
        });
		
		// ▼▼▼ เพิ่มฟังก์ชันใหม่นี้เข้าไปทั้งหมด ▼▼▼
/**
 * จัดการการจับคู่แบบทดสอบด้วยตนเอง
 * @param {string} firstQuizId - ID ของแบบทดสอบแรกที่ผู้ใช้กดปุ่ม
 */
async function handleManualQuizPairing(firstQuizId) {
    const pairingModal = document.getElementById('move-quiz-modal'); // เราจะใช้ Modal เดิม
    const projectSelect = document.getElementById('move-quiz-project-select');
    const modalTitle = pairingModal.querySelector('h3');
    const confirmBtn = document.getElementById('confirm-move-quiz-btn');
    const cancelBtn = document.getElementById('cancel-move-quiz-btn');

    // 1. เปลี่ยนข้อความใน Modal ให้เหมาะสมกับการจับคู่
    modalTitle.textContent = 'จับคู่เพื่อเปรียบเทียบผล';
    projectSelect.innerHTML = '<option value="">กำลังโหลดรายการ...</option>';
    confirmBtn.textContent = 'ยืนยันการจับคู่';
    pairingModal.classList.remove('hidden');

    // 2. แสดงรายการแบบทดสอบอื่นๆ ทั้งหมดในโปรเจคนี้ (ยกเว้นตัวเอง)
    const potentialPairs = allQuizzes.filter(q => q.id !== firstQuizId);

    if (potentialPairs.length === 0) {
        projectSelect.innerHTML = '<option value="">ไม่มีแบบทดสอบอื่นให้จับคู่</option>';
        confirmBtn.disabled = true;
    } else {
        projectSelect.innerHTML = '<option value="">-- เลือกแบบทดสอบที่จะเปรียบเทียบ --</option>' +
            potentialPairs.map(p => `<option value="${p.id}">${p.topic}</option>`).join('');
        confirmBtn.disabled = false;
    }

    // 3. สร้าง Event Listener สำหรับการยืนยัน (ทำงานแค่ครั้งเดียว)
    const confirmPairingHandler = async () => {
        const secondQuizId = projectSelect.value;
        if (!secondQuizId) {
            showMessage("กรุณาเลือกแบบทดสอบที่ต้องการจับคู่");
            return;
        }

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'กำลังจับคู่...';

        try {
            const firstQuizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, firstQuizId);
            const secondQuizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, secondQuizId);

            // บันทึกการจับคู่แบบสองทาง (Two-way binding)
            const batch = writeBatch(db);
            batch.update(firstQuizRef, { pairedQuizId: secondQuizId });
            batch.update(secondQuizRef, { pairedQuizId: firstQuizId });
            await batch.commit();
            
            showMessage("จับคู่แบบทดสอบสำเร็จ!");
            pairingModal.classList.add('hidden');

        } catch (error) {
            console.error("Error pairing quizzes:", error);
            showMessage("เกิดข้อผิดพลาดในการจับคู่");
        } finally {
            // คืนค่า Modal ให้เป็นปกติสำหรับการใช้งาน "ย้าย" ในครั้งต่อไป
            modalTitle.textContent = 'ย้ายแบบทดสอบไปโปรเจคอื่น';
            confirmBtn.textContent = 'ย้าย';
            confirmBtn.disabled = false;
            // ลบ Listener ที่สร้างขึ้นชั่วคราวออก
            confirmBtn.removeEventListener('click', confirmPairingHandler);
            cancelBtn.removeEventListener('click', cleanup);
        }
    };
    
    // ฟังก์ชันสำหรับคืนค่า Modal เมื่อกดยกเลิก
    const cleanup = () => {
        pairingModal.classList.add('hidden');
        modalTitle.textContent = 'ย้ายแบบทดสอบไปโปรเจคอื่น';
        confirmBtn.textContent = 'ย้าย';
        confirmBtn.removeEventListener('click', confirmPairingHandler);
        cancelBtn.removeEventListener('click', cleanup);
    };

    confirmBtn.addEventListener('click', confirmPairingHandler);
    cancelBtn.addEventListener('click', cleanup);
}
// ▲▲▲ สิ้นสุดฟังก์ชันใหม่ ▲▲▲

        function handleDeleteStudent(studentName) {
            showConfirmation(
                `คุณแน่ใจหรือไม่ว่าต้องการลบนักเรียนชื่อ "${studentName}"? ข้อมูลคะแนนและป้ายรางวัลของนักเรียนคนนี้จะถูกลบไปด้วย`,
                async () => {
                    if (!currentProjectId || !currentProjectData) return;
                    const updatedStudents = currentProjectData.students.filter(s => s !== studentName);
                    try {
                        const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, currentProjectId);
                        const studentProfileRef = doc(db, `artifacts/${appId}/public/data/projects/${currentProjectId}/studentProfiles`, studentName);
                        
                        const batch = writeBatch(db);
                        batch.update(projectRef, { students: updatedStudents });
                        batch.delete(studentProfileRef); // Also delete their profile for the leaderboard
                        await batch.commit();

                    } catch (error) {
                        console.error("Error deleting student:", error);
                        showMessage("เกิดข้อผิดพลาดในการลบนักเรียน");
                    }
                }
            );
        }

        function handleDeleteAllStudents() {
            showConfirmation(
                `คุณแน่ใจหรือไม่ว่าต้องการลบนักเรียนทั้งหมดในโปรเจคนี้? การกระทำนี้ไม่สามารถย้อนกลับได้`,
                async () => {
                    if (!currentProjectId) return;
                    try {
                        const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, currentProjectId);
                        const profilesRef = collection(db, `artifacts/${appId}/public/data/projects/${currentProjectId}/studentProfiles`);
                        const profilesSnapshot = await getDocs(profilesRef);

                        const batch = writeBatch(db);
                        batch.update(projectRef, { students: [] });
                        profilesSnapshot.forEach(doc => batch.delete(doc.ref));
                        await batch.commit();

                    } catch (error) {
                        console.error("Error deleting all students:", error);
                        showMessage("เกิดข้อผิดพลาดในการลบนักเรียนทั้งหมด");
                    }
                }
            );
        }

// ▼▼▼ START: เพิ่มฟังก์ชันใหม่ทั้งหมดสำหรับฟีเจอร์ "สร้างแยกเนื้อหาจากไฟล์" ▼▼▼

// 1. สร้างตัวแปรส่วนกลางเพื่อเก็บข้อมูลไฟล์ไว้ใช้ซ้ำ
let extractedFileTopics = [];
let fileDataBase64 = null;
let fileMimeType = null;


// ▼▼▼ START: วางทับฟังก์ชัน analyzeFileForTopics เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
/**
 * ขั้นตอนที่ 1: วิเคราะห์ไฟล์ (รวมถึงไฟล์สแกน) เพื่อดึงหัวข้อออกมา
 * @param {File} file - ไฟล์ที่ผู้ใช้อัปโหลด
 */
async function analyzeFileForTopics(file) {
    const topicsListContainer = document.getElementById('file-topics-list-container');
    const topicsListDiv = document.getElementById('file-topics-list');

    topicsListContainer.classList.remove('hidden');
    topicsListDiv.innerHTML = '<div class="loader mx-auto my-3"></div><p class="text-center text-gray-500">AI กำลังอ่านและวิเคราะห์หัวข้อจากไฟล์สแกน...</p>';

    try {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        
        await new Promise((resolve, reject) => {
            reader.onload = () => {
                fileDataBase64 = reader.result.split(',')[1];
                fileMimeType = file.type;
                resolve();
            };
            reader.onerror = (error) => reject(error);
        });

        if (!fileDataBase64) throw new Error("ไม่สามารถอ่านข้อมูลจากไฟล์ได้");

        const prompt = `
            คุณคือผู้เชี่ยวชาญด้านการวิเคราะห์หลักสูตร จากเนื้อหาของไฟล์ข้อสอบที่แนบมานี้
            จงสกัด "หัวข้อหลัก" (Key Topics) ที่ข้อสอบนี้วัดผลออกมาเป็นรายการ
            วิเคราะห์คำถามแต่ละข้อว่าอยู่เรื่องอะไร แล้วสรุปเป็นรายการหัวข้อที่ไม่ซ้ำกัน
            
            ข้อกำหนด:
            1. สรุปหัวข้อให้สั้นและตรงประเด็น (เช่น "แบบรูป", "พื้นที่", "ทศนิยม")
            2. ตอบกลับเป็น JSON object ที่มี key ชื่อ "topics" โดยค่าของมันคือ array ของ string ที่เป็นชื่อหัวข้อ
            
            ตัวอย่างผลลัพธ์: { "topics": ["แบบรูป", "พื้นที่", "ทศนิยม"] }
        `;

        const schema = { type: "OBJECT", properties: { topics: { type: "ARRAY", items: { type: "STRING" } } }, required: ["topics"] };

        const parts = [
            { text: prompt },
            { inlineData: { mimeType: fileMimeType, data: fileDataBase64 } }
        ];

        // --- ⭐ START: นี่คือส่วนที่แก้ไข ---
        // เราเรียก handleApiCall โดยเพิ่ม `false` เข้าไปเป็น parameter ตัวสุดท้าย
        // เพื่อบอกว่า "ไม่ต้องแสดงผลลัพธ์ (ไม่ต้องเรียก displayGeneratedQuiz)"
        const result = await handleApiCall(parts, "กำลังวิเคราะห์หัวข้อ...", schema, null, false);
        // --- ⭐ END: สิ้นสุดส่วนที่แก้ไข ---
        
        if (result && result.topics) {
            extractedFileTopics = result.topics;
            renderFileTopics();
        } else {
            throw new Error("AI ไม่สามารถแยกหัวข้อจากไฟล์ได้");
        }

    } catch (error) {
        console.error("Error analyzing file for topics:", error);
        topicsListDiv.innerHTML = `<p class="text-red-500 text-center">เกิดข้อผิดพลาด: ${error.message}</p>`;
    }
}

function renderFileTopics() {
    const topicsListDiv = document.getElementById('file-topics-list');
    if (extractedFileTopics.length === 0) {
        topicsListDiv.innerHTML = '<p class="text-gray-500 text-center">ไม่พบหัวข้อที่ชัดเจนในไฟล์นี้</p>';
        return;
    }

    // สร้าง HTML ที่มีทั้งปุ่ม "สร้างเนื้อหา" และ "สร้างแบบทดสอบ"
    topicsListDiv.innerHTML = extractedFileTopics.map(topic => `
        <div class="p-2 rounded-md bg-gray-50 border border-gray-200 flex flex-col sm:flex-row items-center justify-between gap-2">
            <p class="font-semibold text-gray-800 flex-grow text-left">${topic}</p>
            <div class="flex items-center gap-2 flex-shrink-0">
                <button class="generate-content-btn text-blue-800 bg-blue-100 hover:bg-blue-200 text-xs font-semibold py-1.5 px-3 rounded-md flex items-center gap-1.5" data-topic="${escape(topic)}">
                    <i class="fas fa-chalkboard-teacher"></i>สร้างเนื้อหาสำหรับสอน
                </button>
                <button class="file-topic-selection-btn text-indigo-800 bg-indigo-100 hover:bg-indigo-200 text-xs font-semibold py-1.5 px-3 rounded-md flex items-center gap-1.5" data-topic="${escape(topic)}">
                    <i class="fas fa-file-alt"></i>สร้างแบบทดสอบ
                </button>
            </div>
        </div>
    `).join('');
}

async function generateHybridQuizForTopic(selectedTopic) {
    const numTotalQuestions = parseInt(document.getElementById('num-questions').value, 10);
    const quizType = document.getElementById('quiz-type-select').value;
    const numChoices = document.getElementById('num-choices').value;

    const includeImages = document.getElementById('include-images-checkbox').checked;
    const imageInstruction = includeImages ? `สำหรับ "คำถามใหม่" ที่คุณสร้างขึ้น หากจำเป็นต้องมีรูปภาพประกอบ (เช่น เรขาคณิต, กราฟ) ให้สร้างโค้ด SVG ที่สมบูรณ์สำหรับรูปนั้นๆ แล้วใส่ไว้ใน property ชื่อ "imageCode"` : 'ห้ามสร้างรูปภาพหรือโค้ด SVG ใดๆ';

    let formatInstruction = "";
    let responseSchema;

    const mcqSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" },  imageCode: {type: "STRING"} }, required: ["questionText", "options", "correctAnswerIndex"] };
    const tfSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, correctAnswer: { type: "BOOLEAN" },  imageCode: {type: "STRING"} }, required: ["questionText", "correctAnswer"] };
    const shortAnswerSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, idealAnswer: { type: "STRING" },  imageCode: {type: "STRING"} }, required: ["questionText", "idealAnswer"] };
    const matchingSchema = { type: "OBJECT", properties: { questionType: { type: "STRING", "enum": ["matching_item"] }, stem: { type: "STRING" }, correctResponse: { type: "STRING" }, allResponses: { type: "ARRAY", items: { type: "STRING" } },  imageCode: { type: "STRING" } }, required: ["questionType", "stem", "correctResponse", "allResponses"] };

    switch(quizType) {
        case 'multiple_choice':
                // เพิ่มคำสั่งตัวลวงคมๆ
                const sharpDistractorPrompt = `
                **กฎเหล็กการสร้างตัวเลือก (Distractor Engineering):**
                1. ห้ามสุ่มตัวเลขมั่วๆ มาใส่เป็นตัวหลอก
                2. ตัวเลือกที่ผิด (Distractors) ต้องเกิดจาก "ความผิดพลาดที่พบบ่อย" (Common Misconceptions) ของนักเรียนในเรื่องนั้นๆ
                3. ตัวเลือกต้องดูสมเหตุสมผล ไม่ใช่ผิดแบบเห็นได้ชัด
                4. ถ้าเป็นโจทย์คำนวณ ให้ดักทางคนที่ลืมทดเลข, ลืมเปลี่ยนหน่วย, หรือจำสูตรผิด`;

                prompt = `สร้างแบบทดสอบปรนัย${subjectPrefix} ${settings.numQuestions} ข้อ ${topicInstruction} ${topicRefinementInstruction} ${difficultyInstruction} ${complexityInstruction} ${referenceInstruction}. 
                แต่ละข้อมี ${settings.numChoices} ตัวเลือก. 
                ${sharpDistractorPrompt}
                ระบุคำตอบที่ถูกต้อง. ${imageInstruction} ${simpleMathPrompt}`;
                
                schema = mcqSchema;
                break;
        case 'true_false':
            formatInstruction = `คำถามทุกข้อต้องเป็นแบบ 'ถูก/ผิด' หรือ 'ใช่/ไม่ใช่' เท่านั้น`;
            responseSchema = tfSchema;
            break;
        case 'fill_in_no_choices':
            formatInstruction = `คำถามทุกข้อต้องเป็นแบบ 'เติมคำ' (พิมพ์ตอบเอง)`;
            responseSchema = shortAnswerSchema;
            break;
        case 'matching':
            formatInstruction = `คำถามทุกข้อต้องเป็นแบบ 'จับคู่' (แยกข้อ)`;
            responseSchema = matchingSchema;
            break;
        case 'fill_in_with_choices':
            formatInstruction = `คำถามทุกข้อต้องเป็นแบบ 'เติมคำ (มีตัวเลือกให้)' (มี ${numChoices} ตัวเลือก)`;
            responseSchema = mcqSchema;
            break;
        default:
            formatInstruction = `คำถามทุกข้อต้องเป็นแบบปรนัย 4 ตัวเลือก (มี ${numChoices} ตัวเลือก)`;
            responseSchema = mcqSchema;
            break;
    }

    const languageInstruction = "สร้างเนื้อหาเป็นภาษาไทยเท่านั้น ห้ามมีข้อความภาษาอังกฤษปะปนโดยเด็ดขาด";

    const loader = document.getElementById('loader');
    const loaderText = document.getElementById('loader-text');
    const genQuizContainer = document.getElementById('generated-quiz-container');

    document.getElementById('quiz-generation-area').classList.remove('hidden');
    genQuizContainer.innerHTML = '';
    loader.classList.remove('hidden');
    loaderText.textContent = `AI กำลังสร้างแบบทดสอบ "${selectedTopic}" จำนวน ${numTotalQuestions} ข้อ...`;
    
    try {
        // [แก้ไข] เพิ่มคำสั่งพิเศษเข้าไปใน Prompt
        const applicationStylePrompt = `
**[กฎเพิ่มเติม: ปรัชญาการสร้างโจทย์สไตล์ O-NET]**
บทบาท: คุณคือผู้เชี่ยวชาญการสร้างข้อสอบ O-NET ที่เน้นการวัดความเข้าใจเชิงลึก ไม่ใช่การท่องจำ
ภารกิจ: สร้างโจทย์ที่เน้นการคิดวิเคราะห์และการประยุกต์ใช้ ไม่ใช่โจทย์ความจำหรือการคำนวณในขั้นตอนเดียว โดยต้องมีลักษณะอย่างน้อยหนึ่งข้อต่อไปนี้:

* **โจทย์ปัญหาหลายขั้นตอน (Multi-step Problems):** ผู้เรียนต้องใช้ความรู้มากกว่าหนึ่งเรื่องหรือแก้ปัญหามากกว่าหนึ่งสเต็ปเพื่อหาคำตอบ
* **โจทย์คิดย้อนกลับ (Reverse Thinking):** ให้ผลลัพธ์สุดท้าย แล้วให้นักเรียนหาค่าเริ่มต้น (เช่น ให้กำไรมา แล้วถามหาราคาทุน)
* **การวิเคราะห์ข้อมูล (Data Analysis):** สร้างโจทย์ที่ต้องอ่านและตีความข้อมูลจากสถานการณ์, ตาราง, หรือแผนภูมิที่สมมติขึ้น
* **โจทย์แบบประเมินข้อความ (Statement Evaluation):** สร้างข้อความสรุปอย่างมาก 1 ข้อ (ก, ข, ค) แล้วถามว่า "ข้อใดถูกต้อง" หรือ "มีข้อความที่ถูกต้องกี่ข้อความ"
    
**กฎของตัวลวง (Distractor Rule):** ตัวเลือกที่ไม่ถูกต้อง (ตัวลวง) ควรเป็นผลลัพธ์ที่เกิดจากการคำนวณผิดพลาดในขั้นตอนที่พบบ่อย (เช่น ลืมทด, คำนวณผิดเครื่องหมาย, เข้าใจผิดในแนวคิด) เพื่อให้ข้อสอบสามารถจำแนกผู้เรียนได้ดีขึ้น
`;
        
        const prompt = `
            คุณคือผู้เชี่ยวชาญด้านการสร้างแบบทดสอบเพื่อการทบทวนความรู้
            ภารกิจ: สร้างแบบทดสอบ 1 ชุดสำหรับหัวข้อ "${selectedTopic}" โดยมี **จำนวนข้อสอบรวม ${numTotalQuestions} ข้อ**

            แหล่งข้อมูล:
            1.  ไฟล์ข้อสอบต้นฉบับ (แนบมาให้)
            2.  ความรู้ของ AI

            คำสั่ง:
            1.  **[ขั้นตอนสกัด]** พยายามดึงคำถาม *บางส่วน* (ถ้าพบ) จากไฟล์ต้นฉบับที่ตรงกับหัวข้อ "${selectedTopic}" มาเป็นฐาน
                - **กฎการสกัด:** ให้ดึงเฉพาะ "ข้อความ" ของโจทย์และตัวเลือกเท่านั้น **ห้ามนำรูปภาพต้นฉบับมาด้วย** และ **ห้ามใส่ข้อความอ้างอิงรูปภาพ** (เช่น "image_from_original_source_...") ลงในโจทย์โดยเด็ดขาด
            2.  **[ขั้นตอนสร้างใหม่]** สร้างคำถาม "ใหม่" เพิ่มเติม เพื่อให้ได้จำนวนข้อสอบครบ ${numTotalQuestions} ข้อ
                - คำถาม "ใหม่" ที่สร้าง ต้องมีระดับความยากและสไตล์ใกล้เคียงกับต้นฉบับ
                - ${imageInstruction}
            3.  **[กฎรูปแบบ] ${formatInstruction}** (คำถามทุกข้อต้องเป็นรูปแบบนี้เท่านั้น ห้ามใช้รูปแบบอื่นปน)
            4.  **[กฎภาษา] ${languageInstruction}** (ต้องเป็นภาษาไทยเท่านั้น)
            5.  สร้างเฉลยสำหรับทุกข้อ

            ${applicationStylePrompt}
            ${simpleMathPrompt}
        `;
        
        const finalSchema = { 
            type: "OBJECT", 
            properties: { 
                topic: { type: "STRING" }, 
                questions: { type: "ARRAY", items: responseSchema } 
            }, 
            required: ["topic", "questions"] 
        };

        const parts = [
            { text: prompt },
            { inlineData: { mimeType: fileMimeType, data: fileDataBase64 } }
        ];

        await handleApiCall(parts, `กำลังสร้างแบบทดสอบ "${selectedTopic}"...`, finalSchema);

    } catch (error) {
        console.error("Error generating hybrid quiz:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
        genQuizContainer.innerHTML = `<p class="text-red-500 text-center">ขออภัย, ไม่สามารถสร้างแบบทดสอบได้</p>`;
    } finally {
        loader.classList.add('hidden');
    }
}

async function handleGenerateFromFileClick() {
    if (!selectedFile) {
        showMessage("กรุณาเลือกไฟล์ก่อน");
        return;
    }

    const loader = document.getElementById('loader');
    const loaderText = document.getElementById('loader-text');
    const genQuizContainer = document.getElementById('generated-quiz-container');
    const generateBtn = document.getElementById('generate-from-file-btn');
    const pageRangeInput = document.getElementById('pdf-page-range').value; // [เพิ่ม] อ่านค่าหน้า

    generateBtn.disabled = true;
    document.getElementById('quiz-generation-area').classList.remove('hidden');
    genQuizContainer.innerHTML = '';
    loader.classList.remove('hidden');
    loaderText.textContent = 'กำลังอ่านและเตรียมไฟล์...';

    try {
        let base64String = "";
        let mimeType = selectedFile.type;

        // [เพิ่ม Logic ใหม่] ตรวจสอบการเลือกหน้า PDF
        if (selectedFile.type === 'application/pdf' && pageRangeInput.trim() !== '') {
            
            // 1. อ่านจำนวนหน้าทั้งหมดก่อนเพื่อ Validate
            const tempBuffer = await selectedFile.arrayBuffer();
            const tempPdf = await pdfjsLib.getDocument(tempBuffer).promise;
            const totalPages = tempPdf.numPages;

            // 2. แปลงเลขหน้า
            const selectedPages = parsePageSelection(pageRangeInput, totalPages);

            if (selectedPages && selectedPages.length > 0) {
                loaderText.textContent = `กำลังตัดเลือกเฉพาะหน้า: ${selectedPages.join(', ')} ...`;
                // 3. สร้าง PDF ใหม่จากหน้าที่เลือก
                base64String = await createPdfFromSelectedPages(selectedFile, selectedPages);
                console.log(`PDF sliced. Pages: ${selectedPages.length}`);
            } else {
                // ถ้ากรอกผิด หรือแปลงไม่ได้ ให้ใช้ไฟล์เดิม
                console.warn("Invalid page selection, using full file.");
                base64String = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(selectedFile);
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                });
            }

        } else {
            // [Logic เดิม] ไม่ใช่ PDF หรือไม่ได้เลือกหน้า
            base64String = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(selectedFile);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = (error) => reject(error);
            });
        }

        await generateQuizFromFile(mimeType, base64String);

    } catch (error) {
        console.error("Error processing file for AI:", error);
        showMessage(`เกิดข้อผิดพลาดในการประมวลผลไฟล์: ${error.message}`);
        loader.classList.add('hidden');
        generateBtn.disabled = false;
    }
}

function autoFormatMath(text) {
    if (typeof text !== 'string' || !text) {
        return text;
    }

    // Regex นี้จะมองหานิพจน์ที่พบบ่อยๆ เช่น "ตัวเลข \times ตัวเลข", "ตัวเลข^ตัวเลข", หรือคำสั่ง LaTeX 
    // โดยจะทำงานเฉพาะกับส่วนที่ยังไม่ได้ถูกครอบด้วยเครื่องหมาย $ อยู่แล้ว
    const mathPattern = /((?<!\$)\b(\d+(\.\d+)?\s*(\\times|\\div)\s*\d+(\.\d+)?|(\d+\s*\^\s*\{?\d+\}?)|(\\frac|\\sqrt|\\pm|\\geq|\\leq|\\neq))\b(?!\$))/g;

    let formattedText = text.replace(mathPattern, (match) => {
        // ครอบนิพจน์ที่หาเจอด้วยเครื่องหมาย $
        return `$${match.trim()}$`;
    });

    return formattedText;
}

        function sanitizeQuizData(quizData) {
    if (!quizData || !quizData.questions) return quizData;

    const sanitizeText = (text) => {
            if (typeof text !== 'string') return text;
            let s = text;

            // 1. แปลงวงเล็บ \( ... \) ให้เป็น $ ... $ (ของเดิม)
            s = s.replace(/\\\(/g, '$').replace(/\\\)/g, '$');
            s = s.replace(/\\\[/g, '$$').replace(/\\\]/g, '$$');

            // 2. แก้ไข imes เป็น times (ของเดิมมีอยู่แล้ว แต่อาจไม่ครอบคลุม)
            s = s.replace(/\\?imes\b/g, '\\times'); 
            
            // ▼▼▼ [เพิ่มชุดคำสั่งซ่อมแซมคำสั่ง LaTeX ที่ Backslash หายไป] ▼▼▼
            s = s.replace(/\\?text\b/g, '\\text');   // แก้ ext -> \text
            s = s.replace(/\\?sqrt\b/g, '\\sqrt');   // แก้ sqrt -> \sqrt
            s = s.replace(/\\?frac\b/g, '\\frac');   // แก้ frac -> \frac
            s = s.replace(/\\?cdot\b/g, '\\cdot');   // แก้ cdot -> \cdot
            s = s.replace(/\\?pi\b/g, '\\pi');       // แก้ pi -> \pi
            s = s.replace(/\\?div\b/g, '\\div');     // แก้ div -> \div
            s = s.replace(/\\?leq\b/g, '\\leq');     // แก้ leq -> \leq
            s = s.replace(/\\?geq\b/g, '\\geq');     // แก้ geq -> \geq
            s = s.replace(/\\?approx\b/g, '\\approx'); // แก้ approx -> \approx
            s = s.replace(/\\?ne\b/g, '\\ne');       // แก้ ne -> \ne
            // ▲▲▲

            // 3. Auto Format (จับตัวเลข/สูตรที่ลอยๆ มาใส่ $ ให้)
            const mathPattern = /((?<!\$)\b(\d+(\.\d+)?\s*(\\times|\\div|\\cdot)\s*\d+(\.\d+)?|(\\frac\{.+?\}\{.+?\})|(\\sqrt\{.+?\})|(\\text\{.+?\})|(\\pm|\\geq|\\leq|\\neq))\b(?!\$))/g;
            
            s = s.replace(mathPattern, (match) => {
                return `$${match.trim()}$`;
            });

            return s;
        };

    if (quizData.topic) {
        quizData.topic = sanitizeText(quizData.topic);
    }

    quizData.questions.forEach(q => {
        q.questionText = sanitizeText(q.questionText);
        q.stem = sanitizeText(q.stem);
        
        if (q.options) {
            q.options = q.options.map(opt => sanitizeText(opt));
        } 
        
        if (q.correctResponse) {
            q.correctResponse = sanitizeText(q.correctResponse);
        }
        if (q.allResponses) {
            q.allResponses = q.allResponses.map(resp => sanitizeText(resp));
        }
        
        if (q.idealAnswer) {
             q.idealAnswer = sanitizeText(q.idealAnswer);
        }
    });

    return quizData;
}

        // --- Quiz Generation (Admin) ---
        const simpleMathPrompt = "กฎเหล็ก: นิพจน์ทางคณิตศาสตร์ทั้งหมดต้องอยู่ในรูปแบบ LaTeX ที่ถูกต้อง และต้องถูกห่อหุ้มด้วยเครื่องหมายดอลลาร์ ($) เพียงคู่เดียว";

async function handleGenerateFromLink() {
    const urlInput = document.getElementById('link-url-input');
    const topicInput = document.getElementById('link-topic-input');
    const url = urlInput.value.trim();
    const topic = topicInput.value.trim();

    if (!url) {
        showMessage("กรุณาวาง URL ของบทความก่อน");
        return;
    }

    const loader = document.getElementById('loader');
    const loaderText = document.getElementById('loader-text');
    const genQuizContainer = document.getElementById('generated-quiz-container');
    const generateBtn = document.getElementById('generate-from-link-btn');

    // แสดงสถานะกำลังโหลด
    document.getElementById('quiz-generation-area').classList.remove('hidden');
    genQuizContainer.innerHTML = '';
    loader.classList.remove('hidden');
    loaderText.textContent = 'กำลังดึงข้อมูลจากลิงก์...';
    generateBtn.disabled = true;

    try {
        // ใช้ CORS Proxy เพื่อดึงเนื้อหาจากเว็บไซต์
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
        const response = await fetch(proxyUrl);
        if (!response.ok) {
            throw new Error(`ไม่สามารถดึงข้อมูลจาก URL ได้ (Status: ${response.status})`);
        }
        const htmlContent = await response.text();
        
        // สกัดข้อความล้วนๆ ออกจาก HTML
        const textContent = extractTextFromHtml(htmlContent);

        if (!textContent || textContent.length < 100) {
             throw new Error("ไม่พบเนื้อหาที่เพียงพอในลิงก์ที่ให้มา");
        }

        // ส่งต่อข้อมูลที่ได้ไปให้ฟังก์ชันสร้างแบบทดสอบเดิม
        await generateQuiz(topic, textContent);

    } catch (error) {
        console.error("Error generating from link:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
        genQuizContainer.innerHTML = `<p class="text-red-500 text-center">ขออภัย, ไม่สามารถสร้างแบบทดสอบจากลิงก์ได้</p>`;
    } finally {
        loader.classList.add('hidden');
        generateBtn.disabled = false;
    }
}

function extractTextFromHtml(htmlString) {
    const doc = new DOMParser().parseFromString(htmlString, 'text/html');
    
    // ลบแท็กที่ไม่ต้องการออกไปก่อน เช่น script, style, nav, footer
    doc.querySelectorAll('script, style, nav, footer, header, aside').forEach(el => el.remove());
    
    // ดึงข้อความจาก body
    return doc.body.textContent || "";
}

document.getElementById('generate-from-topic-btn').addEventListener('click', () => {
    // ดึงค่าจากช่องหัวข้อหลักเพียงอย่างเดียว
    const topic = document.getElementById('topic-input').value.trim();

    // ไม่ต้องมีการตรวจสอบเงื่อนไขใดๆ ที่นี่
    // เรียกฟังก์ชัน generateQuiz โดยตรง
    // หาก 'topic' เป็นค่าว่าง ('') ฟังก์ชัน generateQuiz ที่มีอยู่แล้ว
    // จะจัดการสร้างแบบทดสอบ "ความรู้ทั่วไป" ให้เอง
    generateQuiz(topic, null);
});

    // ▼▼▼--- วางโค้ดใหม่ต่อท้ายตรงนี้ได้เลย ---▼▼▼
    document.getElementById('generate-from-text-btn').addEventListener('click', () => {
        const textContent = document.getElementById('text-content-input').value.trim();
        if (!textContent) {
            showMessage("กรุณาวางเนื้อหาที่ต้องการสร้างแบบทดสอบ");
            return;
        }
        const topic = document.getElementById('topic-input').value.trim();
        generateQuiz(topic, textContent);
    });
	
// ▼▼▼ วางทับฟังก์ชัน generateQuiz เดิมทั้งหมด ▼▼▼
async function generateQuiz(topic, textContent, singleQuestionIndex = null, extraParts = null, fromBlueprintPage = false, forcedProjectId = null, blueprintTopicId = null, forceApplicationStyle = false) {
    let settings = {};

    // 1. ตรวจสอบว่ามาจากหน้า Blueprint หรือหน้า Dashboard ปกติ
    if (fromBlueprintPage && blueprintPageSettings) {
        settings = blueprintPageSettings;
    } else {
        const checkedTopics = document.querySelectorAll('#math-topics-checkbox-container input:checked');
        settings = {
            quizType: document.getElementById('quiz-type-select').value,
            numQuestions: document.getElementById('num-questions').value,
            numChoices: document.getElementById('num-choices').value,
            includeImages: document.getElementById('include-images-checkbox').checked,
            isNormalTopic: document.getElementById('force-math-checkbox').checked,
            difficultyValue: document.getElementById('difficulty-level-select').value,
            complexityValue: document.getElementById('question-complexity-select').value,
            selectedTopicNames: Array.from(checkedTopics).map(cb => cb.value)
        };
    }

    const subjectPrefix = settings.isNormalTopic ? "" : "คณิตศาสตร์";
    const difficultyInstruction = settings.difficultyValue !== "auto" ? `โดยให้มีความยากง่ายและใช้คำศัพท์ที่เหมาะสมสำหรับนักเรียนระดับชั้น "${settings.difficultyValue}"` : "";
    const complexityInstruction = settings.complexityValue !== "mixed" ? `โดยเน้นการวัดผลในระดับการคิดแบบ "${settings.complexityValue}" ตามหลัก Bloom's Taxonomy` : "";
    
    let topicRefinementInstruction = "";
    if (settings.selectedTopicNames && settings.selectedTopicNames.length > 0) {
        topicRefinementInstruction = `โดยให้สร้างคำถามจากเนื้อหาในหัวข้อเหล่านี้: ${settings.selectedTopicNames.join(', ')}.`;
    }

    let referenceInstruction = "";
    if (extraParts) {
        referenceInstruction = `
            **[กฎเหล็ก: การอ้างอิงสไตล์]**
            จงวิเคราะห์สไตล์, ระดับความยาก, และลักษณะของโจทย์ จาก "ไฟล์ข้อสอบ O-NET ต้นฉบับ" ที่แนบมานี้ แล้วนำมาเป็น "ต้นแบบ" ในการสร้างโจทย์ชุดใหม่
            **ห้ามคัดลอกโจทย์หรือตัวเลขจากไฟล์อ้างอิงมาโดยตรงเด็ดขาด**
        `;
    }

    let prompt = "";
    let loadingMessage = "";
    let schema;
    let topicInstruction = `เกี่ยวกับหัวข้อ "${topic}"`;
    if (!topic && textContent) {
        topicInstruction = "โดยให้ AI วิเคราะห์หาหัวข้อหลักจากเนื้อหาที่ให้มาโดยอัตโนมัติ";
    } else if (!topic && !textContent) {
        topicInstruction = "เกี่ยวกับหัวข้อ 'ความรู้ทั่วไป'";
    }
    
    // Schema definitions...
    const mcqSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" },  imageCode: { type: "STRING" } }, required: ["questionText", "options", "correctAnswerIndex"] };
    const shortAnswerSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, idealAnswer: { type: "STRING" },  imageCode: { type: "STRING" } }, required: ["questionText", "idealAnswer"] };
    const mixedQuestionSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, questionType: { type: "STRING", "enum": ["multiple_choice", "short_answer"] }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" }, idealAnswer: { type: "STRING" },  imageCode: { type: "STRING" } }, required: ["questionText", "questionType"] };
    const trueFalseSchema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, correctAnswer: { type: "BOOLEAN" },  imageCode: { type: "STRING" } }, required: ["questionText", "correctAnswer"] };
    const matchingItemSchema = { type: "OBJECT", properties: { questionType: { type: "STRING", "enum": ["matching_item"] }, stem: { type: "STRING" }, correctResponse: { type: "STRING" }, allResponses: { type: "ARRAY", items: { type: "STRING" } },  imageCode: { type: "STRING" } }, required: ["questionType", "stem", "correctResponse", "allResponses"] };
    
    let finalSchema;

    if (singleQuestionIndex !== null) {
        // Logic for single question regeneration (unchanged)
        const originalQuestionType = currentQuizData.questions[singleQuestionIndex].questionType;
        const imageInstruction = settings.includeImages ? `สำหรับคำถามนี้ หากจำเป็นต้องมีรูปภาพประกอบ ให้สร้างโค้ด SVG ที่สมบูรณ์.` : '';
        prompt = `สร้างคำถามใหม่ 1 ข้อ ${topicInstruction} ${topicRefinementInstruction} ${difficultyInstruction} ให้มีลักษณะคล้ายกับคำถามเดิมแต่ไม่ซ้ำกัน. ${imageInstruction} ${simpleMathPrompt}`;
        if(originalQuestionType === 'multiple_choice') schema = mcqSchema;
        else if(originalQuestionType === 'matching_item') schema = matchingItemSchema;
        else if(originalQuestionType === 'true_false') schema = trueFalseSchema;
        else schema = shortAnswerSchema;
        finalSchema = schema;
    } else {
        const imageInstruction = settings.includeImages ? `สำหรับแต่ละคำถาม หากจำเป็นต้องมีรูปภาพประกอบ ให้สร้างโค้ด SVG ที่สมบูรณ์.` : '';
        
        switch (settings.quizType) {
            case 'multiple_choice':
                const sharpDistractorPrompt = `**กฎเหล็กการสร้างตัวเลือก:** ห้ามสุ่มตัวเลขมั่ว, ตัวเลือกผิดต้องเกิดจากความเข้าใจผิดที่พบบ่อย, ตัวเลือกต้องดูสมเหตุสมผล`;
                prompt = `สร้างแบบทดสอบปรนัย${subjectPrefix} ${settings.numQuestions} ข้อ ${topicInstruction} ${topicRefinementInstruction} ${difficultyInstruction} ${complexityInstruction} ${referenceInstruction}. แต่ละข้อมี ${settings.numChoices} ตัวเลือก. ${sharpDistractorPrompt} ระบุคำตอบที่ถูกต้อง. ${imageInstruction} ${simpleMathPrompt}`;
                schema = mcqSchema;
                break;
            case 'fill_in_with_choices': 
                prompt = `สร้างคำถามแบบเติมคำในช่องว่าง${subjectPrefix} ${settings.numQuestions} ข้อ ${topicInstruction}. มีตัวเลือก ${settings.numChoices} ตัว. ${imageInstruction} ${simpleMathPrompt}`; 
                schema = mcqSchema; 
                break;
            case 'fill_in_no_choices': 
                prompt = `สร้างคำถามแบบเติมคำในช่องว่าง${subjectPrefix} ${settings.numQuestions} ข้อ ${topicInstruction}. พิมพ์ตอบเอง. ${imageInstruction} ${simpleMathPrompt}`; 
                schema = shortAnswerSchema; 
                break;
            case 'mixed': 
                prompt = `สร้างแบบทดสอบ${subjectPrefix} ${settings.numQuestions} ข้อ ${topicInstruction}, คละกันระหว่างปรนัยและเติมคำ. ${imageInstruction} ${simpleMathPrompt}.`; 
                schema = mixedQuestionSchema; 
                break;
            case 'true_false': 
                prompt = `สร้างคำถามแบบใช่/ไม่ใช่${subjectPrefix} ${settings.numQuestions} ข้อ ${topicInstruction} ${topicRefinementInstruction} ${difficultyInstruction} ${complexityInstruction} ${referenceInstruction}. แต่ละข้อต้องมีคำถาม (questionText), คำตอบที่ถูกต้อง (correctAnswer เป็น true หรือ false) **กฎสำคัญ: สำหรับสูตรคณิตศาสตร์ (LaTeX) ต้องใช้ Double Backslash (\\\\) นำหน้าคำสั่งเสมอ** ${imageInstruction} ${simpleMathPrompt}`; 
                schema = trueFalseSchema; 
                break;
            case 'matching': 
                prompt = `สร้างชุดคำถามจับคู่${subjectPrefix} ${settings.numQuestions} คู่ ${topicInstruction}. **กฎสำคัญ: สำหรับสูตรคณิตศาสตร์ (LaTeX) ต้องใช้ Double Backslash (\\\\) นำหน้าคำสั่งเสมอ** ${imageInstruction} ${simpleMathPrompt}`; 
                schema = matchingItemSchema; 
                break;
        }
        finalSchema = { type: "OBJECT", properties: { topic: { type: "STRING" }, questions: { type: "ARRAY", items: schema } }, required: ["topic", "questions"] };
    }

    // Prepare Prompt Logic (Application Style etc.)
    const applicationStylePrompt = `
**[กฎเพิ่มเติม: ปรัชญาการสร้างโจทย์สไตล์ O-NET]**

**[กฎควบคุมความซับซ้อน (Complexity Control Rule) - สำคัญที่สุด!]**
นี่คือกฎที่สำคัญที่สุด: หากมี "ไฟล์ข้อสอบต้นฉบับ" (ไฟล์อ้างอิง) แนบมาด้วย ภารกิจหลักของคุณคือการสร้างข้อสอบที่มีความซับซ้อน **"เทียบเท่า"** กับไฟล์อ้างอิงนั้น

**ห้าม (DO NOT)** สร้างโจทย์ที่มีความซับซ้อน, มีหลายขั้นตอน, หรือต้องตีความ **"เกินกว่า"** ระดับความยากโดยเฉลี่ยของโจทย์ในไฟล์อ้างอิงโดยเด็ดขาด
ให้ยึดไฟล์อ้างอิงเป็น **"เพดาน" (Ceiling)** ของความซับซ้อน

บทบาท: คุณคือผู้เชี่ยวชาญการสร้างข้อสอบ O-NET ที่เน้นการวัดความเข้าใจเชิงลึก
ภารกิจ: สร้างโจทย์ที่เน้นการคิดวิเคราะห์และการประยุกต์ใช้ (ภายใต้กรอบความซับซ้อนของไฟล์อ้างอิง) โดยอาจมีลักษณะดังนี้:

* **โจทย์ปัญหาหลายขั้นตอน (Multi-step Problems):** (ตราบเท่าที่ยังไม่ยากเกินไฟล์อ้างอิง)
* **โจทย์คิดย้อนกลับ (Reverse Thinking):** (ตราบเท่าที่ยังไม่ยากเกินไฟล์อ้างอิง)
* **การวิเคราะห์ข้อมูล (Data Analysis):** (ตราบเท่าที่ยังไม่ยากเกินไฟล์อ้างอิง)
* **โจทย์แบบประเมินข้อความ (Statement Evaluation):** (ตราบเท่าที่ยังไม่ยากเกินไฟล์อ้างอิง)
    
**กฎของตัวลวงขั้นสูง (Advanced Distractor Rule):**
ห้ามใช้ตัวเลขสุ่ม! ตัวเลือกที่ไม่ถูกต้อง (ตัวลวง) ต้องออกแบบมาอย่างจงใจเพื่อดักจับ "Misconception" ของนักเรียน:
1. **Miscalculation:** คำนวณผิดในจุดสำคัญ (เช่น ลืมตัวทด, ลืมหาร, คูณผิดตำแหน่ง)
2. **Misconception:** ใช้สูตรผิด, สลับตัวแปร, เข้าใจนิยามคลาดเคลื่อน
3. **Partial Answer:** ตอบสิ่งที่โจทย์ไม่ได้ถาม (เช่น โจทย์ถามเส้นรอบรูป แต่ตอบพื้นที่)
4. **Unit Trap:** ลืมแปลงหน่วย หรือแปลงผิด
*ตัวลวงทุกข้อต้องดูสมจริงจนนักเรียนที่ 'เกือบรู้' หลงกลได้*
`;
    
    if (textContent) {
        prompt = forceApplicationStyle ? `จากเนื้อหาต่อไปนี้: "${textContent}", ${prompt}${applicationStylePrompt}` : `จากเนื้อหาต่อไปนี้: "${textContent}", ${prompt}`;
        loadingMessage = 'กำลังวิเคราะห์เนื้อหาและสร้างแบบทดสอบ...';
    } else {
        if (forceApplicationStyle) prompt += applicationStylePrompt;
        loadingMessage = 'กำลังสร้างแบบทดสอบจากหัวข้อ...';
    }
    
    let apiPayload;
    if (extraParts) {
        apiPayload = [ { text: prompt }, ...extraParts ];
        loadingMessage = 'กำลังวิเคราะห์ไฟล์อ้างอิงและสร้างแบบทดสอบ...';
    } else {
        apiPayload = prompt;
    }

    // --- ⭐ เรียก API และ "บันทึกประเภทคำถาม" ลงในตัวแปรกลางทันที ⭐ ---
    const result = await handleApiCall(apiPayload, loadingMessage, finalSchema, singleQuestionIndex, true, forcedProjectId, blueprintTopicId);
    
    if (result && currentQuizData) {
        // บรรทัดนี้สำคัญที่สุด: บังคับให้ currentQuizData จำค่าประเภทคำถามที่ถูกต้องจาก settings
        // ไม่เช่นนั้น saveQuiz จะไม่รู้ว่าข้อสอบนี้เป็นประเภทอะไร (เช่น True/False)
        currentQuizData.quizType = settings.quizType;
    }
    
    return result;
}

async function generateQuizFromFile(mimeType, base64Data) {
        const topic = document.getElementById('file-topic-input').value.trim();
        const quizType = document.getElementById('quiz-type-select').value;
        const numQuestions = parseInt(document.getElementById('num-questions').value) || 5;
        const numChoices = parseInt(document.getElementById('num-choices').value) || 4;
        const includeImages = document.getElementById('include-images-checkbox').checked;
        const isNormalTopic = document.getElementById('force-math-checkbox').checked;
        const subjectPrefix = isNormalTopic ? "" : "คณิตศาสตร์";
        
        // ตรวจสอบสถานะ Original Mode
        const isOriginalMode = document.getElementById('original-mode-checkbox').checked;
        const blueprintTopicId = null; 
        const forcedProjectId = currentProjectId;

        let prompt = "";
        let finalSchema; 
        let loadingMessage = "กำลังวิเคราะห์ไฟล์และสร้างโจทย์...";

        const simpleMathPrompt = `
        - หากเป็นโจทย์คณิตศาสตร์ ให้ใช้ LaTeX ในการเขียนสมการทางคณิตศาสตร์ โดยครอบด้วยเครื่องหมาย $ (เช่น $x^2 + 2x + 1 = 0$)
        `;

        if (isOriginalMode) {
            // ==========================================
            // 🚀 โหมด 1: ORIGINAL MODE (ถอดรหัส + ตัดเลขข้อ)
            // ==========================================
            loadingMessage = "กำลังถอดรหัสข้อสอบ (Original Mode)...";
            prompt = `
            บทบาท: คุณคือเครื่องมือถอดรหัสข้อสอบ (Exam Parser)
            ภารกิจ: ถอดความข้อสอบจากไฟล์ให้อยู่ในรูปแบบ JSON โดยรักษา "จำนวนข้อ" และ "เนื้อหา" ตามต้นฉบับ
            
            คำสั่งสำคัญ (Strict Rules):
            1. **Clean Extraction (ตัดเลขข้อ):** คัดลอกโจทย์ออกมาตามจริง **แต่ต้องตัดเลขข้อ ลำดับข้อ หรือตัวอักษรระบุข้อที่อยู่หน้าสุดออก** - ตัวอย่างที่ถูกต้อง: เปลี่ยน "1. จงหาค่าของ..." เป็น "จงหาค่าของ..."
               - ตัวอย่างที่ถูกต้อง: เปลี่ยน "(3) ข้อใดถูกต้อง" เป็น "ข้อใดถูกต้อง"
               - ตัวอย่างที่ถูกต้อง: เปลี่ยน "ข้อที่ 5. กำหนดให้" เป็น "กำหนดให้"
            2. **Verbatim Content:** เนื้อหาหลังจากเลขข้อต้องเหมือนต้นฉบับ 100% ห้ามสรุปย่อ ห้ามเปลี่ยนคำ
            3. **จำนวนข้อ:** ถ้าไฟล์มี 2 ข้อ ให้ส่งคืน 2 ข้อ (ห้ามขาด ห้ามเกิน)
            4. **เฉลย:** ระบุเฉลยตามไฟล์ (ถ้ามี) หรือวิเคราะห์เอง (ถ้าไม่มี)
            
            ${simpleMathPrompt}
            `;

            finalSchema = {
                type: "OBJECT",
                properties: {
                    topic: { type: "STRING", description: "หัวข้อจากไฟล์" },
                    questions: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                questionText: { type: "STRING", description: "โจทย์ที่ตัดเลขข้อออกแล้ว" }, // ย้ำใน description อีกครั้ง
                                questionType: { type: "STRING", "enum": ["multiple_choice", "short_answer", "true_false", "matching_item", "fill_in_with_choices", "fill_in_no_choices"] },
                                options: { type: "ARRAY", items: { type: "STRING" } },
                                correctAnswerIndex: { type: "NUMBER" },
                                idealAnswer: { type: "STRING" },
                                correctAnswer: { type: "BOOLEAN" },
                                stem: { type: "STRING" },
                                correctResponse: { type: "STRING" },
                                allResponses: { type: "ARRAY", items: { type: "STRING" } },
                                imageCode: { type: "STRING" }
                            },
                            required: ["questionText", "questionType"]
                        }
                    }
                },
                required: ["topic", "questions"]
            };

        } else {
            // ==========================================
            // 🚀 โหมด 2: NORMAL MODE (Dynamic Schema)
            // ==========================================
            loadingMessage = `กำลังสร้างข้อสอบ ${quizType} จำนวน ${numQuestions} ข้อ...`;
            
            const topicInstruction = topic ? `หัวข้อหลัก: "${topic}"` : `วิเคราะห์หัวข้อสำคัญจากไฟล์`;

            // เลือก Schema ให้ตรงกับประเภทข้อสอบ
            let specificItemSchema;

            if (quizType.includes('multiple') || quizType.includes('ปรนัย')) {
                specificItemSchema = {
                    type: "OBJECT",
                    properties: {
                        questionText: { type: "STRING" },
                        questionType: { type: "STRING", "enum": ["multiple_choice"] },
                        options: { type: "ARRAY", items: { type: "STRING" }, description: `ตัวเลือก ${numChoices} ข้อ` },
                        correctAnswerIndex: { type: "NUMBER" }
                    },
                    required: ["questionText", "questionType", "options", "correctAnswerIndex"]
                };
            } else if (quizType.includes('true') || quizType.includes('ถูกผิด')) {
                specificItemSchema = {
                    type: "OBJECT",
                    properties: {
                        questionText: { type: "STRING" },
                        questionType: { type: "STRING", "enum": ["true_false"] },
                        correctAnswer: { type: "BOOLEAN" }
                    },
                    required: ["questionText", "questionType", "correctAnswer"]
                };
            } else if (quizType.includes('match') || quizType.includes('จับคู่')) {
                specificItemSchema = {
                    type: "OBJECT",
                    properties: {
                        questionText: { type: "STRING" },
                        questionType: { type: "STRING", "enum": ["matching_item"] },
                        stem: { type: "STRING" },
                        correctResponse: { type: "STRING" },
                        allResponses: { type: "ARRAY", items: { type: "STRING" } }
                    },
                    required: ["questionText", "questionType", "stem", "correctResponse", "allResponses"]
                };
            } else {
                // Default Schema
                specificItemSchema = {
                    type: "OBJECT",
                    properties: {
                        questionText: { type: "STRING" },
                        questionType: { type: "STRING", "enum": ["multiple_choice", "short_answer", "true_false", "matching_item"] },
                        options: { type: "ARRAY", items: { type: "STRING" } },
                        correctAnswerIndex: { type: "NUMBER" },
                        idealAnswer: { type: "STRING" },
                        correctAnswer: { type: "BOOLEAN" },
                        stem: { type: "STRING" },
                        correctResponse: { type: "STRING" }
                    },
                    required: ["questionText", "questionType"]
                };
            }

            if (includeImages) {
                specificItemSchema.properties.imageCode = { type: "STRING", description: "SVG Code ถ้าจำเป็น" };
            }

            finalSchema = {
                type: "OBJECT",
                properties: {
                    topic: { type: "STRING" },
                    questions: {
                        type: "ARRAY",
                        items: specificItemSchema
                    }
                },
                required: ["topic", "questions"]
            };

            prompt = `
            บทบาท: คุณคือครูผู้เชี่ยวชาญวิชา${subjectPrefix}
            งาน: สร้างแบบทดสอบประเภท "${quizType}" จำนวน ${numQuestions} ข้อ
            อ้างอิงเนื้อหาจาก: ไฟล์ที่แนบมา
            ${topicInstruction}
            
            ข้อกำหนด:
            - สร้างคำถามใหม่ที่ท้าทาย (ห้ามคัดลอกโจทย์เดิม)
            - ถ้าเป็นปรนัย ขอตัวเลือก ${numChoices} ตัว
            - ภาษา: ไทย
            ${simpleMathPrompt}
            ${includeImages ? '- หากข้อไหนต้องใช้รูปประกอบ ให้สร้าง SVG code ใส่ใน imageCode' : ''}
            `;
        }

        const apiPayload = [
            { text: prompt },
            { inlineData: { mimeType: mimeType, data: base64Data } }
        ];

        await handleApiCall(apiPayload, loadingMessage, finalSchema, null, true, forcedProjectId, blueprintTopicId);
    }

async function handleApiCall(promptOrParts, loadingMessage, schema, singleQuestionIndex = null, shouldDisplayQuiz = true, forcedProjectId = null, blueprintTopicId = null) {
    const quizGenArea = document.getElementById('quiz-generation-area');
    const loader = document.getElementById('loader');
    const loaderText = document.getElementById('loader-text');
    const genQuizContainer = document.getElementById('generated-quiz-container');

    quizGenArea.classList.remove('hidden');
    if (singleQuestionIndex === null && shouldDisplayQuiz) {
        genQuizContainer.innerHTML = '';
    }
    loader.classList.remove('hidden');
    loaderText.textContent = loadingMessage;

    // ปิดปุ่มต่างๆ ชั่วคราว
    document.getElementById('generate-from-topic-btn').disabled = true;
    document.getElementById('generate-from-text-btn').disabled = true;
    document.getElementById('generate-from-link-btn').disabled = true;
    const fileBtn = document.getElementById('generate-from-file-btn');
    if (fileBtn) fileBtn.disabled = true;
    const blueprintBtn = document.getElementById('generate-from-blueprint-btn');
    if (blueprintBtn) blueprintBtn.disabled = true;
    const parallelBtn = document.getElementById('generate-from-parallel-test-btn');
    if (parallelBtn) parallelBtn.disabled = true;

    try {
        const parts = Array.isArray(promptOrParts) ? promptOrParts : [{ text: promptOrParts }];
        const payload = { contents: [{ role: "user", parts: parts }] };

        if (schema) {
            payload.generationConfig = {
                responseMimeType: "application/json",
                responseSchema: schema
            };
        }

        const apiKey = "AIzaSyB8ziZtJkPE4_53A4djxRjAXI_DDOP_vdg"; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        
        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) {
            const errorBody = await response.text();
            console.error("API Error Response:", errorBody);
            throw new Error(`API call failed with status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (!result.candidates || result.candidates.length === 0) {
            let detailedError = "AI did not return any content.";
            if (result.promptFeedback?.blockReason) {
                detailedError = `Content was blocked by safety filters. Reason: ${result.promptFeedback.blockReason}.`;
            }
            console.error(detailedError, JSON.stringify(result));
            return null; 
        }

        const rawText = result.candidates[0].content.parts[0].text;

        if (schema) {
            let jsonText = rawText;
            if (jsonText.startsWith("```json")) {
                jsonText = jsonText.substring(7, jsonText.length - 3).trim();
            } else if (jsonText.startsWith("```")) {
                jsonText = jsonText.substring(3, jsonText.length - 3).trim();
            }
            let parsedData = JSON.parse(jsonText);

            // ▼▼▼ [จุดที่แก้ไข] จัดการคำถามแบบจับคู่ (Matching) ให้ใช้ตัวเลือกร่วมกัน ▼▼▼
            if (parsedData.questions && Array.isArray(parsedData.questions)) {
                // 1. หาข้อที่เป็นแบบจับคู่
                const matchingQs = parsedData.questions.filter(q => q.questionType === 'matching_item');
                
                if (matchingQs.length > 1) {
                    // 2. รวบรวม "คำตอบที่ถูกต้อง" (correctResponse) จากทุกข้อมาไว้ในกองกลาง
                    // (กรองค่าว่างทิ้งไป เพื่อความชัวร์)
                    const sharedPool = matchingQs.map(q => q.correctResponse).filter(ans => ans && ans.trim() !== "");
                    
                    // 3. สุ่มลำดับตัวเลือกในกองกลาง เพื่อไม่ให้เรียงตามข้อ (1->A, 2->B)
                    // (ใช้ฟังก์ชัน shuffleArray ที่มีอยู่แล้ว)
                    shuffleArray(sharedPool);

                    // 4. ยัดกองกลางกลับเข้าไปใน 'allResponses' ของทุกข้อ
                    matchingQs.forEach(q => {
                        q.allResponses = [...sharedPool]; // Copy array ไปใส่
                    });
                    
                    console.log("Matching options synced:", sharedPool);
                }
            }
            // ▲▲▲ [สิ้นสุดการแก้ไข] ▲▲▲

            if (shouldDisplayQuiz) {
                if (singleQuestionIndex !== null) {
                    // กรณีสร้างใหม่รายข้อ (Regenerate single question)
                    if (currentEditingQuizData && currentEditingQuizData.questions) {
                         // ถ้าข้อที่สร้างใหม่เป็น matching เราต้องระวังไม่ให้มันหลุดกลุ่ม
                         // แต่ใน editor มักแก้ทีละข้อ การดึง pool เดิมมาใช้อาจซับซ้อน 
                         // เบื้องต้นให้ใช้ข้อมูลใหม่ไปก่อน หรือถ้าเป็นไปได้ควรอ่าน pool จากข้ออื่น
                         // (ในที่นี้ปล่อยให้เป็นหน้าที่ของ Editor logic)
                    }
                } else {
                    currentQuizData = parsedData;
                    displayGeneratedQuiz(currentQuizData, forcedProjectId, blueprintTopicId);
                }
            }
            return parsedData;
        } else {
            return rawText;
        }

    } catch (error) {
        console.error("Error in handleApiCall:", error);
        showMessage(`เกิดข้อผิดพลาดในการสร้าง: ${error.message}`);
        if (shouldDisplayQuiz) {
            genQuizContainer.innerHTML = `<p class="text-red-500 text-center">ขออภัย, ไม่สามารถสร้างได้</p>`;
        }
        throw error;
    } finally {
        loader.classList.add('hidden');
        document.getElementById('generate-from-topic-btn').disabled = false;
        document.getElementById('generate-from-text-btn').disabled = false;
        document.getElementById('generate-from-link-btn').disabled = false;
        if (fileBtn) fileBtn.disabled = false;
        if (blueprintBtn) blueprintBtn.disabled = false;
        if (parallelBtn) parallelBtn.disabled = false;
    }
}

        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen().catch(err => console.error(err));
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
        }

function enterFullscreen() {
    const elem = document.documentElement; // ตัวแทนของทั้งหน้าเว็บ
    if (elem.requestFullscreen) {
        elem.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        });
    } else if (elem.webkitRequestFullscreen) { /* Safari */
        elem.webkitRequestFullscreen();
    } else if (elem.msRequestFullscreen) { /* IE11 */
        elem.msRequestFullscreen();
    }
}

/**
 * ฟังก์ชันกลางสำหรับจัดการการออกจากจอ (ป้องกันการนับซ้ำซ้อน)
 */
function handleCheatingEvent() {
    // ถ้ากำลังอยู่ในช่วง Cooldown ให้เมินอีเวนต์นี้ไปเลย
    if (cheatDetectionTimeout) return;

    // ถ้าไม่ใช่ช่วง Cooldown ให้เริ่มทำงาน
    cheatAttempts++;
    logBehaviorEvent('screen_exit', { attemptNumber: cheatAttempts });

    if (cheatAttempts >= maxCheatAttempts) {
        isQuizActive = false;
        showMessage(`ตรวจพบการออกจากหน้าจอครบ ${maxCheatAttempts} ครั้ง ระบบได้ทำการส่งคำตอบของคุณอัตโนมัติ`);

        if (document.getElementById('quiz-form')) {
            handleSubmitQuiz(null);
        } else {
            finalizePerQuestionQuiz();
        }
        document.removeEventListener('visibilitychange', handleVisibilityChange);
        document.removeEventListener('fullscreenchange', handleFullscreenChange);
    } else {
        showMessage(
            `คำเตือน (${cheatAttempts}/${maxCheatAttempts}): กรุณาอย่าออกจากหน้าจอระหว่างทำแบบทดสอบ`,
            enterFullscreen 
        );
    }

    // เริ่ม Cooldown: ตั้งเวลา 500 มิลลิวินาที (0.5 วินาที)
    // ในช่วงเวลานี้ ฟังก์ชันนี้จะไม่ทำงานอีก
    cheatDetectionTimeout = setTimeout(() => {
        cheatDetectionTimeout = null; // เมื่อครบเวลา ให้เคลียร์ Cooldown
    }, 500);
}

function handleVisibilityChange() {
    if (currentMode === 'admin-testing' || !isQuizActive) return;
    if (document.visibilityState === 'hidden') {
        handleCheatingEvent();
    } else if (document.visibilityState === 'visible') {
        console.log("กลับเข้าสู่หน้าจอแบบทดสอบแล้ว, กำลังรีเซ็ตระบบป้องกัน...");
        requestWakeLock();
        resetDimTimer();
    }
}

function handleFullscreenChange() {
    if (currentMode === 'admin-testing' || !isQuizActive) return;
    if (!document.fullscreenElement) {
        handleCheatingEvent();
    }
}

function displayGeneratedQuiz(quizData, forcedProjectId = null, blueprintTopicId = null) {
    const container = document.getElementById('generated-quiz-container');
    let html = `<h3 class="text-xl font-bold mb-3" contenteditable="true" id="editable-quiz-topic">${quizData.topic}</h3>`;
    
    quizData.questions.forEach((q, index) => {
        if (!q.id) { q.id = `q_${Date.now()}_${index}`; }
        
        const questionType = q.questionType || quizData.quizType;
        
        html += `
            <div class="mb-4 p-4 border rounded-lg relative group" data-question-index="${index}">
                <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2">
                     <button data-index="${index}" class="edit-question-btn text-blue-600 hover:text-blue-800 p-1" title="แก้ไขข้อนี้"><i class="fas fa-pen"></i></button>
                     <button data-index="${index}" class="regenerate-question-btn text-green-600 hover:text-green-800 p-1" title="สร้างข้อนี้ใหม่"><i class="fas fa-sync-alt"></i></button>
                </div>
        `;

        // ส่วนแสดงโจทย์
        if (questionType === 'matching_item') {
            html += `<p class="font-semibold" id="q-text-${index}">${index + 1}. ${q.stem}</p>`;
        } else {
            html += `<p class="font-semibold" id="q-text-${index}">${index + 1}. ${q.questionText}</p>`;
        }

        if (q.imageCode) {
            html += `<div id="q-image-container-${index}" class="my-4 flex justify-center">${q.imageCode}</div>`;
        }

        // --- [Logic ใหม่: ตรวจสอบข้อมูลเพื่อเลือกวิธีแสดงผลที่ถูกต้อง] ---
        
        // กรณีที่ 1: มีตัวเลือก (Options) -> แสดงแบบปรนัย
        if (q.options && Array.isArray(q.options) && q.options.length > 0) {
            html += `<ul class="list-disc list-inside mt-2 space-y-1 text-sm" id="q-options-${index}">
                         ${q.options.map((opt, i) => `<li class="${i === q.correctAnswerIndex ? 'text-green-600 font-bold' : ''}">${opt}</li>`).join('')}
                     </ul>`;
        
        // กรณีที่ 2: เป็นจับคู่ -> แสดงคำตอบคู่กัน
        } else if (questionType === 'matching_item' || q.correctResponse) {
            html += `<div class="mt-2 p-2 bg-green-100 text-sm"><strong class="text-gray-700">คำตอบที่ถูกต้อง:</strong> <span id="q-correct-${index}">${q.correctResponse}</span></div>`;
        
        // กรณีที่ 3: เป็น True/False
        } else if (questionType === 'true_false' || typeof q.correctAnswer === 'boolean') {
             html += `<div class="mt-2 space-y-1 text-sm">
                         <p class="${q.correctAnswer === true ? 'text-green-600 font-bold' : ''}">ใช่</p>
                         <p class="${q.correctAnswer === false ? 'text-green-600 font-bold' : ''}">ไม่ใช่</p>
                     </div>`;
        
        // กรณีที่ 4: (Fallback) ถ้าไม่มีตัวเลือก แต่มี idealAnswer -> แสดงแบบเติมคำ
        } else if (q.idealAnswer) {
            html += `<div class="mt-2 p-2 bg-gray-100 text-sm"><strong class="text-gray-700">คำตอบที่คาดหวัง:</strong> <span id="q-ideal-${index}">${q.idealAnswer}</span></div>`;
        
        } else {
            // กรณีไม่เข้าพวกจริงๆ (ข้อมูลไม่ครบ)
             html += `<p class="text-red-500 text-sm">ข้อผิดพลาด: ไม่พบข้อมูลเฉลยหรือตัวเลือก</p>`;
        }

        html += `</div>`;
    });

    html += `<div id="generated-quiz-actions" class="mt-4">
        <div class="flex items-center justify-center my-3">
            <input id="pre-test-checkbox" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
            <label for="pre-test-checkbox" class="ml-2 block text-sm font-medium text-gray-900">บันทึกเป็นแบบทดสอบก่อนเรียน (Pre-test)</label>
        </div>
        <button id="verify-answers-btn" class="w-full bg-yellow-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-yellow-600 flex items-center justify-center mb-2"><i class="fas fa-check-double mr-2"></i>ตรวจทานความถูกต้องของเฉลย (AI)</button>
        <button id="export-worksheet-pdf-btn" class="w-full bg-red-600 text-white py-2 px-4 rounded-lg font-semibold hover:bg-red-700 flex items-center justify-center mb-2"><i class="fas fa-file-pdf mr-2"></i>Export เป็นใบงาน (PDF)</button>
        <button id="save-quiz-btn" class="w-full bg-green-600 text-white py-2 px-4 rounded-lg font-semibold hover:bg-green-700"><i class="fas fa-save mr-2"></i>บันทึกและสร้างรหัส</button>
    </div>`;
    
    container.innerHTML = html;
    
    document.querySelectorAll('.edit-question-btn').forEach(btn => btn.addEventListener('click', handleEditQuestion));
    document.querySelectorAll('.regenerate-question-btn').forEach(btn => btn.addEventListener('click', handleRegenerateQuestion));
    document.getElementById('export-worksheet-pdf-btn').addEventListener('click', exportQuizAsWorksheetPDF);
    document.getElementById('verify-answers-btn').addEventListener('click', handleVerifyAnswers);

    const saveButton = document.getElementById('save-quiz-btn');
    if (saveButton) {
        const projectIdForSave = forcedProjectId || currentProjectId; 
        saveButton.addEventListener('click', () => saveQuiz(projectIdForSave, blueprintTopicId));
    }

    if (window.MathJax) window.MathJax.typesetPromise([container]);
}
        
        function handleRegenerateQuestion(e) {
            const index = e.currentTarget.dataset.index;
            const topic = currentQuizData.topic;
            showMessage(`กำลังสร้างคำถามข้อ ${parseInt(index) + 1} ใหม่...`);
            generateQuiz(topic, null, parseInt(index));
        }

        // --- SVG Drag and Drop Functions (Mouse & Touch) ---
        function getPointerPosition(svg, evt) {
            const CTM = svg.getScreenCTM();
            let clientX, clientY;

            // Check for touch event
            if (evt.touches && evt.touches.length > 0) {
                clientX = evt.touches[0].clientX;
                clientY = evt.touches[0].clientY;
            } else {
                // Fallback to mouse event
                clientX = evt.clientX;
                clientY = evt.clientY;
            }

            return {
                x: (clientX - CTM.e) / CTM.a,
                y: (clientY - CTM.f) / CTM.d
            };
        }

        function startDrag(evt) {
            // Prevent default touch actions like scrolling
            if (evt.type === 'touchstart') {
                evt.preventDefault();
            }
            const target = evt.target.closest('.draggable-text');
            if (target) {
                draggedSvgElement = target;
                const svg = draggedSvgElement.ownerSVGElement;
                const pointerPos = getPointerPosition(svg, evt);

                svgOffset.x = pointerPos.x - parseFloat(draggedSvgElement.getAttributeNS(null, "x"));
                svgOffset.y = pointerPos.y - parseFloat(draggedSvgElement.getAttributeNS(null, "y"));
            }
        }
		
/**
 * คำนวณค่าความยาก (p), ค่าอำนาจจำแนก (r), และรายชื่อนักเรียนในกลุ่มต่างๆ
 * @param {object} quizData ข้อมูลของแบบทดสอบ
 * @param {Array} submissions ข้อมูลการส่งงานของนักเรียนทุกคน
 * @returns {object} อ็อบเจกต์ที่เก็บทั้งสถิติรายข้อ (perQuestionStats) และข้อมูลกลุ่มภาพรวม (overallGroups)
 */
function calculateItemAnalysis(quizData, submissions) {
    const analysisResults = {};
    if (submissions.length < 2) return { perQuestionStats: {}, overallGroups: null }; // แก้ไข return ค่าว่าง

    const sortedSubmissions = [...submissions].sort((a, b) => {
    // 1. เรียงตามคะแนนล่าสุด (มากไปน้อย)
    const scoreDiff = b.latestScore - a.latestScore;
    if (scoreDiff !== 0) return scoreDiff;

    // 2. ถ้าคะแนนเท่ากัน ให้เรียงตามจำนวนครั้งที่ทำ (น้อยไปมาก)
    const attemptsA = a.attempts?.length || 1;
    const attemptsB = b.attempts?.length || 1;
    const attemptDiff = attemptsA - attemptsB;
    if (attemptDiff !== 0) return attemptDiff;

    // 3. ถ้าจำนวนครั้งเท่ากัน ให้เรียงตามเวลาที่ส่ง (ก่อนไปหลัง)
    const timeA = new Date(a.latestSubmittedAt);
    const timeB = new Date(b.latestSubmittedAt);
    const timeDiff = timeA - timeB;
    if (timeDiff !== 0) return timeDiff;

    // 4. ถ้าเวลาส่งเท่ากัน ให้เรียงตามชื่อ (ก-ฮ)
    return a.studentName.localeCompare(b.studentName, 'th');
});
    const totalStudents = sortedSubmissions.length;

    const groupSize = Math.max(1, Math.floor(totalStudents * 0.33));
    if (groupSize === 0) return { perQuestionStats: {}, overallGroups: null }; // แก้ไข return ค่าว่าง

    const upperGroup = sortedSubmissions.slice(0, groupSize);
    const lowerGroup = sortedSubmissions.slice(-groupSize);

    // [เพิ่มส่วนนี้] สร้างรายชื่อกลุ่มภาพรวม
    const overallUpperGroupNames = upperGroup.map(sub => sub.studentName);
    const overallLowerGroupNames = lowerGroup.map(sub => sub.studentName);

    quizData.questions.forEach((question, index) => {
        const questionText = question.stem || question.questionText;
        let totalCorrect = 0;
        let upperCorrect = 0;
        let lowerCorrect = 0;

        const upperGroupResponders = [];
        const lowerGroupResponders = [];

        upperGroup.forEach(sub => {
            const latestAttempt = sub.attempts[sub.attempts.length - 1];
            const answerItem = latestAttempt.answers.find(ans => ans.originalQuestionText === questionText);
            upperGroupResponders.push({ name: sub.studentName, isCorrect: answerItem ? answerItem.isCorrect : false });
            if (answerItem && answerItem.isCorrect) {
                upperCorrect++;
            }
        });

        lowerGroup.forEach(sub => {
            const latestAttempt = sub.attempts[sub.attempts.length - 1];
            const answerItem = latestAttempt.answers.find(ans => ans.originalQuestionText === questionText);
            lowerGroupResponders.push({ name: sub.studentName, isCorrect: answerItem ? answerItem.isCorrect : false });
            if (answerItem && answerItem.isCorrect) {
                lowerCorrect++;
            }
        });
        
        submissions.forEach(sub => {
            const latestAttempt = sub.attempts[sub.attempts.length - 1];
            const answerItem = latestAttempt.answers.find(ans => ans.originalQuestionText === questionText);
            if (answerItem && answerItem.isCorrect) {
                totalCorrect++;
            }
        });

        const p_value = totalStudents > 0 ? (totalCorrect / totalStudents) : 0;
        const r_value = groupSize > 0 ? (upperCorrect / groupSize) - (lowerCorrect / groupSize) : 0;
        
        analysisResults[index] = { 
            p: p_value, 
            r: r_value,
            upperGroupResponders: upperGroupResponders,
            lowerGroupResponders: lowerGroupResponders
        };
    });

    // [แก้ไขส่วนนี้] เปลี่ยนรูปแบบการ return ข้อมูล
    return {
        perQuestionStats: analysisResults,
        overallGroups: {
            upperGroupNames: overallUpperGroupNames,
            lowerGroupNames: overallLowerGroupNames
        }
    };
}

        function drag(evt) {
            if (draggedSvgElement) {
                evt.preventDefault();
                const svg = draggedSvgElement.ownerSVGElement;
                const pointerPos = getPointerPosition(svg, evt);
                const viewBox = svg.viewBox.baseVal;

                // Calculate proposed new coordinates
                let newX = pointerPos.x - svgOffset.x;
                let newY = pointerPos.y - svgOffset.y;

                // Get the bounding box of the text element itself to prevent it from going partially off-screen
                const textBBox = draggedSvgElement.getBBox();

                // Clamp coordinates within the SVG viewbox
                newX = Math.max(viewBox.x, Math.min(newX, viewBox.x + viewBox.width - textBBox.width));
                newY = Math.max(viewBox.y, Math.min(newY, viewBox.y + viewBox.height - textBBox.height));

                draggedSvgElement.setAttributeNS(null, "x", newX);
                draggedSvgElement.setAttributeNS(null, "y", newY);
            }
        }

        function endDrag(evt) {
            draggedSvgElement = null;
        }

        // --- SVG Edit Click Handler ---
        function handleSvgEditClick(e) {
            if (e.target.classList.contains('delete-svg-btn')) {
                const targetId = e.target.dataset.targetId;
                const svg = e.currentTarget;
                const textElementToDelete = svg.querySelector(`#${targetId}`);
                if (textElementToDelete) {
                    textElementToDelete.remove();
                }
                e.target.remove(); // Remove the delete button itself
            }
        }
        
        function handleEditQuestion(e) {
            const btn = e.currentTarget;
            const index = btn.dataset.index;
            const q = currentQuizData.questions[index];
            const qTextEl = document.getElementById(`q-text-${index}`);
            const imageContainer = document.getElementById(`q-image-container-${index}`);

            if (btn.innerHTML.includes('fa-pen')) { // --- Start edit mode ---
                btn.innerHTML = '<i class="fas fa-save"></i>';
                btn.title = "บันทึกการแก้ไข";

                if(qTextEl) qTextEl.contentEditable = true;

                if (imageContainer) {
                    const svgElement = imageContainer.querySelector('svg');
                    if (svgElement) {
                        const textElements = svgElement.querySelectorAll('text');
                        textElements.forEach((textEl, i) => {
                            const textId = `editable-text-${index}-${i}`;
                            textEl.id = textId;
                            textEl.classList.add('draggable-text');
                            textEl.style.cursor = 'move';

                            // Create and append delete button
                            const deleteBtn = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            const textBBox = textEl.getBBox();
                            deleteBtn.setAttribute('cx', String(textBBox.x + textBBox.width + 5));
                            deleteBtn.setAttribute('cy', String(textBBox.y + textBBox.height / 2 - 5));
                            deleteBtn.setAttribute('r', '5');
                            deleteBtn.setAttribute('fill', 'red');
                            deleteBtn.setAttribute('class', 'delete-svg-btn');
                            deleteBtn.dataset.targetId = textId;
                            textEl.after(deleteBtn);
                        });
                        
                        // Add event listeners for drag and delete
                        svgElement.addEventListener('mousedown', startDrag);
                        svgElement.addEventListener('mousemove', drag);
                        svgElement.addEventListener('mouseup', endDrag);
                        svgElement.addEventListener('mouseleave', endDrag);
                        svgElement.addEventListener('touchstart', startDrag, { passive: false });
                        svgElement.addEventListener('touchmove', drag, { passive: false });
                        svgElement.addEventListener('touchend', endDrag);
                        svgElement.addEventListener('touchcancel', endDrag);
                        svgElement.addEventListener('click', handleSvgEditClick);
                    }
                }
                if(qTextEl) qTextEl.focus();

            } else { // --- Save edits ---
                btn.innerHTML = '<i class="fas fa-pen"></i>';
                btn.title = "แก้ไขข้อนี้";

                if(qTextEl) {
                    qTextEl.contentEditable = false;
                    const questionType = q.questionType || currentQuizData.quizType;
                    if (questionType === 'matching_item') {
                         q.stem = qTextEl.innerText.substring(qTextEl.innerText.indexOf('.') + 2).trim();
                    } else {
                         q.questionText = qTextEl.innerText.substring(qTextEl.innerText.indexOf('.') + 2).trim();
                    }
                }

                if (imageContainer) {
                    const svgElement = imageContainer.querySelector('svg');
                    if (svgElement) {
                        // Clone the SVG to manipulate it without affecting the display
                        const svgClone = svgElement.cloneNode(true);
                        
                        // Remove delete buttons and other edit-mode artifacts from the clone
                        svgClone.querySelectorAll('.delete-svg-btn').forEach(btn => btn.remove());
                        svgClone.querySelectorAll('.draggable-text').forEach(el => {
                            el.classList.remove('draggable-text');
                            el.style.cursor = 'default';
                            el.removeAttribute('id');
                        });

                        // Save the cleaned HTML
                        q.imageCode = svgClone.outerHTML;

                        // Now, remove listeners and artifacts from the displayed SVG
                        svgElement.removeEventListener('mousedown', startDrag);
                        svgElement.removeEventListener('mousemove', drag);
                        svgElement.removeEventListener('mouseup', endDrag);
                        svgElement.removeEventListener('mouseleave', endDrag);
                        svgElement.removeEventListener('touchstart', startDrag);
                        svgElement.removeEventListener('touchmove', drag);
                        svgElement.removeEventListener('touchend', endDrag);
                        svgElement.removeEventListener('touchcancel', endDrag);
                        svgElement.removeEventListener('click', handleSvgEditClick);
                        
                        svgElement.querySelectorAll('.delete-svg-btn').forEach(btn => btn.remove());
                        svgElement.querySelectorAll('.draggable-text').forEach(el => {
                            el.classList.remove('draggable-text');
                            el.style.cursor = 'default';
                        });
                    }
                }
            }
        }

let currentEditingQuizData = null; // เพิ่มตัวแปร global นี้ไว้ด้านบนของ script

        // ฟังก์ชันที่ 1: เปิด Editor และดึงข้อมูล
        async function handleOpenQuizEditor(quizId) {
            const editorModal = document.getElementById('quiz-editor-modal');
            const questionsContainer = document.getElementById('quiz-editor-questions-container');
            
            questionsContainer.innerHTML = '<div class="loader mx-auto"></div>';
            editorModal.classList.remove('hidden');

            try {
                const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
                const quizSnap = await getDoc(quizRef);

                if (!quizSnap.exists()) {
                    throw new Error("ไม่พบแบบทดสอบ");
                }
                
                currentEditingQuizData = { id: quizId, ...quizSnap.data() };
                renderQuizEditor(currentEditingQuizData);

            } catch (error) {
                console.error("Error opening quiz editor:", error);
                showMessage("เกิดข้อผิดพลาดในการโหลดข้อมูลแบบทดสอบ");
                editorModal.classList.add('hidden');
            }
        }

function renderQuizEditor(quizData) {
    document.getElementById('editor-quiz-topic').value = quizData.topic;
    const questionsContainer = document.getElementById('quiz-editor-questions-container');
    
    let html = quizData.questions.map((q, index) => {
        let questionContent = '';
        const questionType = q.questionType || quizData.quizType;
        
        // ตรวจสอบว่าเป็นโจทย์แบบ "เติมคำที่มีตัวเลือกซ่อนอยู่" หรือไม่
        const hasHiddenOptions = (questionType === 'short_answer' || questionType === 'fill_in_no_choices') && q.options && q.options.length > 0;

        switch(questionType) {
            case 'multiple_choice':
                const optionsHTML = (q.options || []).map((opt, optIndex) => `
                    <div class="flex items-center gap-2">
                        <input type="radio" name="correct-answer-${index}" value="${optIndex}" ${optIndex === q.correctAnswerIndex ? 'checked' : ''} class="accent-green-600">
                        <input type="text" value="${opt}" class="w-full p-1 border rounded-md option-input">
                    </div>
                `).join('');
                questionContent = `
                    <label class="block text-sm font-medium text-gray-600">ตัวเลือกและเฉลย:</label>
                    <div class="space-y-2 mt-1">${optionsHTML}</div>
                `;
                break;
            
            case 'fill_in_no_choices':
            case 'short_answer':
                 questionContent = `
                    <label class="block text-sm font-medium text-gray-600">เฉลยที่ถูกต้อง:</label>
                    <input type="text" value="${q.idealAnswer || ''}" class="w-full p-1 border rounded-md ideal-answer-input">
                 `;
                 
                 // --- [เพิ่ม] ส่วนแสดงตัวเลือกที่ถูกซ่อน (สำหรับ Black Market) ---
                 if (hasHiddenOptions) {
                     const hiddenOptionsHTML = (q.options || []).map((opt, optIndex) => `
                        <div class="flex items-center gap-2 opacity-75">
                            <input type="radio" name="hidden-correct-answer-${index}" value="${optIndex}" ${optIndex === q.correctAnswerIndex ? 'checked' : ''} class="accent-gray-500" disabled>
                            <input type="text" value="${opt}" class="w-full p-1 border border-dashed border-gray-400 rounded-md bg-gray-50 hidden-option-input">
                        </div>
                    `).join('');
                    
                    questionContent += `
                        <div class="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                            <div class="flex items-center gap-2 mb-2 text-yellow-800 text-xs font-bold">
                                <i class="fas fa-eye-slash"></i>
                                <span>ตัวเลือกที่ถูกซ่อน (ใช้สำหรับไอเทม "เผยตัวเลือก" ใน Sync Mode)</span>
                            </div>
                            <div class="space-y-2">${hiddenOptionsHTML}</div>
                        </div>
                    `;
                 }
                 // -------------------------------------------------------
                break;
            
            case 'true_false':
                questionContent = `
                    <label class="block text-sm font-medium text-gray-600">เฉลย:</label>
                    <div class="space-y-1 mt-1">
                        <div class="flex items-center gap-2"><input type="radio" name="correct-answer-${index}" value="true" ${q.correctAnswer === true ? 'checked' : ''} class="accent-green-600"> <span>ใช่ / ถูก</span></div>
                        <div class="flex items-center gap-2"><input type="radio" name="correct-answer-${index}" value="false" ${q.correctAnswer === false ? 'checked' : ''} class="accent-green-600"> <span>ไม่ใช่ / ผิด</span></div>
                    </div>
                `;
                break;
            case 'matching_item':
                questionContent = `
                     <label class="block text-sm font-medium text-gray-600">เฉลยที่ถูกต้อง (คู่ของคำถามนี้):</label>
                     <input type="text" value="${q.correctResponse || ''}" class="w-full p-1 border rounded-md correct-response-input">
                `;
                break;
        }

        let questionText = q.questionText || q.stem || '';
        questionText = questionText.replace(/<br\s*\/?>/gi, '\n'); 

        // ปุ่ม Toggle (แสดงเฉพาะ Multiple Choice หรือ Short Answer ที่มีตัวเลือกซ่อน)
        let toggleBtnHTML = '';
        if (questionType === 'multiple_choice') {
            toggleBtnHTML = `<button class="toggle-hidden-options-btn text-purple-600 hover:text-purple-800 p-1 rounded-full hover:bg-purple-100" title="แปลงเป็นแบบเติมคำ (แต่ซ่อนตัวเลือกไว้ขาย)">
                                <i class="fas fa-eye-slash"></i>
                             </button>`;
        } else if (hasHiddenOptions) {
            toggleBtnHTML = `<button class="toggle-hidden-options-btn text-purple-600 hover:text-purple-800 p-1 rounded-full hover:bg-purple-100" title="กลับคืนเป็นแบบตัวเลือก (Multiple Choice)">
                                <i class="fas fa-eye"></i>
                             </button>`;
        }

        return `
         <div class="p-4 border rounded-lg bg-gray-50 question-editor-item relative" data-q-index="${index}" data-q-type="${questionType}">

            <div class="absolute top-2 right-2 flex items-center gap-2">
                ${toggleBtnHTML} <button class="ai-fix-question-btn text-yellow-600 hover:text-yellow-800 p-1 rounded-full hover:bg-yellow-100" title="ให้ AI ช่วยแก้ไขข้อผิดพลาดข้อนี้">
                    <i class="fas fa-magic-wand-sparkles"></i>
                </button>
                <button class="ai-fix-formula-btn text-blue-600 hover:text-blue-800 p-1 rounded-full hover:bg-blue-100" title="ให้ AI ช่วยซ่อมสูตร LaTeX">
                    <i class="fas fa-square-root-alt"></i>
                </button>
                <button class="regenerate-question-editor-btn text-green-600 hover:text-green-800 p-1 rounded-full hover:bg-green-100" title="สร้างโจทย์ข้อนี้ใหม่">
                    <i class="fas fa-sync-alt"></i>
                </button>
                <button class="delete-question-editor-btn text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100" title="ลบคำถามข้อนี้">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
            <label class="block text-sm font-medium text-gray-700 mb-1">คำถามข้อที่ ${index + 1} (${questionType}):</label>
            
            <textarea class="w-full p-2 border border-gray-300 rounded-lg auto-resize-textarea">${questionText}</textarea>
            
            <div class="mt-3">${questionContent}</div>
        </div>
        `;
    }).join('');

    questionsContainer.innerHTML = html;

    const addQuestionButtonHTML = `
        <div class="mt-4 flex justify-center items-center gap-2 p-4 bg-gray-100 rounded-lg">
            <span class="text-sm font-medium text-gray-700">เพิ่มข้อใหม่แบบ:</span>
            <select id="new-question-type-select" class="p-2 border border-gray-300 rounded-lg text-sm">
                <option value="multiple_choice">ปรนัย (4 ตัวเลือก)</option>
                <option value="short_answer">เติมคำ (พิมพ์ตอบ)</option>
                <option value="true_false">ถูก/ผิด</option>
                <option value="matching_item">จับคู่</option>
            </select>
            <button id="add-question-editor-btn" class="bg-blue-600 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-700 flex items-center gap-2">
                <i class="fas fa-plus-circle"></i> เพิ่ม
            </button>
        </div>
    `;
    questionsContainer.insertAdjacentHTML('beforeend', addQuestionButtonHTML);
    
    questionsContainer.querySelectorAll('.auto-resize-textarea').forEach(textarea => {
        textarea.style.overflowY = 'hidden';
        textarea.style.minHeight = '100px'; 
        textarea.rows = 4;
        const resize = () => {
            textarea.style.height = 'auto'; 
            textarea.style.height = (textarea.scrollHeight) + 'px'; 
        };
        textarea.addEventListener('input', resize);
        resize(); 
    });

    questionsContainer.querySelectorAll('.ai-fix-question-btn').forEach(btn => {
        btn.addEventListener('click', handleAiFixQuestion);
    });
    questionsContainer.querySelectorAll('.ai-fix-formula-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
             const index = parseInt(e.currentTarget.closest('.question-editor-item').dataset.qIndex, 10);
             handleAiFixFormula(index);
        });
    });
    
    // === [เพิ่ม] Listener สำหรับปุ่ม Toggle ===
    questionsContainer.querySelectorAll('.toggle-hidden-options-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
             const index = parseInt(e.currentTarget.closest('.question-editor-item').dataset.qIndex, 10);
             handleToggleHiddenOptions(index);
        });
    });
}

function handleToggleHiddenOptions(index) {
    if (!currentEditingQuizData || !currentEditingQuizData.questions[index]) return;
    
    const q = currentEditingQuizData.questions[index];
    const currentType = q.questionType || 'multiple_choice';

    // 1. เก็บข้อมูลปัจจุบันจาก DOM ลงตัวแปร q ก่อน (เพื่อไม่ให้สิ่งที่พิมพ์ล่าสุดหายไป)
    const el = document.querySelector(`.question-editor-item[data-q-index="${index}"]`);
    if (el) {
        q.questionText = el.querySelector('textarea').value;
        
        if (currentType === 'multiple_choice') {
            const optionInputs = el.querySelectorAll('.option-input');
            q.options = Array.from(optionInputs).map(input => input.value);
            const checkedRadio = el.querySelector('input[type="radio"]:checked');
            if (checkedRadio) q.correctAnswerIndex = parseInt(checkedRadio.value);
        } 
        else if (currentType === 'short_answer' || currentType === 'fill_in_no_choices') {
            const idealInput = el.querySelector('.ideal-answer-input');
            if (idealInput) q.idealAnswer = idealInput.value;
            
            const hiddenInputs = el.querySelectorAll('.hidden-option-input');
            if (hiddenInputs.length > 0) {
                q.options = Array.from(hiddenInputs).map(input => input.value);
            }
        }
    }

    // 2. สลับสถานะ
    if (currentType === 'multiple_choice') {
        // แปลงเป็น Short Answer (Hidden Options)
        q.questionType = 'short_answer';
        // ตั้งค่าเฉลยอัตโนมัติ โดยเอา text ของตัวเลือกที่ถูก มาใส่ใน idealAnswer
        if (q.options && q.correctAnswerIndex !== undefined) {
            q.idealAnswer = q.options[q.correctAnswerIndex] || '';
        }
    } else {
        // แปลงกลับเป็น Multiple Choice
        q.questionType = 'multiple_choice';
        // (ข้อมูล options และ correctAnswerIndex ยังคงอยู่เหมือนเดิม)
    }

    // 3. วาดหน้าจอใหม่
    renderQuizEditor(currentEditingQuizData);
}
		
		function handleDeleteQuestionInEditor(index) {
    if (!currentEditingQuizData || !currentEditingQuizData.questions[index]) return;

    // ดึงข้อความคำถามมาแสดงเพื่อยืนยัน
    const questionText = currentEditingQuizData.questions[index].questionText || currentEditingQuizData.questions[index].stem;
    
    showConfirmation(
        `คุณแน่ใจหรือไม่ว่าต้องการลบคำถามข้อ ${index + 1} ("${questionText.substring(0, 20)}...")?`,
        () => {
            // 1. ลบคำถามออกจาก array ใน state ชั่วคราว
            currentEditingQuizData.questions.splice(index, 1);
            
            // 2. วาดหน้าจอ Editor ใหม่ทั้งหมด (คำถามจะหายไป และลำดับข้อจะถูกจัดเรียงใหม่)
            renderQuizEditor(currentEditingQuizData);
            
            showMessage("ลบคำถามแล้ว (อย่าลืมกด 'บันทึกการแก้ไข' เพื่อยืนยัน)");
        }
    );
}

function handleAddQuestionInEditor() {
    if (!currentEditingQuizData) return;

    // 1. อ่านค่าประเภทคำถามจาก Dropdown
    const typeSelect = document.getElementById('new-question-type-select');
    const selectedType = typeSelect ? typeSelect.value : 'multiple_choice';

    // 2. สร้างโครงสร้างข้อมูลเริ่มต้นตามประเภทที่เลือก
    let newQuestion = {
        id: `q_${Date.now()}_new`,
        questionType: selectedType,
        questionText: '--- [คำถามใหม่] ---'
    };

    switch (selectedType) {
        case 'multiple_choice':
            newQuestion.options = ['ตัวเลือก ก', 'ตัวเลือก ข', 'ตัวเลือก ค', 'ตัวเลือก ง'];
            newQuestion.correctAnswerIndex = 0;
            break;
        case 'short_answer':
        case 'fill_in_no_choices':
            newQuestion.idealAnswer = 'คำตอบที่ถูกต้อง';
            break;
        case 'true_false':
            newQuestion.correctAnswer = true;
            break;
        case 'matching_item':
            newQuestion.stem = 'คำถาม...';
            newQuestion.correctResponse = 'คู่คำตอบ...';
            // สำหรับ matching เราอาจต้องใส่ stem ใน questionText เพื่อให้ renderQuizEditor ทำงานถูกในบางจุด
            newQuestion.questionText = 'คำถาม...'; 
            break;
    }

    // 3. เพิ่มคำถามใหม่เข้าไปใน state
    currentEditingQuizData.questions.push(newQuestion);
    
    // 4. วาดหน้าจอ Editor ใหม่
    renderQuizEditor(currentEditingQuizData);
    
    // 5. เลื่อนจอไปที่คำถามใหม่และโฟกัส
    setTimeout(() => {
        const lastQuestionElement = document.querySelector('.question-editor-item:last-of-type');
        if (lastQuestionElement) {
            lastQuestionElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            const textarea = lastQuestionElement.querySelector('textarea');
            if (textarea) textarea.focus();
        }
    }, 100);
}
		
async function handleAiFixQuestion(e) {
    const btn = e.currentTarget;
    const questionItem = btn.closest('.question-editor-item');
    if (!questionItem) return;
    const index = parseInt(questionItem.dataset.qIndex, 10);

    if (isNaN(index) || !currentEditingQuizData.questions[index]) {
        showMessage("เกิดข้อผิดพลาด: ไม่สามารถระบุคำถามที่ต้องการแก้ไขได้");
        return;
    }

    const faultyQuestionData = currentEditingQuizData.questions[index];

    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    btn.disabled = true;

    const prompt = `
        บทบาท: คุณคือผู้เชี่ยวชาญด้านการแก้ไขและทำความสะอาดข้อมูล (Data Cleaning Expert)
        ภารกิจ: ข้อมูล JSON ของคำถามต่อไปนี้มีข้อผิดพลาดปนอยู่ เช่น มีข้อความที่ไม่ใช่ส่วนหนึ่งของคำถาม หรือมีโค้ด LaTeX ที่ผิดพลาด
        
        ข้อมูลที่ผิดพลาด: ${JSON.stringify(faultyQuestionData)}
        
        คำสั่ง: โปรดแก้ไขข้อมูลนี้ให้ถูกต้อง โดยมีเงื่อนไขดังนี้:
        1. ลบข้อความที่ไม่เกี่ยวข้องกับคำถาม ตัวเลือก หรือคำอธิบายออกทั้งหมด
        2. ตรวจสอบและแก้ไข Syntax ของ LaTeX ทั้งหมดให้ถูกต้อง และครอบด้วยเครื่องหมาย $
        3. ห้ามเปลี่ยนแปลงความหมายหรือตัวเลขที่สำคัญของโจทย์เดิม
        4. ตอบกลับมาเป็น JSON object ที่มีโครงสร้างเหมือนเดิมทุกประการ
    `;

    let schema;
    const questionType = faultyQuestionData.questionType || currentEditingQuizData.quizType;
    switch (questionType) {
        case 'short_answer':
            schema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, idealAnswer: { type: "STRING" },  imageCode: { type: "STRING" } }, required: ["questionText", "idealAnswer"] };
            break;
        case 'multiple_choice':
        default:
            schema = { type: "OBJECT", properties: { questionText: { type: "STRING" }, options: { type: "ARRAY", items: { type: "STRING" } }, correctAnswerIndex: { type: "NUMBER" },  imageCode: { type: "STRING" } }, required: ["questionText", "options", "correctAnswerIndex"] };
            break;
    }

    try {
        let correctedData = await callAnalysisApi(prompt, schema);

        // (Safety Net) บังคับแก้ไข S -> $
        if (correctedData.options && Array.isArray(correctedData.options)) {
            correctedData.options = correctedData.options.map(opt =>
                typeof opt === 'string' ? opt.replace(/S(\s*[\d_]+?\s*)S/g, '$$$1$') : opt
            );
        }

        // --- [ ส่วนแก้ไขที่สำคัญที่สุด ] ---
        // **บังคับลบข้อความแปลกๆ ที่มาจาก imageCode โดยตรง**
        // เป็นการแก้ปัญหาที่ต้นตอ กรณีที่ AI ไม่ยอมลบให้
        if (faultyQuestionData.imageCode && faultyQuestionData.imageCode.includes('fix the option')) {
            correctedData.imageCode = ''; // สั่งล้างค่าในช่องรูปภาพให้ว่างเปล่า
        }
        // --- [ สิ้นสุดส่วนแก้ไข ] ---

        currentEditingQuizData.questions[index] = { ...faultyQuestionData, ...correctedData };
        
        renderQuizEditor(currentEditingQuizData);
        showMessage("AI แก้ไขคำถามสำเร็จ!");

    } catch (error) {
        console.error("AI Fix Error:", error);
        showMessage("AI ไม่สามารถแก้ไขคำถามได้ โปรดลองสร้างใหม่แทน");
        renderQuizEditor(currentEditingQuizData);
    }
}

        async function handleSaveChanges() {
    const saveBtn = document.getElementById('save-quiz-edits-btn');
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>กำลังบันทึก...';

    try {
        const newTopic = document.getElementById('editor-quiz-topic').value;
        const questionElements = document.querySelectorAll('.question-editor-item');
        let allCorrectResponsesForMatching = [];
        
        const newQuestions = Array.from(questionElements).map((el, index) => {
            const questionType = el.dataset.qType;
            const questionTextWithBreaks = el.querySelector('textarea').value.replace(/\n/g, '<br>');
            let newQuestionData = { questionType: questionType };
            
            const originalQuestion = currentEditingQuizData.questions[index] || {};

            switch (questionType) {
                case 'multiple_choice':
                    newQuestionData.questionText = questionTextWithBreaks;
                    const optionInputs = el.querySelectorAll('.option-input'); // ใช้ class แทน
                    newQuestionData.options = Array.from(optionInputs).map(input => input.value);
                    const checkedRadioMCQ = el.querySelector('input[type="radio"]:checked');
                    newQuestionData.correctAnswerIndex = checkedRadioMCQ ? parseInt(checkedRadioMCQ.value) : 0;
                    break;
                
                case 'fill_in_no_choices':
                case 'short_answer':
                    newQuestionData.questionText = questionTextWithBreaks;
                    newQuestionData.idealAnswer = el.querySelector('.ideal-answer-input').value;
                    
                    // === [เพิ่ม] บันทึกตัวเลือกที่ซ่อนอยู่ (ถ้ามี) ===
                    const hiddenOptionInputs = el.querySelectorAll('.hidden-option-input');
                    if (hiddenOptionInputs.length > 0) {
                        newQuestionData.options = Array.from(hiddenOptionInputs).map(input => input.value);
                        // เราจะรักษา correctAnswerIndex เดิมไว้ (ถ้ามี) หรือถ้าไม่มีก็ default 0
                        // แต่ในโหมดเติมคำ index นี้ไม่ได้ใช้ในการตรวจคำตอบ ใช้แค่ตอนกด Reveal ในเกม
                        if (originalQuestion.correctAnswerIndex !== undefined) {
                            newQuestionData.correctAnswerIndex = originalQuestion.correctAnswerIndex;
                        } else {
                             newQuestionData.correctAnswerIndex = 0;
                        }
                    } else {
                        // ถ้าไม่มี hidden inputs ให้ลบ options ออก (เผื่อกรณีเคยมีแต่ลบออก)
                        delete newQuestionData.options;
                        delete newQuestionData.correctAnswerIndex;
                    }
                    // ==========================================
                    break;
                
                case 'true_false':
                    newQuestionData.questionText = questionTextWithBreaks;
                    const checkedRadioTF = el.querySelector('input[type="radio"]:checked');
                    newQuestionData.correctAnswer = checkedRadioTF ? checkedRadioTF.value === 'true' : true;
                    break;
                case 'matching_item':
                    newQuestionData.stem = questionTextWithBreaks;
                    const correctResponseInput = el.querySelector('.correct-response-input');
                    newQuestionData.correctResponse = correctResponseInput ? correctResponseInput.value : '';
                    allCorrectResponsesForMatching.push(newQuestionData.correctResponse);
                    break;
                default:
                    newQuestionData.questionText = questionTextWithBreaks;
                    break;
            }
            return { ...originalQuestion, ...newQuestionData };
        });

        if (allCorrectResponsesForMatching.length > 0) {
            newQuestions.forEach(q => {
                if (q.questionType === 'matching_item') {
                    q.allResponses = allCorrectResponsesForMatching;
                }
            });
        }
        
        // 1. บันทึกการแก้ไขลง Firestore
        const quizId = currentEditingQuizData.id;
        const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
        await updateDoc(quizRef, {
            topic: newTopic,
            questions: newQuestions
        });
        
        document.getElementById('quiz-editor-modal').classList.add('hidden');
        
        // 2. เริ่มกระบวนการตรวจคะแนนใหม่
        showMessage(
            "บันทึกการแก้ไขสำเร็จ! ระบบกำลังเริ่มตรวจคะแนนของผู้ส่งเดิมใหม่ทั้งหมดโดยอัตโนมัติ...",
            () => initiateReGradeProcess(quizId)
        );
        
    } catch (error) {
        console.error("Error saving quiz edits:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึก");
    } finally {
        saveBtn.disabled = false;
        saveBtn.innerHTML = '<i class="fas fa-save"></i> บันทึกการแก้ไข';
    }
}

async function initiateReGradeProcess(quizId) {
    showMessage("กำลังเริ่มกระบวนการตรวจคะแนนใหม่... กรุณารอสักครู่");

    try {
        // 1. ดึงข้อมูลข้อสอบเวอร์ชันล่าสุด (ที่มีเฉลยใหม่)
        const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
        const quizSnap = await getDoc(quizRef);
        if (!quizSnap.exists()) throw new Error("ไม่พบข้อมูลแบบทดสอบ");
        const newQuizData = { id: quizId, ...quizSnap.data() };

        // 2. ดึงข้อมูลการส่งงาน (submission) ของนักเรียนทุกคนในข้อสอบนี้
        const submissionsRef = collection(db, `artifacts/${appId}/public/data/quizzes`, quizId, "submissions");
        const submissionsSnap = await getDocs(submissionsRef);
        if (submissionsSnap.empty) {
            showMessage("ไม่มีข้อมูลการส่งงานเก่าให้ตรวจใหม่");
            return;
        }

        // 3. สร้าง Promise สำหรับการตรวจคะแนนใหม่ของนักเรียนแต่ละคน
        const reGradePromises = submissionsSnap.docs.map(submissionDoc => 
            reGradeSingleSubmission(submissionDoc, newQuizData)
        );

        // 4. รอให้กระบวนการตรวจใหม่ของทุกคนเสร็จสิ้น
        await Promise.all(reGradePromises);

        // 5. หลังจากตรวจใหม่ครบทุกคนแล้ว ให้อัปเดตตารางผู้นำของโปรเจค
        // (จำเป็นต้องมี projectId ในข้อมูลข้อสอบ)
        if (newQuizData.projectId) {
            const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, newQuizData.projectId);
            const projectSnap = await getDoc(projectRef);
            if (projectSnap.exists() && projectSnap.data().students) {
                const studentUpdatePromises = projectSnap.data().students.map(studentName => 
                    updateStudentProfile(newQuizData.projectId, studentName)
                );
                await Promise.all(studentUpdatePromises);
            }
        }
        
        showMessage(`ตรวจคะแนนใหม่ ${submissionsSnap.size} รายการสำเร็จ! คะแนนและสถิติทั้งหมดได้รับการอัปเดตแล้ว`);

    } catch (error) {
        console.error("Re-grade process failed:", error);
        showMessage(`เกิดข้อผิดพลาดในการตรวจคะแนนใหม่: ${error.message}`);
    }
}

async function reGradeSingleSubmission(submissionDoc, newQuizData) {
    const submissionData = submissionDoc.data();
    const studentName = submissionData.studentName;
    const oldAttempts = submissionData.attempts || [];
    const newAttempts = [];

    // ดึง Type Scoring จาก Quiz Data
    const typeScoring = newQuizData.settings?.typeScoring || { mcq: 1, sa: 1, tf: 1 };

    for (const attempt of oldAttempts) {
        let newRawScore = 0;
        let newEarnedBadges = []; 
        let correctStreak = 0;
        const newDetailedAnswers = [];
        
        // คำนวณคะแนนเต็มของรอบนี้ (Sum of Weights)
        let attemptMaxScore = 0;

        for (const ans of attempt.answers) {
            let newQuestion;
            if (ans.questionId) {
                newQuestion = newQuizData.questions.find(q => q.id === ans.questionId);
            }
            if (!newQuestion && ans.originalQuestionText) {
                newQuestion = newQuizData.questions.find(q => (q.stem || q.questionText) === ans.originalQuestionText);
            }

            let isCorrect = false;
            let weight = 1;

            if (newQuestion) {
                const questionType = newQuestion.questionType || newQuizData.quizType;
                
                // หาน้ำหนัก
                if (questionType === 'short_answer' || questionType === 'fill_in_no_choices') weight = parseFloat(typeScoring.sa) || 1;
                else if (questionType === 'true_false') weight = parseFloat(typeScoring.tf) || 1;
                else weight = parseFloat(typeScoring.mcq) || 1;

                switch (questionType) {
                    case 'multiple_choice':
                        if (newQuestion.options && newQuestion.correctAnswerIndex < newQuestion.options.length) {
                            const correctAnswerText = newQuestion.options[newQuestion.correctAnswerIndex];
                            isCorrect = (ans.answerText === correctAnswerText);
                        }
                        break;
                    case 'true_false':
                        const studentAnswerBool = (ans.answer === true || ans.answer === 'true');
                        isCorrect = (studentAnswerBool === newQuestion.correctAnswer);
                        break;
                    case 'matching_item':
                        isCorrect = (ans.answer === newQuestion.correctResponse);
                        break;
                    case 'short_answer':
                        isCorrect = await gradeShortAnswer(ans.answer, newQuestion);
                        break;
                    default:
                        isCorrect = ans.isCorrect;
                        break;
                }
            }

            attemptMaxScore += weight;

            if (isCorrect) {
                newRawScore += weight; // บวกคะแนนตามน้ำหนัก
                correctStreak++;
                if (correctStreak === 3) newEarnedBadges.push(BADGES.ON_FIRE.id);
            } else {
                correctStreak = 0;
            }
            newDetailedAnswers.push({ ...ans, isCorrect: isCorrect }); 
        }

        let newPoints = 0;
        const isPreservedScore = attempt.isSyncGame === true || (attempt.points > (newQuizData.questions.length * 20));

        if (isPreservedScore) {
            newPoints = attempt.points;
        } else {
            // คำนวณ Point ใหม่แบบพื้นฐาน (ยังไม่รวม Confidence เพราะข้อมูลเก่าอาจไม่มี)
            // สมมติว่าข้อมูลเก่าเป็นแบบ Normal Mode: ถูกได้ Weight Point
            newPoints = newRawScore; 
            
            // Badge คะแนนเต็ม (เช็คจากคะแนนดิบ vs คะแนนเต็มรวม)
            if (newRawScore === attemptMaxScore && attemptMaxScore > 0) {
                // newPoints += 50; // ตัดโบนัส +50 ออกตาม Requirement ที่ต้องการให้ Point สะท้อนคะแนนจริง
                newEarnedBadges.push(BADGES.PERFECT_SCORE.id);
            }
        }
        
        newAttempts.push({ 
            ...attempt, 
            score: newRawScore, 
            points: newPoints, 
            badges: Array.from(new Set(newEarnedBadges)),
            answers: newDetailedAnswers 
        });
    }

    const newFirstScore = newAttempts.length > 0 ? newAttempts[0].score : 0;
    const newBestScore = Math.max(...newAttempts.map(a => a.score));
    const newLatestScore = newAttempts.length > 0 ? newAttempts[newAttempts.length - 1].score : 0;
    const newLatestPoints = newAttempts.length > 0 ? newAttempts[newAttempts.length - 1].points : 0;
    
    // คำนวณคะแนนเต็มรวมของข้อสอบชุดปัจจุบัน (เพื่ออัปเดต totalQuestions)
    let currentQuizMaxScore = 0;
    newQuizData.questions.forEach(q => {
        const qt = q.questionType || newQuizData.quizType;
        if (qt === 'short_answer' || qt === 'fill_in_no_choices') currentQuizMaxScore += (parseFloat(typeScoring.sa) || 1);
        else if (qt === 'true_false') currentQuizMaxScore += (parseFloat(typeScoring.tf) || 1);
        else currentQuizMaxScore += (parseFloat(typeScoring.mcq) || 1);
    });

    const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${newQuizData.id}/submissions`, studentName);
    await updateDoc(submissionRef, {
        attempts: newAttempts,
        firstScore: newFirstScore,
        bestScore: newBestScore,
        latestScore: newLatestScore,
        points: newLatestPoints,
        totalQuestions: currentQuizMaxScore // อัปเดตตัวหารให้เป็นคะแนนเต็มรวม
    });
}

        function cleanupQuizOptions(quizData) {
            // ฟังก์ชันสำหรับหา ห.ร.ม. (GCD) เพื่อใช้ลดทอนเศษส่วน
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);

            // ฟังก์ชันสำหรับแปลงสตริงเศษส่วน (เช่น "3 1/2") เป็นค่าตัวเลข (3.5)
            const parseFraction = (str) => {
                if (typeof str !== 'string') return null;
                str = str.trim();
                const parts = str.split(/[ /]/).filter(p => p !== ''); // รองรับทั้ง "3 1/2" และ "3/2"
                
                if (parts.length === 3) { // จำนวนคละ "3 1/2"
                    return parseInt(parts[0]) + (parseInt(parts[1]) / parseInt(parts[2]));
                } else if (parts.length === 2) { // เศษเกิน "7/2"
                    return parseInt(parts[0]) / parseInt(parts[1]);
                } else if (parts.length === 1 && !isNaN(parts[0])) { // จำนวนเต็ม
                    return parseFloat(parts[0]);
                }
                return null; // รูปแบบที่ไม่รู้จัก
            };

            // ฟังก์ชันสำหรับลดทอนและจัดรูปแบบเศษส่วนใหม่
            const simplifyAndFormat = (str) => {
                if (typeof str !== 'string') return str;
                const match = str.match(/(\d+)\s+(\d+)\/(\d+)/); // ตรวจจับรูปแบบจำนวนคละ "3 1/2"
                if (match) {
                    const whole = parseInt(match[1]);
                    let num = parseInt(match[2]);
                    let den = parseInt(match[3]);
                    const common = gcd(num, den);
                    num /= common;
                    den /= common;
                    if (den === 1) return (whole + num).toString(); // ถ้าเป็น 3 2/2 ให้เป็น 4
                    return `${whole} ${num}/${den}`;
                }
                return str; // คืนค่าเดิมถ้าไม่ใช่จำนวนคละ
            };

            if (quizData && quizData.questions) {
                quizData.questions.forEach(q => {
                    // ทำงานเฉพาะกับคำถามแบบปรนัย (multiple_choice)
                    if (q.questionType === 'multiple_choice' && q.options) {
                        const uniqueOptions = new Map();
                        const originalCorrectOptionText = q.options[q.correctAnswerIndex];

                        q.options.forEach(opt => {
                            const simplifiedOpt = simplifyAndFormat(opt);
                            const numericValue = parseFraction(simplifiedOpt);
                            
                            // ใช้ค่าตัวเลขเป็น key เพื่อตรวจสอบความซ้ำซ้อน
                            // ถ้ายังไม่มี key นี้ ให้เพิ่มเข้าไปใน Map
                            if (numericValue !== null && !uniqueOptions.has(numericValue)) {
                                uniqueOptions.set(numericValue, simplifiedOpt);
                            }
                        });

                        // สร้าง Array ของตัวเลือกใหม่จากค่าที่ไม่ซ้ำกัน
                        q.options = Array.from(uniqueOptions.values());

                        // ค้นหา Index ใหม่ของคำตอบที่ถูกต้อง
                        const newCorrectIndex = q.options.findIndex(opt => opt === simplifyAndFormat(originalCorrectOptionText));
                        q.correctAnswerIndex = newCorrectIndex !== -1 ? newCorrectIndex : 0;
                    }
                });
            }
            return quizData;
        }

function showGameStartConfirmationModal(quizId, mode, topic) {
    const quiz = allQuizzes.find(q => q.id === quizId) || allQuizzesGlobal.find(q => q.id === quizId);
    const topicText = quiz ? quiz.topic : (topic || 'แบบทดสอบ');

    actionTargetId = quizId;
    
    const confirmBtn = document.getElementById('confirm-game-start-btn');
    document.getElementById('game-start-quiz-id').value = quizId;
    document.getElementById('game-start-mode').value = mode;

    document.getElementById('game-start-modal-title').innerText = `เริ่มกิจกรรม: ${topicText}`;

    // --- จัดการการแสดงผล UI ตามโหมด ---
    const syncVariantSelector = document.getElementById('sync-variant-selector');
    const syncBlackMarketSettings = document.getElementById('black-market-settings-container'); 
    
    // (ลบตัวแปร onetModeContainer ออก)
    
    const timerCheckbox = document.getElementById('sync-timer-enable-checkbox');
    const syncTimerSettings = timerCheckbox ? timerCheckbox.closest('div.border-t') : null;

    if (mode === 'sync') {
        // โหมด Sync: แสดงตัวเลือกโหมดเกม, เวลา, ตลาดมืด
        if (syncVariantSelector) syncVariantSelector.classList.remove('hidden');
        if (syncTimerSettings) syncTimerSettings.classList.remove('hidden');
        if (syncBlackMarketSettings) syncBlackMarketSettings.classList.remove('hidden');
        
        // (ลบบรรทัดที่สั่ง onetModeContainer.classList.remove('hidden') ออก)

    } else {
        // โหมดอื่นๆ: ซ่อนตัวเลือกของ Sync ให้หมด
        if (syncVariantSelector) syncVariantSelector.classList.add('hidden');
        if (syncTimerSettings) syncTimerSettings.classList.add('hidden');
        if (syncBlackMarketSettings) syncBlackMarketSettings.classList.add('hidden');
        
        // (ลบบรรทัดที่สั่ง onetModeContainer.classList.add('hidden') ออก)
    }

    // (ลบส่วนรีเซ็ตค่า onetCheckbox ออก)

    // แสดง Modal
    document.getElementById('confirm-game-start-modal').classList.remove('hidden');
}

async function saveGameResultsAsSubmissions(finalGameData) {
    if (finalGameData.resultsSaved) {
        console.log("Game results already saved. Skipping.");
        return;
    }

    console.log("Saving game results (Weighted Score)...", finalGameData);
    const quizId = finalGameData.quizId;
    let playersData = [];

    if (finalGameData.players) { 
        playersData = Object.entries(finalGameData.players).map(([name, data]) => ({ name, ...data }));
    } else if (finalGameData.groups) { 
        Object.values(finalGameData.groups).forEach(group => {
            group.members.forEach(memberName => {
                playersData.push({ name: memberName, score: group.score, answers: group.answers });
            });
        });
    }

    if (playersData.length === 0) return;

    const quizData = finalGameData.shuffledQuiz || currentQuizData;
    
    // 1. คำนวณคะแนนเต็มรวม (Total Weighted Score)
    let totalMaxScore = 0;
    quizData.questions.forEach(q => {
        const w = getQuestionWeight(quizData, q.questionType || quizData.quizType);
        totalMaxScore += w;
    });

    const batch = writeBatch(db);
    const projectId = quizData.projectId || currentProjectId;
    const profileUpdates = {};

    for (const player of playersData) {
        const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`, player.name);
        
        // 2. คำนวณคะแนนดิบตามน้ำหนัก (Weighted Raw Score)
        let rawScoreWeighted = 0;
        const answersList = player.answers || [];
        
        answersList.forEach(ans => {
            if (ans.isCorrect) {
                // หาคำถามเพื่อดูน้ำหนัก
                const q = quizData.questions[ans.questionIndex];
                if (q) {
                    const w = getQuestionWeight(quizData, q.questionType || quizData.quizType);
                    rawScoreWeighted += w;
                } else {
                    rawScoreWeighted += 1; // Fallback
                }
            }
        });

        // 3. ใช้ Points ที่เล่นได้จริงในเกม (รวม Wager แล้ว)
        let finalPoints = (player.totalPoints !== undefined) ? player.totalPoints : rawScoreWeighted;

        let earnedBadges = player.badges || [];
        // เช็คคะแนนเต็มจากคะแนนดิบที่มีน้ำหนักแล้ว เทียบกับคะแนนเต็มรวม
        if (rawScoreWeighted === totalMaxScore && totalMaxScore > 0) {
            if (!earnedBadges.includes('perfect_score')) earnedBadges.push('perfect_score');
        }

        const gameAttempt = {
            score: rawScoreWeighted, // บันทึกเป็นคะแนนที่มีน้ำหนักแล้ว
            points: finalPoints,     // บันทึก Points ที่เล่นได้จริงในเกม
            badges: earnedBadges,
            submittedAt: new Date().toISOString(),
            isSyncGame: true,
            answers: answersList.map(ans => ({
                questionId: ans.questionId,
                answer: ans.answer,
                answerText: ans.answerText,
                isCorrect: ans.isCorrect,
                originalQuestionText: ans.originalQuestionText,
                wasConfident: ans.wasConfident,
                powerupUsed: ans.powerupUsed || null 
            }))
        };
        
        const submissionDoc = await getDoc(submissionRef);
        const existingData = submissionDoc.exists() ? submissionDoc.data() : {};
        
        const oldBestPoints = existingData.points || 0;
        let pointsToAdd = 0;
        if (finalPoints > oldBestPoints) {
            pointsToAdd = finalPoints - oldBestPoints;
        }

        const submissionData = {
            studentName: player.name,
            totalQuestions: totalMaxScore, // ใช้คะแนนเต็มรวมเป็นตัวหาร
            attempts: arrayUnion(gameAttempt),
            latestScore: rawScoreWeighted,
            points: Math.max(oldBestPoints, finalPoints),
            latestSubmittedAt: gameAttempt.submittedAt,
            bestScore: Math.max((existingData.bestScore || 0), rawScoreWeighted),
            firstScore: existingData.firstScore !== undefined ? existingData.firstScore : rawScoreWeighted
        };

        batch.set(submissionRef, submissionData, { merge: true });

        if (projectId) {
            if (!profileUpdates[player.name]) {
                profileUpdates[player.name] = { pointsToAdd: 0, badgesToAdd: [] };
            }
            profileUpdates[player.name].pointsToAdd += pointsToAdd;
            earnedBadges.forEach(b => {
                profileUpdates[player.name].badgesToAdd.push(b);
            });
        }
    }

    if (projectId) {
        for (const [studentName, updateData] of Object.entries(profileUpdates)) {
            if (updateData.pointsToAdd > 0 || updateData.badgesToAdd.length > 0) {
                const profileRef = doc(db, `artifacts/${appId}/public/data/projects/${projectId}/studentProfiles`, studentName);
                const updatePayload = {
                    studentName: studentName,
                    totalPoints: increment(updateData.pointsToAdd)
                };
                updateData.badgesToAdd.forEach(badgeId => {
                    updatePayload[`badgesCount.${badgeId}`] = increment(1);
                });
                batch.set(profileRef, updatePayload, { merge: true });
            }
        }
    }

    try {
        if (currentLiveGameId) {
            const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
            batch.update(gameRef, { resultsSaved: true });
        }

        await batch.commit();
        console.log("Save complete (Weighted Scores)");
        showMessage(`บันทึกผลการเรียนเรียบร้อยแล้ว!`);
        
    } catch (error) {
        console.error("Error saving game results:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึกผลคะแนน");
    }
}

// ▼▼▼ วางทับฟังก์ชัน saveQuiz เดิมทั้งหมด ▼▼▼
async function saveQuiz(forcedProjectId = null, blueprintTopicId = null) {
    const projectIdToUse = forcedProjectId || currentProjectId;

    if (!projectIdToUse) {
        promptForProjectAndSave();
        return;
    }
    
    if (!currentQuizData || !currentQuizData.questions || !userId) {
        showMessage("ข้อมูลไม่ครบถ้วน ไม่สามารถบันทึกได้");
        return;
    }
    const saveButton = document.getElementById('save-quiz-btn');
    saveButton.disabled = true;
    saveButton.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>กำลังบันทึก...';

    const isPreTest = document.getElementById('pre-test-checkbox').checked;
    let finalTopic = document.getElementById('editable-quiz-topic').innerText.trim();

    if (isPreTest && !finalTopic.startsWith('(ก่อนเรียน)')) {
        finalTopic = `(ก่อนเรียน) ${finalTopic}`;
    }

    try {
        const newQuizSettings = {
            resultsDisplay: document.getElementById('results-display-select').value,
            shuffle: document.getElementById('shuffle-setting-select').value,
            timerMode: document.getElementById('timer-mode-select').value,
            timerDuration: parseInt(document.getElementById('timer-duration-input').value) || 10,
            passingScore: parseInt(document.getElementById('passing-score-input').value) || 0,
            isAdaptive: document.getElementById('adaptive-quiz-checkbox').checked,
            loopUntilPass: document.getElementById('loop-until-pass-checkbox').checked
        };

        // --- ⭐ จุดแก้ไขสำคัญ ⭐ ---
        // ใช้ค่า quizType จากข้อมูลที่สร้างมา (ถ้ามี) ถ้าไม่มีค่อยไปดึงจาก UI
        // (เพราะ UI ในหน้า Blueprint อาจจะไม่ได้แสดง Dropdown นี้ หรือค่าไม่ตรง)
        const determinedQuizType = currentQuizData.quizType || document.getElementById('quiz-type-select').value;

        const cleanQuestions = (currentQuizData.questions || []).map((q, index) => {
            const cleanQ = {
                id: `q_${Date.now()}_${index}`,
                questionText: q.questionText || "",
                // ใช้ค่าที่หามาได้ ไม่ใช่ค่าจาก Dropdown เสมอไป
                questionType: q.questionType || determinedQuizType, 
                imageCode: q.imageCode || null,
            };
            
            // Logic การเก็บข้อมูลตามประเภทคำถาม
            if (cleanQ.questionType === 'multiple_choice' || cleanQ.questionType === 'fill_in_with_choices' || (cleanQ.questionType === 'mixed' && q.options)) {
                cleanQ.options = q.options || [];
                cleanQ.correctAnswerIndex = q.correctAnswerIndex !== undefined ? q.correctAnswerIndex : 0;
            }
            if (cleanQ.questionType === 'short_answer' || cleanQ.questionType === 'fill_in_no_choices' || (cleanQ.questionType === 'mixed' && q.idealAnswer)) {
                cleanQ.idealAnswer = q.idealAnswer || "";
            }
            if (cleanQ.questionType === 'true_false') {
                cleanQ.correctAnswer = q.correctAnswer === true;
            }
            if (cleanQ.questionType === 'matching_item') {
                cleanQ.stem = q.stem || "";
                cleanQ.correctResponse = q.correctResponse || "";
                cleanQ.allResponses = q.allResponses || [];
            }
            return cleanQ;
        });

        const dataToSave = {
            topic: finalTopic,
            quizType: determinedQuizType, // บันทึกประเภทที่ถูกต้อง
            questions: cleanQuestions,
            projectId: projectIdToUse,
            createdBy: userId,
            createdAt: new Date().toISOString(),
            status: 'active',
            settings: newQuizSettings,
            quizMode: isPreTest ? 'pre-test' : 'standard',
            pairedQuizId: null,
            lessonPlan: null
        };

        let newQuizId;
        while (true) {
            newQuizId = Math.floor(1000 + Math.random() * 9000).toString();
            const existing = await getDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId));
            if (!existing.exists()) break;
        }
        await setDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId), dataToSave);

        // Logic สำหรับ Auto-linking (Blueprint)
        if (blueprintTopicId && currentBlueprintProjectId) {
            try {
                const blueprintProjectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, currentBlueprintProjectId);
                await updateDoc(blueprintProjectRef, {
                    [`topics.${blueprintTopicId}.linkedQuizIds`]: arrayUnion(newQuizId)
                });
            } catch (linkError) {
                console.error("Failed to auto-link quiz:", linkError);
            }
        }

        currentQuizData.settings = newQuizSettings;
        currentQuizData.id = newQuizId;

        // แสดงผลสำเร็จ
        const actionsContainer = document.getElementById('generated-quiz-actions');
        actionsContainer.innerHTML = `
            <div class="p-4 bg-green-100 text-green-800 rounded-lg text-center">
                <p class="font-semibold">สร้างแบบทดสอบสำเร็จ!</p>
                <p>รหัสสำหรับทำแบบทดสอบ: <strong id="quiz-id" class="text-lg select-all">${newQuizId}</strong></p>
                <button id="copy-quiz-id-btn" class="mt-2 bg-green-600 text-white py-1 px-3 rounded-md hover:bg-green-700 text-sm"><i class="fas fa-copy"></i> คัดลอก</button>
            </div>
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-3 mt-4">
                <button id="start-live-race-generated-btn" class="w-full bg-orange-500 text-white py-3 px-4 rounded-lg font-semibold hover:bg-orange-600 flex items-center justify-center"><i class="fas fa-flag-checkered mr-2"></i>แข่งขันสด</button>
                <button id="start-presentation-btn" class="w-full bg-purple-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-purple-700 flex items-center justify-center"><i class="fas fa-chalkboard-teacher mr-2"></i>เริ่มโหมดนำเสนอ</button>
                <button id="admin-try-quiz-btn" class="w-full bg-teal-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-teal-700 flex items-center justify-center"><i class="fas fa-vial mr-2"></i>ทดลองทำข้อสอบ</button>
            </div>`;
        document.getElementById('copy-quiz-id-btn').addEventListener('click', () => copyTextToClipboard(newQuizId, "คัดลอกรหัสแล้ว!"));
        document.getElementById('start-live-race-generated-btn').addEventListener('click', () => handleStartLiveRace(newQuizId));
        document.getElementById('start-presentation-btn').addEventListener('click', () => startPresentation(currentQuizData));
        document.getElementById('admin-try-quiz-btn').addEventListener('click', startAdminTest);
        showMessage("บันทึกแบบทดสอบสำเร็จแล้ว!");

    } catch (error) {
        console.error("Error saving quiz:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึกแบบทดสอบ");
    } finally {
        saveButton.disabled = false;
        saveButton.innerHTML = '<i class="fas fa-save mr-2"></i>บันทึกและสร้างรหัส';
    }
}

function promptForProjectAndSave() {
    const moveQuizModal = document.getElementById('move-quiz-modal');
    const projectSelect = document.getElementById('move-quiz-project-select');
    const modalTitle = moveQuizModal.querySelector('h3');
    const confirmBtn = document.getElementById('confirm-move-quiz-btn');

    // 1. เปลี่ยนข้อความใน Modal ให้เหมาะสม
    modalTitle.textContent = 'เลือกโปรเจคเพื่อบันทึก';
    confirmBtn.textContent = 'เลือกและบันทึก';

    // 2. แสดงรายการโปรเจคทั้งหมดที่มี
    if (allProjects.length === 0) {
        projectSelect.innerHTML = '<option value="">คุณยังไม่มีโปรเจค</option>';
        confirmBtn.disabled = true;
    } else {
        projectSelect.innerHTML = allProjects
            .map(p => `<option value="${p.id}">${p.projectName}</option>`)
            .join('');
        confirmBtn.disabled = false;
    }
    
    // 3. แสดง Modal
    moveQuizModal.classList.remove('hidden');

    // 4. จัดการเมื่อผู้ใช้กดปุ่ม "เลือกและบันทึก"
    const newConfirmHandler = () => {
        const selectedProjectId = projectSelect.value;
        if (selectedProjectId) {
            currentProjectId = selectedProjectId; // **ตั้งค่าโปรเจคที่เลือก**
            moveQuizModal.classList.add('hidden'); // ซ่อน Modal
            
            // เรียกฟังก์ชัน saveQuiz อีกครั้ง ซึ่งครั้งนี้ currentProjectId จะไม่เป็นค่าว่างแล้ว
            saveQuiz(); 
            
            // คืนค่าข้อความและ Event Listener ของ Modal ให้เป็นเหมือนเดิม
            modalTitle.textContent = 'ย้ายแบบทดสอบไปโปรเจคอื่น';
            confirmBtn.textContent = 'ย้าย';
            confirmBtn.removeEventListener('click', newConfirmHandler);
            confirmBtn.addEventListener('click', confirmMoveQuiz);
        } else {
            showMessage("กรุณาเลือกโปรเจคที่ต้องการบันทึก");
        }
    };

    // ลบ Event Listener เก่าออกชั่วคราว แล้วใส่ตัวใหม่เข้าไป
    confirmBtn.removeEventListener('click', confirmMoveQuiz);
    confirmBtn.addEventListener('click', newConfirmHandler);
}
        
        function copyTextToClipboard(text, successMessage) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.opacity = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                showMessage(successful ? successMessage : "คัดลอกไม่สำเร็จ");
            } catch (err) {
                showMessage("คัดลอกไม่สำเร็จ");
                console.error('Copy command failed', err);
            }
            document.body.removeChild(textArea);
        }

        // --- Admin Results View ---
        function listenForProjectQuizzes(projectId) {
            const quizzesRef = collection(db, `artifacts/${appId}/public/data/quizzes`);
            const q = query(quizzesRef, where("projectId", "==", projectId));
            
            unsubscribeQuizzesListener = onSnapshot(q, async (snapshot) => {
                allQuizzes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderQuizzes();
            }, (error) => {
                console.error("Error fetching project quizzes:", error);
                document.getElementById('project-quizzes-list').innerHTML = '<p class="text-red-500">เกิดข้อผิดพลาดในการโหลดแบบทดสอบ</p>';
            });
        }
        
async function renderQuizzes() {
    const quizzesListContainer = document.getElementById('project-quizzes-list');
    const searchTerm = document.getElementById('quiz-search-input').value.toLowerCase();

    let quizzesToRender;
    if (currentProjectId === 'starred') {
        quizzesToRender = starredQuizzes;
    } else {
        quizzesToRender = allQuizzes;
    }
    
    let filteredQuizzes = quizzesToRender.filter(q => q.topic.toLowerCase().includes(searchTerm));
    filteredQuizzes.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    if (filteredQuizzes.length === 0) {
        quizzesListContainer.innerHTML = '<p class="text-gray-500">ไม่พบแบบทดสอบที่ตรงกัน</p>';
        return;
    }
    
    // ▼▼▼ [แก้ไข] ใช้วิธีนับแบบประหยัด (Aggregation Query) ▼▼▼
    const submissionCounts = {};
    const submissionPromises = filteredQuizzes.map(async (quiz) => {
        const submissionsCol = collection(db, `artifacts/${appId}/public/data/quizzes/${quiz.id}/submissions`);
        // เปลี่ยนจาก getDocs เป็น getCountFromServer
        const submissionSnapshot = await getCountFromServer(submissionsCol);
        submissionCounts[quiz.id] = submissionSnapshot.data().count;
    });
    await Promise.all(submissionPromises);
    // ▲▲▲ [สิ้นสุดส่วนแก้ไข] ▲▲▲

    let html = '';
    filteredQuizzes.forEach(quiz => {
        const submissionCount = submissionCounts[quiz.id] || 0;
        const status = quiz.status || 'active';
        const timerMode = quiz.settings?.timerMode || 'none';
        let statusText = '';
        let statusColor = '';
        const now = new Date();
        let effectiveStatus = status;

        if (status === 'scheduled') {
            const startTime = quiz.startTime ? new Date(quiz.startTime) : null;
            const endTime = quiz.endTime ? new Date(quiz.endTime) : null;
            if (endTime && now > endTime) {
                effectiveStatus = 'inactive';
            } else if (startTime && now < startTime) {
                effectiveStatus = 'scheduled_pending';
            } else {
                effectiveStatus = 'active';
            }
        }

        switch (effectiveStatus) {
            case 'inactive': statusText = 'ปิดใช้งาน'; statusColor = 'text-red-700 bg-red-100'; break;
            case 'scheduled_pending': statusText = 'รอเปิด'; statusColor = 'text-blue-700 bg-blue-100'; break;
            case 'active': statusText = timerMode !== 'none' ? 'เปิด (จับเวลา)' : 'เปิดใช้งาน'; statusColor = 'text-green-700 bg-green-100'; break;
            default: statusText = 'ตั้งเวลา (เปิด)'; statusColor = 'text-green-700 bg-green-100'; break;
        }

        let scheduleInfo = '';
        const timeFormatOptions = { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: false };
        if (status === 'scheduled') {
            if (quiz.startTime) scheduleInfo += `<p class="text-xs text-gray-500 mt-1">เปิด: ${new Date(quiz.startTime).toLocaleString('th-TH', timeFormatOptions)}</p>`;
            if (quiz.endTime) scheduleInfo += `<p class="text-xs text-gray-500 mt-1">ปิด: ${new Date(quiz.endTime).toLocaleString('th-TH', timeFormatOptions)}</p>`;
        }
        
        let actionButtonsHtml = '';
        if (quiz.pairedQuizId) {
            const pairedQuiz = allQuizzes.find(q => q.id === quiz.pairedQuizId);
            if (pairedQuiz) {
                let preTestId, postTestId;
                if (new Date(quiz.createdAt) < new Date(pairedQuiz.createdAt)) {
                    preTestId = quiz.id;
                    postTestId = pairedQuiz.id;
                } else {
                    preTestId = pairedQuiz.id;
                    postTestId = quiz.id;
                }
                actionButtonsHtml += `
                    <button data-quiz-id="${postTestId}" data-pre-test-id="${preTestId}" class="compare-results-btn text-white bg-gradient-to-r from-cyan-500 to-blue-500 hover:bg-gradient-to-l font-semibold py-2 px-4 rounded-lg flex items-center gap-2 text-sm shadow-md hover:shadow-lg transition-shadow">
                        <i class="fas fa-chart-bar"></i> เปรียบเทียบผล
                    </button>
                `;
            }
        } else if (quiz.quizMode === 'pre-test') {
            actionButtonsHtml += `
                <button data-quiz-id="${quiz.id}" class="generate-post-test-btn text-white bg-gradient-to-r from-purple-500 to-pink-500 hover:bg-gradient-to-l font-semibold py-2 px-4 rounded-lg flex items-center gap-2 text-sm shadow-md hover:shadow-lg transition-shadow">
                    <i class="fas fa-magic"></i> สร้าง Post-test คู่ขนาน
                </button>
            `;
        }
        if (quiz.quizMode === 'pre-test' && submissionCount > 0) {
             actionButtonsHtml += `
                <button data-quiz-id="${quiz.id}" class="generate-lesson-btn text-gray-800 bg-gray-100 hover:bg-gray-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1">
                    <i class="fas fa-brain"></i> สร้างเนื้อหาสอน
                </button>
            `;
        } else if (!quiz.pairedQuizId && quiz.quizMode !== 'pre-test' && submissionCount > 0) {
            actionButtonsHtml += `
                <button data-quiz-id="${quiz.id}" class="generate-lesson-btn text-white bg-gradient-to-r from-gray-500 to-gray-700 hover:bg-gradient-to-l text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1">
                    <i class="fas fa-brain"></i> วิเคราะห์ผล
                </button>
            `;
        }

        let pairingButtonHtml = '';
        if (quiz.pairedQuizId) {
            pairingButtonHtml = `<button data-quiz-id="${quiz.id}" class="unpair-quiz-btn text-red-800 bg-red-100 hover:bg-red-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-unlink"></i> ยกเลิกจับคู่</button>`;
        } else {
            pairingButtonHtml = `<button data-quiz-id="${quiz.id}" class="pair-quiz-btn text-gray-800 bg-gray-100 hover:bg-gray-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-link"></i> จับคู่</button>`;
        }

        const syncButtonHtml = `
            <button data-quiz-id="${quiz.id}" data-mode="sync" class="start-game-btn bg-indigo-600 text-white hover:bg-indigo-700 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1 shadow-sm">
                <i class="fas fa-bolt"></i> Sync Mode
            </button>
        `;

        html += `
            <div class="p-4 border rounded-lg hover:bg-gray-50 flex flex-col">
                 <div class="flex justify-between items-start">
                     <div class="quiz-result-card cursor-pointer flex-grow" data-quiz-id="${quiz.id}">
                         <p class="font-semibold text-indigo-700 pointer-events-none">${quiz.topic} <span class="text-xs text-gray-500 pointer-events-none ml-2">(${quiz.questions.length} ข้อ)</span></p>
                         <p class="text-sm text-gray-500 pointer-events-none">สร้างเมื่อ: ${new Date(quiz.createdAt).toLocaleString('th-TH')}</p>
                         <div class="mt-1"><span class="font-semibold text-sm">${submissionCount}</span><span class="text-xs text-gray-600"> คนส่ง</span></div>
                         ${scheduleInfo}
                     </div>
                     <div class="flex flex-col items-end">
                         <div class="flex items-center gap-2">
                             <span class="text-xs font-semibold px-2 py-1 rounded-full ${statusColor}">${statusText}</span>
                             <button data-quiz-id="${quiz.id}" class="quiz-status-btn text-gray-600 hover:text-indigo-600 text-lg p-1" title="ตั้งค่าสถานะ"><i class="fas fa-power-off"></i></button>
                         </div>
                     </div>
                 </div>

                <div class="mt-3 pt-3 border-t">
                    <div class="flex items-center gap-2 flex-wrap">
                        <button data-quiz-id="${quiz.id}" class="star-quiz-btn text-gray-400 hover:text-yellow-500 text-lg p-1" title="ติดดาว"><i class="${quiz.isStarred ? 'fas fa-star text-yellow-500' : 'far fa-star'}"></i></button>
                        ${actionButtonsHtml}
                        ${syncButtonHtml}
                        <button data-quiz-id="${quiz.id}" class="toggle-actions-btn text-gray-500 hover:text-indigo-600 p-1 rounded-md text-sm border px-2 bg-white">
                            <i class="fas fa-ellipsis-h mr-1"></i> เพิ่มเติม
                        </button>
                    </div>

                    <div id="actions-container-${quiz.id}" class="hidden mt-2 pt-2 border-t border-dashed">
                        <div class="flex items-center gap-2 flex-wrap">
                            <button data-quiz-id="${quiz.id}" class="copy-quiz-id-list-btn text-blue-800 bg-blue-100 hover:bg-blue-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-id-card"></i> คัดลอก ID</button>
                            <button data-quiz-id="${quiz.id}" class="edit-quiz-btn text-blue-800 bg-blue-100 hover:bg-blue-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-pen"></i> แก้ไข</button>
                            <button data-quiz-id="${quiz.id}" class="quiz-settings-btn text-cyan-800 bg-cyan-100 hover:bg-cyan-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-cog"></i> ตั้งค่า</button>
                            <button data-quiz-id="${quiz.id}" class="duplicate-quiz-btn text-gray-800 bg-gray-100 hover:bg-gray-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-copy"></i> คัดลอก</button>
                            <button data-quiz-id="${quiz.id}" data-topic="${quiz.topic}" class="rename-quiz-btn text-yellow-800 bg-yellow-100 hover:bg-yellow-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-edit"></i> แก้ไขชื่อ</button>
                            <button data-quiz-id="${quiz.id}" class="parallel-quiz-btn text-teal-800 bg-teal-100 hover:bg-teal-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-clone"></i> สร้างคู่ขนาน</button>
                            <button data-quiz-id="${quiz.id}" class="move-quiz-btn text-purple-800 bg-purple-100 hover:bg-purple-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-project-diagram"></i> ย้าย</button>
                            ${pairingButtonHtml}
                            <button data-quiz-id="${quiz.id}" class="start-presentation-list-btn text-indigo-800 bg-indigo-100 hover:bg-indigo-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-chalkboard-teacher"></i> นำเสนอ</button>
                            <button data-quiz-id="${quiz.id}" class="admin-try-quiz-list-btn text-teal-800 bg-teal-100 hover:bg-teal-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-vial"></i> ทดลอง</button>
                            <button data-quiz-id="${quiz.id}" class="start-live-race-btn text-orange-800 bg-orange-100 hover:bg-orange-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-flag-checkered"></i> แข่งขันสด</button>
                            
                            <button data-quiz-id="${quiz.id}" class="export-pdf-list-btn text-red-800 bg-red-100 hover:bg-red-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-file-pdf"></i> Export PDF</button>
                            <button data-quiz-id="${quiz.id}" data-topic="${quiz.topic}" class="delete-quiz-btn text-red-500 hover:text-red-700 text-sm py-1 px-3 rounded-md flex items-center gap-1"><i class="fas fa-trash-alt"></i> ลบ</button>
                            <button data-quiz-id="${quiz.id}" class="generate-easy-version-btn text-green-800 bg-green-100 hover:bg-green-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1">
                                <i class="fas fa-magic"></i> สร้างฉบับง่าย
                            </button>
							<button data-quiz-id="${quiz.id}" class="generate-easy-parallel-btn text-teal-800 bg-teal-100 hover:bg-teal-200 text-xs font-semibold py-1 px-3 rounded-md flex items-center gap-1">
    <i class="fas fa-random"></i> สร้างง่าย+คู่ขนาน
</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
    });
    quizzesListContainer.innerHTML = html;
    
    document.querySelectorAll('.quiz-result-card').forEach(card => {
        card.addEventListener('click', () => {
            const quizId = card.dataset.quizId;
            showQuizDetailView(quizId);
        });
    });
}

async function handleUnpairQuiz(quizIdToUnpair) {
    const quizData = allQuizzes.find(q => q.id === quizIdToUnpair);
    if (!quizData || !quizData.pairedQuizId) {
        showMessage("ไม่พบข้อมูลการจับคู่");
        return;
    }

    showConfirmation(
        `คุณแน่ใจหรือไม่ว่าต้องการยกเลิกการจับคู่แบบทดสอบนี้?`,
        async () => {
            try {
                const firstQuizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizIdToUnpair);
                const secondQuizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizData.pairedQuizId);

                // ลบการจับคู่ของทั้งสองฝั่ง
                const batch = writeBatch(db);
                batch.update(firstQuizRef, { pairedQuizId: null });
                batch.update(secondQuizRef, { pairedQuizId: null });
                await batch.commit();
                
                showMessage("ยกเลิกการจับคู่สำเร็จ");
                // onSnapshot จะอัปเดต UI ให้อัตโนมัติ
            } catch (error) {
                console.error("Error unpairing quizzes:", error);
                showMessage("เกิดข้อผิดพลาดในการยกเลิกการจับคู่");
            }
        }
    );
}
// ▲▲▲ สิ้นสุดฟังก์ชันใหม่ ▲▲▲

// --- วางทับฟังก์ชัน formatAndPrintLessonPlan เดิมทั้งหมด ---
function formatAndPrintLessonPlan(lessonPlan, quizData) {
    const lessonWindow = window.open('', '_blank');
    
    const lessonHtml = `
        <!DOCTYPE html>
        <html lang="th">
        <head>
            <meta charset="UTF-8">
            <title>แผนการสอน: ${quizData.topic}</title>
            <script src="https://cdn.tailwindcss.com"><\/script>
            <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
            
            <script>
                window.MathJax = {
                    tex: {
                        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]
                    },
                    svg: {
                        fontCache: 'global'
                    }
                };
            <\/script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"><\/script>
            <style>
                body { font-family: 'Sarabun', sans-serif; }
                @media print {
                    body { -webkit-print-color-adjust: exact; }
                    .no-print { display: none; }
                }
                .content-section { page-break-inside: avoid; }
            </style>
        </head>
        <body class="p-8 max-w-4xl mx-auto">
            <div class="text-center mb-8">
                <p class="text-lg">แผนการสอนและคำแนะนำสำหรับครู</p>
                <h1 class="text-3xl font-bold">เรื่อง: ${quizData.topic}</h1>
            </div>

            <div class="space-y-8">
                <div class="content-section bg-red-50 p-4 rounded-lg border-l-4 border-red-400">
                    <h2 class="text-xl font-bold text-red-800 mb-2">จุดที่นักเรียนยังไม่เข้าใจ (Learning Gaps)</h2>
                    <ul class="list-disc list-inside text-red-900 space-y-1">
                        ${lessonPlan.learningGaps.map(gap => `<li>${gap}</li>`).join('')}
                    </ul>
                </div>

                <div class="content-section bg-blue-50 p-4 rounded-lg border-l-4 border-blue-400">
                    <h2 class="text-xl font-bold text-blue-800 mb-2">แนวทางการสอนและเนื้อหาทบทวน</h2>
                    <p class="text-gray-800 whitespace-pre-wrap">${lessonPlan.teachingContent}</p>
                </div>

                <div class="content-section bg-green-50 p-4 rounded-lg border-l-4 border-green-400">
                    <h2 class="text-xl font-bold text-green-800 mb-2">โจทย์ตัวอย่างสำหรับฝึกฝน</h2>
                    <div class="space-y-4">
                        ${lessonPlan.practiceProblems.map(p => `
                            <div>
                                <p><strong>โจทย์:</strong> ${p.question}</p>
                                <p><strong>เฉลย:</strong> ${p.solution}</p>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        </body>
        </html>
    `;
    
    lessonWindow.document.write(lessonHtml);
    lessonWindow.document.close();
    lessonWindow.onload = function() {
        // เพิ่มการหน่วงเวลาเพื่อให้ MathJax ทำงานเสร็จก่อนพิมพ์
        setTimeout(() => {
            lessonWindow.print();
        }, 1000); 
    };
}

async function handleAiFixFormula(index) {
    const questionItem = document.querySelector(`.question-editor-item[data-q-index="${index}"]`);
    if (!questionItem) return;

    const questionType = questionItem.dataset.qType;
    const fixBtn = questionItem.querySelector('.ai-fix-formula-btn');

    // 1. รวบรวมข้อมูลทั้งหมดจากฟอร์ม
    let dataToSend = {
        question: questionItem.querySelector('textarea').value
    };

    switch (questionType) {
        case 'multiple_choice':
            dataToSend.options = Array.from(questionItem.querySelectorAll('input[type="text"]')).map(input => input.value);
            break;
        
        // === [แก้ไข] เพิ่มเคส fill_in_no_choices ===
        case 'fill_in_no_choices':
        case 'short_answer':
            dataToSend.idealAnswer = questionItem.querySelector('.ideal-answer-input').value;
            break;
            
        case 'matching_item':
            dataToSend.correctResponse = questionItem.querySelector('.correct-response-input').value;
            break;
    }

    fixBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    fixBtn.disabled = true;

    try {
        const prompt = `
            คุณคือผู้เชี่ยวชาญด้าน LaTeX ขั้นสูง
            ภารกิจของคุณคือตรวจสอบและแก้ไขข้อมูลของคำถามต่อไปนี้ โดยเน้นที่การซ่อมแซมโค้ด LaTeX ที่ผิดพลาด
            ข้อมูลที่ต้องแก้ไข: ${JSON.stringify(dataToSend)}
            ให้ตอบกลับมาเป็น JSON object ที่มี key "fixedData"
        `;

        const schema = {
            type: "OBJECT",
            properties: {
                fixedData: {
                    type: "OBJECT",
                    properties: {
                        question: { type: "STRING" },
                        options: { type: "ARRAY", items: { type: "STRING" } },
                        idealAnswer: { type: "STRING" },
                        correctResponse: { type: "STRING" }
                    },
                    required: ["question"] 
                }
            },
            required: ["fixedData"]
        };

        const result = await callAnalysisApi(prompt, schema);

        if (result && result.fixedData) {
            const fixedData = result.fixedData;
            questionItem.querySelector('textarea').value = fixedData.question || dataToSend.question;

            switch (questionType) {
                case 'multiple_choice':
                    if (fixedData.options && fixedData.options.length > 0) {
                        questionItem.querySelectorAll('input[type="text"]').forEach((input, i) => {
                            input.value = fixedData.options[i] || dataToSend.options[i];
                        });
                    }
                    break;
                
                // === [แก้ไข] เพิ่มเคส fill_in_no_choices ===
                case 'fill_in_no_choices':
                case 'short_answer':
                    questionItem.querySelector('.ideal-answer-input').value = fixedData.idealAnswer || dataToSend.idealAnswer;
                    break;
                
                case 'matching_item':
                    questionItem.querySelector('.correct-response-input').value = fixedData.correctResponse || dataToSend.correctResponse;
                    break;
            }
            showMessage("AI แก้ไขสูตรทั้งหมดในข้อนี้สำเร็จแล้ว");
        } else {
            throw new Error("AI ไม่สามารถประมวลผลข้อมูลได้");
        }

    } catch (error) {
        console.error("AI Formula Fix Error:", error);
        showMessage("เกิดข้อผิดพลาดในการใช้ AI แก้ไขสูตร");
    } finally {
        fixBtn.innerHTML = '<i class="fas fa-square-root-alt"></i>';
        fixBtn.disabled = false;
    }
}

async function handleGenerateLessonPlan(quizId) {
    showMessage("AI กำลังวิเคราะห์ผลสอบและสร้างเนื้อหา... กรุณารอสักครู่");

    try {
        const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
        const quizSnap = await getDoc(quizRef);
        if (!quizSnap.exists()) throw new Error("ไม่พบข้อมูลแบบทดสอบ");
        const quizData = { id: quizId, ...quizSnap.data() };

        const submissionsRef = collection(db, `artifacts/${appId}/public/data/quizzes`, quizId, "submissions");
        const submissionsSnap = await getDocs(submissionsRef);
        const submissions = submissionsSnap.docs.map(doc => doc.data());
        if (submissions.length === 0) throw new Error("ยังไม่มีนักเรียนส่งงาน");

        const itemAnalysis = calculateItemAnalysis(quizData, submissions).perQuestionStats;
        const distractorAnalysis = calculateDistractorAnalysis(quizData, submissions);

        // --- START: ส่วนแก้ไขที่สำคัญ ---
        // 1. สร้างฟังก์ชันเล็กๆ สำหรับทำความสะอาดข้อความ
        const sanitizeForPrompt = (text) => {
            if (!text) return "";
            // แทนที่อักขระที่อาจทำให้ JSON เสียหาย
            return text.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
        };

        // 2. สร้าง analysisSummary โดยใช้ฟังก์ชันทำความสะอาด
        let analysisSummary = "สรุปผลการวิเคราะห์:\\n";
        quizData.questions.forEach((q, index) => {
            const pValue = itemAnalysis[index]?.p.toFixed(2) || 'N/A';
            const rValue = itemAnalysis[index]?.r.toFixed(2) || 'N/A';
            // ใช้ sanitizeForPrompt กับข้อความคำถาม
            const cleanQuestionText = sanitizeForPrompt(q.questionText || q.stem);
            analysisSummary += `- ข้อ ${index + 1} (p=${pValue}, r=${rValue}): ${cleanQuestionText}\\n`;
            
            if (q.questionType === 'multiple_choice' && distractorAnalysis[index]) {
                const distractors = distractorAnalysis[index];
                const commonMistake = Object.keys(distractors)
                    .filter(optIndex => parseInt(optIndex) !== q.correctAnswerIndex)
                    .sort((a, b) => distractors[b].total - distractors[a].total)[0];
                if (commonMistake && distractors[commonMistake].total > 0) {
                    // ใช้ sanitizeForPrompt กับข้อความตัวลวง
                    const cleanDistractorText = sanitizeForPrompt(distractors[commonMistake].text);
                    analysisSummary += `  - ความเข้าใจผิดที่พบบ่อย: นักเรียนมักเลือกตอบตัวเลือก "${cleanDistractorText}"\\n`;
                }
            }
        });
        // --- END: ส่วนแก้ไขที่สำคัญ ---
        
        const prompt = `
            คุณคือผู้เชี่ยวชาญด้านการออกแบบการสอน (Instructional Designer) จากข้อมูลผลการสอบก่อนเรียนในหัวข้อ "${quizData.topic}" ต่อไปนี้ โปรดสร้างสรุปเนื้อหาและแนวทางการสอนสำหรับครู
            ${analysisSummary}
            ภารกิจของคุณ:
            1.  **ระบุจุดอ่อนหลัก (Key Learning Gaps):** สรุป 2-3 ประเด็นสำคัญที่นักเรียนยังไม่เข้าใจมากที่สุดจากผลวิเคราะห์ข้างต้น
            2.  **สร้างเนื้อหาสอน (Teaching Content):** เขียนคำอธิบายสั้นๆ ที่เข้าใจง่าย หรือยกตัวอย่างเปรียบเทียบเพื่อแก้ไขความเข้าใจผิดในประเด็นเหล่านั้นโดยเฉพาะ
            3.  **สร้างโจทย์ตัวอย่าง (Practice Problems):** สร้างโจทย์ปัญหาใหม่ 1-2 ข้อ พร้อมเฉลยวิธีทำ เพื่อให้ครูใช้เป็นตัวอย่างในการสอนเพื่อเสริมความเข้าใจในจุดที่นักเรียนผิดบ่อย
            จัดทำเนื้อหาทั้งหมดเป็นภาษาไทยในรูปแบบที่ชัดเจนและนำไปใช้ได้ทันที
        `;
        const lessonSchema = {
            type: "OBJECT",
            properties: {
                learningGaps: { type: "ARRAY", items: { type: "STRING" } },
                teachingContent: { type: "STRING" },
                practiceProblems: { type: "ARRAY", items: { type: "OBJECT", properties: { question: { type: "STRING" }, solution: { type: "STRING" } } } }
            },
            required: ["learningGaps", "teachingContent", "practiceProblems"]
        };
        
        const lessonPlan = await callAnalysisApi(prompt, lessonSchema);
        
        await updateDoc(quizRef, { lessonPlan: lessonPlan });

        const lessonHtml = `
            <h3 class="text-xl font-bold mb-4 text-gray-800">แผนการสอนแนะนำสำหรับเรื่อง: ${quizData.topic}</h3>
            <div class="space-y-6 text-left text-base">
                <div><h4 class="font-semibold text-red-800 border-b pb-1 mb-2">จุดที่นักเรียนยังไม่เข้าใจ (Learning Gaps)</h4><ul class="list-disc list-inside text-red-900">${lessonPlan.learningGaps.map(gap => `<li>${gap}</li>`).join('')}</ul></div>
                <div><h4 class="font-semibold text-blue-800 border-b pb-1 mb-2">แนวทางการสอนและเนื้อหาทบทวน</h4><p class="text-gray-700 whitespace-pre-wrap">${lessonPlan.teachingContent}</p></div>
                <div><h4 class="font-semibold text-green-800 border-b pb-1 mb-2">โจทย์ตัวอย่างสำหรับฝึกฝน</h4><div class="space-y-3">${lessonPlan.practiceProblems.map(p => `<div class="border-l-4 border-green-200 pl-3"><p><strong>โจทย์:</strong> ${p.question}</p><p><strong>เฉลย:</strong> ${p.solution}</p></div>`).join('')}</div></div>
            </div>`;

        document.getElementById('lesson-plan-title').textContent = `แผนการสอน: ${quizData.topic}`;
        document.getElementById('lesson-plan-content').innerHTML = lessonHtml;
        document.getElementById('lesson-plan-modal').classList.remove('hidden');
		if (window.MathJax) MathJax.typesetPromise();
        messageModal.classList.add('hidden');

    } catch (error) {
        console.error("Error generating lesson plan:", error);
        showMessage(`เกิดข้อผิดพลาด: ${error.message}`);
    }
}
        
// --- วางทับฟังก์ชัน handleDuplicateQuiz เดิมทั้งหมด ---
async function handleDuplicateQuiz(quizId) {
            try {
                const originalQuizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
                const originalQuizSnap = await getDoc(originalQuizRef);

                if (originalQuizSnap.exists()) {
                    const originalData = originalQuizSnap.data();
                    let newTopic = '';
                    let newQuizMode = 'standard';
                    let newPairedQuizId = null;

                    // --- [START] ตรรกะใหม่ที่เพิ่มเข้ามา ---
                    if (originalData.quizMode === 'pre-test') {
                        // กรณีที่ 1: คัดลอก Pre-test, ให้สร้างเป็น Post-test
                        let baseTopic = originalData.topic.replace('(ก่อนเรียน)', '').trim();
                        newTopic = `(หลังเรียน) ${baseTopic}`;
                        newQuizMode = 'post-test';
                        newPairedQuizId = quizId; //จับคู่กับ Pre-test เดิม
                    } else {
                        // กรณีที่ 2: คัดลอกแบบทดสอบธรรมดาหรือ Post-test, ให้สร้างเป็น (คัดลอก)
                        newTopic = `(คัดลอก) ${originalData.topic}`;
                        // quizMode และ pairedQuizId เป็นค่าเริ่มต้น (standard, null)
                    }
                    // --- [END] สิ้นสุดตรรกะใหม่ ---

                    const newData = {
                        ...originalData,
                        topic: newTopic,
                        createdAt: new Date().toISOString(),
                        quizMode: newQuizMode,
                        pairedQuizId: newPairedQuizId
                    };
                    
                    let newQuizId;
                    while (true) {
                        newQuizId = Math.floor(1000 + Math.random() * 9000).toString();
                        const existing = await getDoc(doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId));
                        if (!existing.exists()) break;
                    }

                    const newQuizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, newQuizId);
                    await setDoc(newQuizRef, newData);
                    
                    if (newData.quizMode === 'post-test') {
                        await updateDoc(originalQuizRef, { pairedQuizId: newQuizId });
                    }

                    showMessage("คัดลอกแบบทดสอบสำเร็จ");
                } else {
                    throw new Error("Original quiz not found");
                }
            } catch (error) {
                console.error("Error duplicating quiz:", error);
                showMessage("เกิดข้อผิดพลาดในการคัดลอกแบบทดสอบ");
            }
        }

// --- วางทับฟังก์ชัน handleDeleteQuiz เดิมทั้งหมดด้วยโค้ดนี้ ---
async function handleDeleteQuiz(quizId, showSuccessMessage = true) {
    try {
        const batch = writeBatch(db);
        // 1. ลบ Submissions ทั้งหมดของแบบทดสอบนี้
        const submissionsRef = collection(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`);
        const submissionsSnapshot = await getDocs(submissionsRef);
        submissionsSnapshot.forEach(subDoc => {
            batch.delete(doc(submissionsRef, subDoc.id));
        });

        // 2. ลบตัวแบบทดสอบเอง
        const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
        batch.delete(quizRef);

        await batch.commit();

        // --- [ใหม่] ส่วนโค้ดสำหรับลบลิงก์ออกจาก Blueprint Projects ทั้งหมด ---
        try {
            console.log(`Starting cleanup for deleted quiz ID: ${quizId} in all blueprint projects.`);
            const blueprintProjectsRef = collection(db, `artifacts/${appId}/public/data/blueprintProjects`);
            const blueprintSnapshot = await getDocs(blueprintProjectsRef);
            
            const updatePromises = [];

            blueprintSnapshot.forEach(docSnap => {
                const projectData = docSnap.data();
                const topics = projectData.topics || {};
                let projectNeedsUpdate = false;
                
                for (const topicId in topics) {
                    const topic = topics[topicId];
                    if (topic.linkedQuizIds && topic.linkedQuizIds.includes(quizId)) {
                        projectNeedsUpdate = true;
                        // เตรียมคำสั่ง update โดยใช้ arrayRemove
                        const projectRef = doc(db, `artifacts/${appId}/public/data/blueprintProjects`, docSnap.id);
                        const promise = updateDoc(projectRef, {
                            [`topics.${topicId}.linkedQuizIds`]: arrayRemove(quizId)
                        });
                        updatePromises.push(promise);
                    }
                }
            });

            if (updatePromises.length > 0) {
                await Promise.all(updatePromises);
                console.log(`Successfully removed ${updatePromises.length} link(s) for quiz ID: ${quizId}.`);
            }
        } catch (cleanupError) {
            console.error("Error during blueprint link cleanup:", cleanupError);
            // ไม่ต้องแสดงข้อความ Error ให้ผู้ใช้เห็น เพราะการลบหลักสำเร็จแล้ว
        }
        // --- [สิ้นสุดส่วนโค้ดใหม่] ---

        if (showSuccessMessage) {
            showMessage("ลบแบบทดสอบสำเร็จแล้ว");
        }
    } catch (error) {
        console.error("Error deleting quiz:", error);
        if (showSuccessMessage) {
            showMessage("เกิดข้อผิดพลาดในการลบแบบทดสอบ");
        }
    }
}

        async function showQuizDetailView(quizId) {
            if (unsubscribeSubmissionsListener) unsubscribeSubmissionsListener();
            switchQuizDetailTab('analytics');

            try {
                // 1. ดึงข้อมูลของแบบทดสอบที่คลิก
                const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
                const quizDoc = await getDoc(quizRef);

                if (!quizDoc.exists()) {
                    showMessage("ไม่พบข้อมูลแบบทดสอบ");
                    return;
                }

                const quizData = { id: quizDoc.id, ...quizDoc.data() };
                currentQuizData = quizData;

                // --- [ ส่วนที่แก้ไขใหม่ทั้งหมด ] ---
                // 2. ดึงข้อมูลของโปรเจคแม่ของแบบทดสอบนั้นๆ เสมอ
                // เพื่อให้แน่ใจว่าเรามีข้อมูลนักเรียน (currentProjectData) พร้อมใช้งาน
                const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, quizData.projectId);
                const projectDoc = await getDoc(projectRef);
                if (projectDoc.exists()) {
                    currentProjectData = projectDoc.data();
                    currentProjectId = quizData.projectId; // อัปเดต ID โปรเจคปัจจุบันให้ถูกต้องเสมอ
                } else {
                    // ในกรณีที่โปรเจคถูกลบไปแล้วแต่แบบทดสอบยังอยู่ (กรณีฉุกเฉิน)
                    // ให้ใช้ข้อมูลว่างๆ แทนเพื่อไม่ให้แอปพัง
                    currentProjectData = { students: [] };
                    currentProjectId = quizData.projectId;
                }
                // --- [ สิ้นสุดส่วนที่แก้ไข ] ---

                // 3. ตั้งค่าหัวข้อและ ID บนหน้าจอ
                document.getElementById('results-quiz-title').textContent = quizData.topic;
                document.getElementById('results-quiz-id-display').textContent = quizId;

                // 4. เริ่มฟังข้อมูลการส่งงาน และวาดผลลัพธ์
                const submissionsRef = collection(db, `artifacts/${appId}/public/data/quizzes`, quizId, "submissions");
unsubscribeSubmissionsListener = onSnapshot(submissionsRef, (snapshot) => {
                    // 1. ดึงข้อมูลทั้งหมด (รวมทั้งที่ยังทำไม่เสร็จ)
                    const allSubmissions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    currentSubmissions = allSubmissions; 

                    // 2. สร้าง list ใหม่ที่กรองเอาเฉพาะคนที่ "ทำเสร็จแล้ว" จริงๆ (มีข้อมูลการทำข้อสอบ)
                    // เพื่อส่งไปให้ฟังก์ชันที่ต้องการข้อมูลคะแนนเท่านั้น
                    const completedSubmissions = allSubmissions.filter(sub => sub.attempts && sub.attempts.length > 0);

                    // 3. เรียกใช้ฟังก์ชันต่างๆ โดยส่งข้อมูลที่เหมาะสมไปให้
                    renderBehaviorLog(allSubmissions); // <-- ใช้ข้อมูลทั้งหมด
                    renderAnswerGrid(currentProjectData.students, completedSubmissions, quizData); // <-- ใช้เฉพาะที่ทำเสร็จ
                    renderAnalytics(quizData, completedSubmissions); // <-- ใช้เฉพาะที่ทำเสร็จ
                    renderQuizResultsTable(currentProjectData.students, allSubmissions, quizData); // <-- ใช้ข้อมูลทั้งหมด เพื่อแสดงสถานะได้ครบทุกคน
                    renderQuizLeaderboard(completedSubmissions, quizData, 'quiz-leaderboard-table-body'); // <-- ใช้เฉพาะที่ทำเสร็จ
                });

                // 5. แสดง View
                showView('quiz-results');

            } catch (error) {
                console.error("Error showing quiz detail view:", error);
                showMessage("เกิดข้อผิดพลาดในการแสดงรายละเอียดแบบทดสอบ");
            }
        }
		
function renderAnswerGrid(students, submissions, quizData) {
    const container = document.getElementById('answer-grid-container');
    if (!container) return;

    if (!students || students.length === 0) {
        container.innerHTML = '<p class="p-4 text-center text-gray-500">ยังไม่มีข้อมูลนักเรียนเพื่อนำมาสร้างตาราง</p>';
        return;
    }

    const questions = quizData.questions;
    const submissionsByStudent = submissions.reduce((acc, sub) => {
        acc[sub.studentName] = sub;
        return acc;
    }, {});

    const toChar = (index) => String.fromCharCode(65 + index);

    const getCorrectAnswerText = (q) => {
        const questionType = q.questionType || quizData.quizType;
        switch (questionType) {
            case 'multiple_choice':
                return q.options && q.options.length > q.correctAnswerIndex ? toChar(q.correctAnswerIndex) : '-';
            case 'true_false':
                const correctBool = (q.correctAnswer === true || String(q.correctAnswer).toLowerCase() === 'true');
                return correctBool ? 'ใช่' : 'ไม่ใช่';
            case 'matching_item':
                return q.correctResponse || '-';
            case 'short_answer':
                return 'พิมพ์ตอบ';
            default:
                return '-';
        }
    };

    const getUserAnswerText = (q, ans) => {
        if (ans.answer === null || ans.answer === undefined) return '-';
        const questionType = q.questionType || quizData.quizType;
        switch (questionType) {
            case 'multiple_choice':
                const originalIndex = q.options.findIndex(opt => opt === ans.answerText);
                return originalIndex !== -1 ? toChar(originalIndex) : (ans.answerText || '-');
            case 'true_false':
                if (ans.answer == '0' || ans.answer === true || ans.answer === 'true') {
                    return 'ใช่';
                }
                return 'ไม่ใช่';
            default:
                return ans.answer;
        }
    };

    let tableHtml = `
        <table class="min-w-full bg-white text-sm text-center">
            <thead class="bg-gray-100">
                <tr>
                    <th class="py-2 px-2 border-b border-r font-semibold text-left sticky left-0 bg-gray-100 z-10">ชื่อ - สกุล</th>
                    ${questions.map((q, i) => `<th class="py-2 px-2 border-b">${i + 1}</th>`).join('')}
                </tr>
                <tr class="bg-gray-200">
                    <th class="py-1 px-2 border-b border-r text-left sticky left-0 bg-gray-200 z-10">เฉลย</th>
                    ${questions.map(q => `<td class="py-1 px-2 border-b font-bold text-blue-700">${getCorrectAnswerText(q)}</td>`).join('')}
                </tr>
            </thead>
            <tbody>
    `;

    students.forEach(name => {
        tableHtml += '<tr>';
        tableHtml += `<td class="py-2 px-2 border-b border-r text-left sticky left-0 bg-white z-10">${name}</td>`;
        
        const submission = submissionsByStudent[name];
        if (submission) {
            const latestAttempt = submission.attempts[submission.attempts.length - 1];
            questions.forEach((q, index) => {
                const answer = latestAttempt.answers.find(ans => ans.questionId === q.id);

                if (answer) {
                    let cellClasses = '';
                    const isCorrect = answer.isCorrect === true;
                    const isConfident = (answer.wasConfident === true || answer.wasConfident === 'confident');
                    const powerupUsed = answer.powerupUsed;

                    if (powerupUsed === 'wagerMultiplier') {
                        // สีสำหรับโหมดเดิมพัน (ปรับแก้: เอา border ออก)
                        if (isCorrect) {
                            cellClasses = 'bg-yellow-300 text-yellow-900 font-bold'; // เหลือแค่สีพื้นหลังและตัวอักษร
                        } else {
                            cellClasses = 'bg-red-700 text-white font-bold'; 
                        }
                    } else if (isConfident) {
                        cellClasses = isCorrect ? 'bg-green-400 text-white font-bold' : 'bg-red-500 text-white font-bold';
                    } else {
                        cellClasses = isCorrect ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
                    }
                    
                    tableHtml += `<td class="py-2 px-2 border-b ${cellClasses}">${getUserAnswerText(q, answer)}</td>`;

                } else {
                    tableHtml += '<td class="py-2 px-2 border-b bg-gray-50">-</td>';
                }
            });
        } else {
            tableHtml += questions.map(() => '<td class="py-2 px-2 border-b bg-gray-50 text-gray-400">ยังไม่ส่ง</td>').join('');
        }
        tableHtml += '</tr>';
    });

    tableHtml += '</tbody></table>';
    container.innerHTML = tableHtml;
}

function renderQuizResultsTable(students, submissions, quizData) {
    const submissionsByStudent = submissions.reduce((acc, sub) => {
        acc[sub.studentName] = sub;
        return acc;
    }, {});

    // --- [แก้ไข] 1. คำนวณคะแนนเต็มรวม (Weighted Max Score) ---
    let totalMaxScore = 0;
    const typeScoring = quizData.settings?.typeScoring || { mcq: 1, sa: 1, tf: 1 };
    if (quizData.questions && quizData.questions.length > 0) {
        quizData.questions.forEach(q => {
            const qType = q.questionType || quizData.quizType;
            let weight = 1;
            if (qType === 'short_answer' || qType === 'fill_in_no_choices') weight = parseFloat(typeScoring.sa) || 1;
            else if (qType === 'true_false') weight = parseFloat(typeScoring.tf) || 1;
            else weight = parseFloat(typeScoring.mcq) || 1;
            totalMaxScore += weight;
        });
    } else { totalMaxScore = 1; }
    // -------------------------------------------------------

    // 1. ปุ่มลบหมู่
    const exportContainer = document.querySelector('#scores-tab-content .mb-4.flex');
    if (exportContainer && !document.getElementById('bulk-delete-submissions-btn')) {
        const bulkDeleteBtn = document.createElement('button');
        bulkDeleteBtn.id = 'bulk-delete-submissions-btn';
        bulkDeleteBtn.className = 'hidden bg-red-600 text-white py-1 px-3 rounded-md hover:bg-red-700 text-sm flex items-center gap-2 ml-auto transition-all';
        bulkDeleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i> ลบรายการที่เลือก (<span id="selected-count">0</span>)';
        exportContainer.appendChild(bulkDeleteBtn);
        bulkDeleteBtn.addEventListener('click', handleBulkDeleteSubmissions);
    }

    // 2. หัวตาราง
    const tableHead = document.querySelector('#results-table thead tr');
    if (tableHead) {
        tableHead.innerHTML = `
            <th class="py-2 px-4 border-b text-center w-10">
                <input type="checkbox" id="select-all-submissions" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer">
            </th>
            <th class="py-2 px-4 border-b text-left">ชื่อนักเรียน</th>
            <th class="py-2 px-4 border-b text-left">คะแนนดีที่สุด</th>
            <th class="py-2 px-4 border-b text-left">ผล</th>
            <th class="py-2 px-4 border-b text-left">ประเภท</th>
            <th class="py-2 px-4 border-b text-left">คะแนนครั้งแรก</th>
            <th class="py-2 px-4 border-b text-left">คะแนนล่าสุด</th>
            <th class="py-2 px-4 border-b text-left">Points</th>
            <th class="py-2 px-4 border-b text-left">สถานะ</th>
            <th class="py-2 px-4 border-b text-left">เวลาที่ส่งล่าสุด</th>
            <th class="py-2 px-4 border-b text-left">จัดการ</th>
        `;
    }

    const tableBody = document.getElementById('quiz-results-table-body');
    if (!students || students.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="11" class="text-center p-4 text-gray-500">ไม่มีรายชื่อนักเรียนในโปรเจคนี้</td></tr>';
        return;
    }
    
    const isRemedialQuiz = quizData.isRemedial === true;
    const passingScore = quizData.settings?.passingScore ?? -1; 

    let html = '';
    students.forEach(studentName => {
        const submission = submissionsByStudent[studentName];
        let quizTypeHtml = `<td class="py-2 px-4 border-b"><span class="text-xs font-medium px-2.5 py-0.5 rounded-full ${isRemedialQuiz ? 'bg-amber-100 text-amber-800' : 'bg-blue-100 text-blue-800'}">${isRemedialQuiz ? 'สอบซ่อม' : 'สอบปกติ'}</span></td>`;
        
        let checkboxHtml = '';
        if (submission) {
            checkboxHtml = `<input type="checkbox" class="submission-checkbox h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer" value="${studentName}">`;
        } else {
             checkboxHtml = `<input type="checkbox" disabled class="h-4 w-4 rounded border-gray-200 text-gray-300 cursor-not-allowed">`;
        }

        if (submission) {
            if (submission.attempts && submission.attempts.length > 0) {
                let isPass = isRemedialQuiz ? (submission.bestScore === totalMaxScore) : (passingScore !== -1 && submission.bestScore >= passingScore);
                const resultClass = isPass ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
                const resultText = isPass ? 'ผ่าน' : 'ไม่ผ่าน';
                const resultHtml = `<td class="py-2 px-4 border-b"><span class="text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full ${resultClass}">${resultText}</span></td>`;
                const statusCell = `<td class="py-2 px-4 border-b"><span class="bg-blue-100 text-blue-800 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">ส่งแล้ว (${submission.attempts?.length || 1} ครั้ง)</span></td>`;

                const pointsHtml = `
                    <div class="flex items-center gap-2">
                        <span class="font-semibold text-blue-600">${(submission.points || 0).toLocaleString()}</span>
                        <button class="edit-points-btn text-gray-400 hover:text-orange-500 transition-colors" 
                                data-student-name="${studentName}" 
                                data-current-points="${submission.points || 0}"
                                title="แก้ไข Points ด้วยมือ">
                            <i class="fas fa-pen text-xs"></i>
                        </button>
                    </div>
                `;

                // --- [แก้ไข] ใช้ totalMaxScore แทน submission.totalQuestions ---
                html += `
                    <tr class="hover:bg-gray-50">
                        <td class="py-2 px-4 border-b text-center">${checkboxHtml}</td>
                        <td class="py-2 px-4 border-b">${studentName}</td>
                        <td class="py-2 px-4 border-b text-green-600 font-bold">${submission.bestScore} / ${totalMaxScore}</td>
                        ${resultHtml}
                        ${quizTypeHtml}
                        <td class="py-2 px-4 border-b font-semibold">${submission.firstScore} / ${totalMaxScore}</td>
                        <td class="py-2 px-4 border-b font-semibold">${submission.latestScore} / ${totalMaxScore}</td>
                        <td class="py-2 px-4 border-b">${pointsHtml}</td>
                        ${statusCell}
                        <td class="py-2 px-4 border-b text-sm text-gray-600">${new Date(submission.latestSubmittedAt).toLocaleString('th-TH')}</td>
                        <td class="py-2 px-4 border-b">
                            <button data-student-name="${studentName}" class="delete-submission-btn text-red-500 hover:text-red-700 text-lg p-1" title="ลบผลสอบของนักเรียนคนนี้">
                                <i class="fas fa-trash-alt pointer-events-none"></i>
                            </button>
                        </td>
                    </tr>
                `;
            } else {
                // กรณีเริ่มทำแต่ไม่เสร็จ
                const statusCell = `<td class="py-2 px-4 border-b"><span class="bg-orange-100 text-orange-800 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">เริ่มแล้ว (ยังไม่ส่ง)</span></td>`;
                html += `
                    <tr class="hover:bg-gray-50 bg-orange-50">
                        <td class="py-2 px-4 border-b text-center">${checkboxHtml}</td>
                        <td class="py-2 px-4 border-b">${studentName}</td>
                        <td class="py-2 px-4 border-b">-</td> <td class="py-2 px-4 border-b">-</td>
                        ${quizTypeHtml}
                        <td class="py-2 px-4 border-b">-</td> <td class="py-2 px-4 border-b">-</td> <td class="py-2 px-4 border-b">-</td>
                        ${statusCell}
                        <td class="py-2 px-4 border-b text-sm text-gray-600">${new Date(submission.startedAt).toLocaleString('th-TH')}</td>
                        <td class="py-2 px-4 border-b">
                                <button data-student-name="${studentName}" class="delete-submission-btn text-red-500 hover:text-red-700 text-lg p-1" title="ลบผลสอบของนักเรียนคนนี้">
                                <i class="fas fa-trash-alt pointer-events-none"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }
        } else {
            // กรณีที่ยังไม่เริ่มทำ
            const statusCell = `<td class="py-2 px-4 border-b"><span class="bg-yellow-100 text-yellow-800 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">ยังไม่ส่ง</span></td>`;
            html += `
                <tr class="hover:bg-gray-50">
                    <td class="py-2 px-4 border-b text-center">${checkboxHtml}</td>
                    <td class="py-2 px-4 border-b">${studentName}</td>
                    <td class="py-2 px-4 border-b">-</td> <td class="py-2 px-4 border-b">-</td>
                    ${quizTypeHtml}
                    <td class="py-2 px-4 border-b">-</td> <td class="py-2 px-4 border-b">-</td> <td class="py-2 px-4 border-b">-</td>
                    ${statusCell}
                    <td class="py-2 px-4 border-b">-</td>
                    <td class="py-2 px-4 border-b"></td>
                </tr>
            `;
        }
    });
    tableBody.innerHTML = html;

    // Checkbox Logic
    const selectAllCb = document.getElementById('select-all-submissions');
    const rowCbs = document.querySelectorAll('.submission-checkbox');
    const bulkBtn = document.getElementById('bulk-delete-submissions-btn');
    const countSpan = document.getElementById('selected-count');

    const updateBulkBtnState = () => {
        const checkedCount = document.querySelectorAll('.submission-checkbox:checked').length;
        if (countSpan) countSpan.textContent = checkedCount;
        if (checkedCount > 0) {
            bulkBtn.classList.remove('hidden');
        } else {
            bulkBtn.classList.add('hidden');
        }
    };

    if (selectAllCb) {
        selectAllCb.addEventListener('change', (e) => {
            rowCbs.forEach(cb => cb.checked = e.target.checked);
            updateBulkBtnState();
        });
    }

    rowCbs.forEach(cb => {
        cb.addEventListener('change', () => {
            if (!cb.checked && selectAllCb) selectAllCb.checked = false;
            if (cb.checked && selectAllCb) {
                const allChecked = document.querySelectorAll('.submission-checkbox:checked').length === rowCbs.length;
                if (allChecked) selectAllCb.checked = true;
            }
            updateBulkBtnState();
        });
    });
}

async function handleBulkDeleteSubmissions() {
    const selectedCheckboxes = document.querySelectorAll('.submission-checkbox:checked');
    const selectedNames = Array.from(selectedCheckboxes).map(cb => cb.value);

    if (selectedNames.length === 0) return;

    if (!currentQuizData || !currentQuizData.id) {
        showMessage("ข้อมูลแบบทดสอบไม่ถูกต้อง");
        return;
    }

    showConfirmation(
        `คุณแน่ใจหรือไม่ว่าต้องการลบผลการสอบของนักเรียน ${selectedNames.length} คนที่เลือก? การกระทำนี้ไม่สามารถย้อนกลับได้`,
        async () => {
            const quizId = currentQuizData.id;
            const batch = writeBatch(db);

            selectedNames.forEach(studentName => {
                const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`, studentName);
                batch.delete(submissionRef);
            });
            
            try {
                await batch.commit();
                showMessage(`ลบผลการสอบ ${selectedNames.length} รายการเรียบร้อยแล้ว`);
                
                // ซ่อนปุ่มหลังจากลบเสร็จ
                document.getElementById('bulk-delete-submissions-btn').classList.add('hidden');
                // เคลียร์ Checkbox หัวตาราง
                const selectAllHeader = document.getElementById('select-all-submissions');
                if(selectAllHeader) selectAllHeader.checked = false;

                // onSnapshot จะทำงานและรีเฟรชตารางให้อัตโนมัติ
            } catch (error) {
                console.error("Error bulk deleting submissions:", error);
                showMessage("เกิดข้อผิดพลาดในการลบข้อมูล");
            }
        }
    );
}

        async function confirmRenameQuiz() {
            const newName = document.getElementById('rename-quiz-input').value.trim();
            if (!newName) {
                showMessage("กรุณาใส่ชื่อใหม่");
                return;
            }
            if (!actionTargetId) return;

            const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, actionTargetId);
            try {
                await updateDoc(quizRef, { topic: newName });
                showMessage("เปลี่ยนชื่อแบบทดสอบสำเร็จ");
                renameQuizModal.classList.add('hidden');
                actionTargetId = null;
            } catch (error) {
                console.error("Error renaming quiz:", error);
                showMessage("เกิดข้อผิดพลาดในการเปลี่ยนชื่อ");
            }
        }
        
        async function handleMoveQuiz(quizId) {
            actionTargetId = quizId;
            const projectSelect = document.getElementById('move-quiz-project-select');
            projectSelect.innerHTML = '<option>กำลังโหลดโปรเจค...</option>';
            moveQuizModal.classList.remove('hidden');

            try {
                const projectsRef = collection(db, `artifacts/${appId}/public/data/projects`);
                const snapshot = await getDocs(projectsRef);
                const projects = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                
                const otherProjects = projects.filter(p => p.id !== currentProjectId);

                if (otherProjects.length === 0) {
                    projectSelect.innerHTML = '<option value="">ไม่มีโปรเจคอื่นให้ย้ายไป</option>';
                    document.getElementById('confirm-move-quiz-btn').disabled = true;
                    return;
                }

                projectSelect.innerHTML = otherProjects
                    .map(p => `<option value="${p.id}">${p.projectName}</option>`)
                    .join('');
                document.getElementById('confirm-move-quiz-btn').disabled = false;

            } catch (error) {
                console.error("Error fetching projects for move:", error);
                showMessage("ไม่สามารถโหลดรายการโปรเจคได้");
                moveQuizModal.classList.add('hidden');
            }
        }

        async function confirmMoveQuiz() {
            const newProjectId = document.getElementById('move-quiz-project-select').value;
            if (!newProjectId) {
                showMessage("กรุณาเลือกโปรเจคปลายทาง");
                return;
            }
            if (!actionTargetId) return;

            const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, actionTargetId);
            try {
                await updateDoc(quizRef, { projectId: newProjectId });
                showMessage("ย้ายแบบทดสอบสำเร็จ");
                moveQuizModal.classList.add('hidden');
                actionTargetId = null;
            } catch (error) {
                console.error("Error moving quiz:", error);
                showMessage("เกิดข้อผิดพลาดในการย้ายแบบทดสอบ");
            }
        }

async function handleQuizSettings(quizId) {
    actionTargetId = quizId;
    const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
    
    try {
        const quizSnap = await getDoc(quizRef);
        if (quizSnap.exists()) {
            const quizData = quizSnap.data();
            // ดึงค่า settings ออกมา (ถ้าไม่มีให้ใช้ object ว่าง)
            const settings = quizData.settings || {};

            // --- 1. โหลดค่าทั่วไป ---
            document.getElementById('modal-shuffle-select').value = settings.shuffle || 'none';
            document.getElementById('modal-results-display-select').value = settings.resultsDisplay || 'show_results_and_answers';
            
            // --- 2. โหลดค่าจับเวลา ---
            document.getElementById('modal-timer-mode-select').value = settings.timerMode || 'none';
            document.getElementById('modal-timer-duration-input').value = settings.timerDuration || 10;
            // เรียกฟังก์ชันเพื่อซ่อน/แสดงช่องกรอกเวลาตามค่าที่โหลดมา
            toggleTimerInputInModal(); 

            // --- 3. โหลดเงื่อนไขการผ่าน ---
            document.getElementById('modal-passing-score-input').value = settings.passingScore || 0;
            if (document.getElementById('modal-adaptive-quiz-checkbox')) {
                document.getElementById('modal-adaptive-quiz-checkbox').checked = settings.isAdaptive || false;
            }
            if (document.getElementById('modal-loop-until-pass-checkbox')) {
                document.getElementById('modal-loop-until-pass-checkbox').checked = settings.loopUntilPass || false;
            }

            // --- 4. โหลดคะแนน O-NET (Weighted Score) ---
            const typeScoring = settings.typeScoring || { mcq: 1, sa: 1, tf: 1 };
            if (document.getElementById('modal-score-mcq')) document.getElementById('modal-score-mcq').value = typeScoring.mcq;
            if (document.getElementById('modal-score-sa')) document.getElementById('modal-score-sa').value = typeScoring.sa;
            if (document.getElementById('modal-score-tf')) document.getElementById('modal-score-tf').value = typeScoring.tf;

            // --- 5. โหลดความมั่นใจ ---
            if (document.getElementById('modal-confidence-scoring-checkbox')) {
                document.getElementById('modal-confidence-scoring-checkbox').checked = settings.isConfidenceScoringEnabled || false;
            }
            if (document.getElementById('modal-confidence-mode-select')) {
                document.getElementById('modal-confidence-mode-select').value = settings.confidenceMode || 'checkbox';
            }
            // เรียกฟังก์ชันเพื่อซ่อน/แสดงตัวเลือกความมั่นใจ
            toggleConfidenceOptionsInModal();

            // เปิดหน้าต่าง Modal
            document.getElementById('quiz-settings-modal').classList.remove('hidden');
        } else {
            showMessage("ไม่พบข้อมูลแบบทดสอบ");
        }
    } catch (error) {
        console.error("Error fetching quiz settings:", error);
        showMessage("เกิดข้อผิดพลาดในการโหลดการตั้งค่า");
    }
}

function toggleTimerInputInModal() {
    const mode = document.getElementById('modal-timer-mode-select').value;
    const container = document.getElementById('modal-timer-duration-container');
    const label = document.getElementById('modal-timer-duration-label');
    
    if (mode === 'none') {
        container.classList.add('hidden');
    } else {
        container.classList.remove('hidden');
        if (mode === 'whole_quiz') {
            label.textContent = 'ระยะเวลา (นาที):';
        } else {
            label.textContent = 'ระยะเวลา (วินาที):';
        }
    }
}

function toggleConfidenceOptionsInModal() {
    const isChecked = document.getElementById('modal-confidence-scoring-checkbox').checked;
    const container = document.getElementById('modal-confidence-mode-container');
    if (container) {
        if (isChecked) {
            container.classList.remove('hidden');
        } else {
            container.classList.add('hidden');
        }
    }
}

async function confirmQuizSettings() {
    if (!actionTargetId) return;
    
    const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, actionTargetId);
    
    const newSettings = {
        shuffle: document.getElementById('modal-shuffle-select').value,
        resultsDisplay: document.getElementById('modal-results-display-select').value,
        timerMode: document.getElementById('modal-timer-mode-select').value,
        timerDuration: parseInt(document.getElementById('modal-timer-duration-input').value) || 10,
        passingScore: parseInt(document.getElementById('modal-passing-score-input').value) || 0,
        isAdaptive: document.getElementById('modal-adaptive-quiz-checkbox').checked,
        loopUntilPass: document.getElementById('modal-loop-until-pass-checkbox').checked,
        isConfidenceScoringEnabled: document.getElementById('modal-confidence-scoring-checkbox').checked,
        confidenceMode: document.getElementById('modal-confidence-mode-select').value,

        // ▼▼▼ [ส่วนที่เพิ่มใหม่: บันทึกคะแนนรายประเภท] ▼▼▼
        typeScoring: {
            mcq: parseFloat(document.getElementById('modal-score-mcq').value) || 1, // ตัวเลือก
            sa: parseFloat(document.getElementById('modal-score-sa').value) || 1,  // เติมคำ
            tf: parseFloat(document.getElementById('modal-score-tf').value) || 1   // ถูกผิด
        }
        // ▲▲▲
    };

    try {
        await updateDoc(quizRef, { settings: newSettings });
        showMessage("บันทึกการตั้งค่าสำเร็จ");
        quizSettingsModal.classList.add('hidden');
        actionTargetId = null;
    } catch (error) {
        console.error("Error updating quiz settings:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึก");
    }
}

        async function confirmQuizStatus() {
            if (!actionTargetId) return;
            const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, actionTargetId);
            const selectedOption = document.querySelector('input[name="status-option"]:checked');
            
            if (!selectedOption) {
                showMessage("กรุณาเลือกสถานะ");
                return;
            }

            const statusChoice = selectedOption.value;
            let dataToUpdate = {};

            if (statusChoice === 'active' || statusChoice === 'inactive') {
                dataToUpdate = { status: statusChoice, startTime: null, endTime: null };
            } else if (statusChoice === 'schedule') {
                const startTime = document.getElementById('quiz-start-time').value;
                const endTime = document.getElementById('quiz-end-time').value;
                if (!startTime && !endTime) {
                    showMessage("กรุณาเลือกเวลาเปิด หรือ เวลาปิด อย่างน้อยหนึ่งอย่าง");
                    return;
                }
                dataToUpdate = { 
                    status: 'scheduled', 
                    startTime: startTime ? new Date(startTime).toISOString() : null,
                    endTime: endTime ? new Date(endTime).toISOString() : null
                };
            }

            try {
                await updateDoc(quizRef, dataToUpdate);
                showMessage("อัปเดตสถานะสำเร็จ");
                quizStatusModal.classList.add('hidden');
                actionTargetId = null;
            } catch (error) {
                 console.error("Error updating quiz status:", error);
                 showMessage("เกิดข้อผิดพลาดในการอัปเดตสถานะ");
            }
        }

        // --- Leaderboard ---
        function listenForStudentProfiles(projectId) {
            const profilesRef = collection(db, `artifacts/${appId}/public/data/projects/${projectId}/studentProfiles`);
            unsubscribeStudentProfilesListener = onSnapshot(profilesRef, (snapshot) => {
                const profiles = snapshot.docs.map(doc => doc.data());
                renderLeaderboard(profiles, 'leaderboard-table-body');
            }, (error) => {
                console.error("Error listening for student profiles:", error);
                document.getElementById('leaderboard-table-body').innerHTML = '<tr><td colspan="4" class="text-center p-4 text-red-500">เกิดข้อผิดพลาดในการโหลดข้อมูลผู้นำ</td></tr>';
            });
        }

        function renderLeaderboard(profiles, tableBodyId) {
            const tableBody = document.getElementById(tableBodyId);
            if (!profiles || profiles.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="4" class="text-center p-4 text-gray-500">ยังไม่มีข้อมูลคะแนนสำหรับตารางผู้นำ</td></tr>';
                return;
            }

            // --- Advanced Ranking ---
            profiles.sort((a, b) => {
                // 1. Primary: Total Points
                const pointsDiff = (b.totalPoints || 0) - (a.totalPoints || 0);
                if (pointsDiff !== 0) return pointsDiff;

                // 2. Secondary: Number of Specialist (👩‍🚀) badges
                const specialistDiff = (b.badgesCount?.specialist || 0) - (a.badgesCount?.specialist || 0);
                if (specialistDiff !== 0) return specialistDiff;

                // 3. Tertiary: Number of First Try Ace (🚀) badges
                const firstTryAceDiff = (b.badgesCount?.first_try_ace || 0) - (a.badgesCount?.first_try_ace || 0);
                if (firstTryAceDiff !== 0) return firstTryAceDiff;

                // 4. Quaternary: Number of Perfect Score (👑) badges
                const perfectScoreDiff = (b.badgesCount?.perfect_score || 0) - (a.badgesCount?.perfect_score || 0);
                if (perfectScoreDiff !== 0) return perfectScoreDiff;
                
                // 5. Quinary: Number of Quick Thinker (⚡️) badges
                const quickThinkerDiff = (b.badgesCount?.quick_thinker || 0) - (a.badgesCount?.quick_thinker || 0);
                if (quickThinkerDiff !== 0) return quickThinkerDiff;

                // 6. Final: Alphabetical by name
                return a.studentName.localeCompare(b.studentName, 'th');
            });

            let html = '';
            profiles.forEach((profile, index) => {
                const rank = index + 1;
                const badgesCount = profile.badgesCount || {};

                let badgesHTML = '';
                const badgeOrder = ['specialist', 'perfect_score', 'first_try_ace', 'quick_thinker'];

                badgeOrder.forEach(badgeId => {
                    if (badgesCount[badgeId] > 0) {
                        const badgeInfo = Object.values(BADGES).find(b => b.id === badgeId);
                        if (badgeInfo) {
                            if (badgeId === 'specialist') {
                                // For specialist, just show the icon
                                badgesHTML += `
                                    <span class="inline-flex items-center mx-1" title="${badgeInfo.name}">
                                        <i class="fas ${badgeInfo.icon} text-lg"></i>
                                    </span>
                                `;
                            } else {
                                // For others, show icon and count
                                badgesHTML += `
                                    <span class="inline-flex items-center mx-1" title="${badgeInfo.name} (${badgesCount[badgeId]} ครั้ง)">
                                        <i class="fas ${badgeInfo.icon} text-lg"></i>
                                        <span class="ml-1 text-sm font-semibold">${badgesCount[badgeId]}</span>
                                    </span>
                                `;
                            }
                        }
                    }
                });

                html += `
                    <tr class="hover:bg-gray-50">
                        <td class="py-2 px-4 border-b text-center font-bold">${rank}</td>
                        <td class="py-2 px-4 border-b">${profile.studentName}</td>
                        <td class="py-2 px-4 border-b text-center font-semibold text-indigo-600">${(profile.totalPoints || 0).toLocaleString()}</td>
                        <td class="py-2 px-4 border-b">${badgesHTML || '-'}</td>
                    </tr>
                `;
            });
            tableBody.innerHTML = html;
        }
		
		// --- [ เพิ่มฟังก์ชันใหม่นี้เข้าไปทั้งหมด ] ---

/**
 * แสดงหน้าจอสำหรับโหมดวนลูปเมื่อนักเรียนสอบไม่ผ่าน (เวอร์ชันอัปเดตล่าสุด)
 * @param {number} score คะแนนที่นักเรียนทำได้
 * @param {number} totalQuestions จำนวนข้อทั้งหมด
 * @param {string} displaySetting การตั้งค่าการแสดงผล
 */
function displayLoopScreen(score, totalQuestions, displaySetting) {
    let scoreHtml = '';
    if (displaySetting !== 'show_pass_fail_only') {
        scoreHtml = `<p class="text-gray-700 mt-2">คะแนนของคุณคือ <strong class="text-xl">${score} / ${totalQuestions}</strong></p>`;
    }

    const html = `
        <div class="text-center p-8 bg-red-100 rounded-lg fade-in">
            <i class="fas fa-redo-alt text-5xl text-red-500 mb-4 animate-spin [animation-duration:2s]"></i>
            <h3 class="text-2xl font-bold text-red-800">ยังไม่ผ่านเกณฑ์นะ!</h3>
            ${scoreHtml}
            <p class="text-gray-600">สู้ๆ ลองใหม่อีกครั้งเพื่อทบทวนความเข้าใจนะ</p>
            <button id="retake-quiz-loop-btn" class="mt-6 bg-red-600 text-white py-3 px-6 rounded-lg font-semibold hover:bg-red-700 transition-transform hover:scale-105">
                ทำแบบทดสอบอีกครั้ง
            </button>
        </div>
    `;
    studentResultArea.innerHTML = html;
    studentResultArea.classList.remove('hidden');
    studentQuizArea.classList.add('hidden');

    document.getElementById('retake-quiz-loop-btn').addEventListener('click', () => {
        // --- [ เพิ่มโค้ด 1 บรรทัดนี้เข้ามาครับ ] ---
        studentResultArea.classList.add('hidden'); // สั่งซ่อนหน้าจอ "ยังไม่ผ่านเกณฑ์" ก่อน
        
        quizStartTime = new Date();
        displayQuizForStudent(currentQuizData);
    });
}

        // NEW: Render Quiz-specific Leaderboard
        // --- นำโค้ดนี้ไปวางแทนที่ฟังก์ชัน renderQuizLeaderboard เดิมทั้งหมด ---
function renderQuizLeaderboard(submissions, quizData, tableBodyId) {
    const tableBody = document.getElementById(tableBodyId);
    const isStudentView = tableBodyId === 'student-quiz-leaderboard-table-body';
    
    // --- [แก้ไข] 1. คำนวณคะแนนเต็มรวม (Weighted Max Score) ---
    let totalMaxScore = 0;
    const typeScoring = quizData.settings?.typeScoring || { mcq: 1, sa: 1, tf: 1 };
    
    if (quizData.questions && quizData.questions.length > 0) {
        quizData.questions.forEach(q => {
            const qType = q.questionType || quizData.quizType;
            let weight = 1;
            
            if (qType === 'short_answer' || qType === 'fill_in_no_choices') {
                weight = parseFloat(typeScoring.sa) || 1;
            } else if (qType === 'true_false') {
                weight = parseFloat(typeScoring.tf) || 1;
            } else {
                // multiple_choice, matching, etc.
                weight = parseFloat(typeScoring.mcq) || 1;
            }
            totalMaxScore += weight;
        });
    } else {
        totalMaxScore = 1; // กันหารด้วย 0 กรณีไม่มีข้อสอบ
    }
    // -------------------------------------------------------

    // --- ส่วนหัวตารางที่ทำให้คลิกได้ ---
    const table = document.getElementById(tableBodyId).closest('table');
    if (table && !isStudentView) {
        const thead = table.querySelector('thead');
        thead.innerHTML = `
            <tr class="bg-gray-100">
                <th class="py-2 px-4 border-b text-center w-16">อันดับ</th>
                <th class="py-2 px-4 border-b text-left sortable-header" data-sort="studentName" style="cursor: pointer;">ชื่อนักเรียน</th>
                <th class="py-2 px-4 border-b text-center sortable-header" data-sort="bestScore" style="cursor: pointer;">คะแนนดีที่สุด</th>
                <th class="py-2 px-4 border-b text-center">ผล</th>
                <th class="py-2 px-4 border-b text-center sortable-header" data-sort="points" style="cursor: pointer;">Points (ครั้งล่าสุด)</th>
                <th class="py-2 px-4 border-b text-center sortable-header" data-sort="attempts" style="cursor: pointer;">จำนวนครั้งที่ทำ</th>
                <th class="py-2 px-4 border-b text-left sortable-header" data-sort="latestSubmittedAt" style="cursor: pointer;">เวลาที่ส่งล่าสุด</th>
                <th class="py-2 px-4 border-b text-left">ป้ายรางวัล</th>
            </tr>
        `;
    }

    if (!submissions || submissions.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="${isStudentView ? 6 : 8}" class="text-center p-4 text-gray-500">ยังไม่มีนักเรียนส่งแบบทดสอบนี้</td></tr>`;
        return;
    }

    // --- ส่วน Logic การจัดเรียงข้อมูล ---
    const submissionsCopy = [...submissions]; 
    submissionsCopy.sort((a, b) => {
        let valA, valB;
        switch (quizLeaderboardSortBy) {
            case 'studentName':
                valA = a.studentName || '';
                valB = b.studentName || '';
                return quizLeaderboardSortOrder === 'asc' ? valA.localeCompare(valB, 'th') : valB.localeCompare(valA, 'th');
            case 'points':
                valA = a.points || 0;
                valB = b.points || 0;
                break;
            case 'attempts':
                valA = a.attempts?.length || 1;
                valB = b.attempts?.length || 1;
                break;
            case 'latestSubmittedAt':
                valA = new Date(a.latestSubmittedAt);
                valB = new Date(b.latestSubmittedAt);
                break;
            case 'bestScore':
            default:
                valA = a.bestScore;
                valB = b.bestScore;
                break;
        }
        if (valA < valB) return quizLeaderboardSortOrder === 'asc' ? -1 : 1;
        if (valA > valB) return quizLeaderboardSortOrder === 'asc' ? 1 : -1;
        return 0; 
    });

    // --- ส่วนการสร้างตาราง ---
    const isRemedialQuiz = quizData.isRemedial === true;
    // ปรับเกณฑ์ผ่านให้เทียบกับคะแนนเต็มรวม (ถ้าไม่ได้ตั้งค่าตายตัวไว้)
    const passingScore = quizData.settings?.passingScore ?? (totalMaxScore / 2);

    let html = '';
    submissionsCopy.forEach((sub, index) => {
        const rank = index + 1;
        let resultHtml = '<td class="py-2 px-4 border-b text-center">-</td>';
        
        // เช็คผล ผ่าน/ไม่ผ่าน
        if (isRemedialQuiz || passingScore !== -1) {
            let isPass = isRemedialQuiz ? (sub.bestScore === totalMaxScore) : (sub.bestScore >= passingScore);
            const resultClass = isPass ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
            const resultText = isPass ? 'ผ่าน' : 'ไม่ผ่าน';
            resultHtml = `<td class="py-2 px-4 border-b text-center"><span class="text-xs font-medium px-2.5 py-0.5 rounded-full ${resultClass}">${resultText}</span></td>`;
        }
        
        const latestAttempt = sub.attempts[sub.attempts.length - 1];
        const badgesHTML = (latestAttempt.badges || [])
            .map(badgeId => {
                const badgeInfo = Object.values(BADGES).find(b => b.id === badgeId);
                return badgeInfo ? `<span title="${badgeInfo.name}"><i class="fas ${badgeInfo.icon} mx-1 text-lg"></i></span>` : '';
            }).join('');
            
        // --- [แก้ไข] ใช้ totalMaxScore แทน totalQuestions ที่เป็นจำนวนข้อ ---
        html += `
            <tr class="hover:bg-gray-50">
                <td class="py-2 px-4 border-b text-center font-bold">${rank}</td>
                <td class="py-2 px-4 border-b">${sub.studentName}</td>
                <td class="py-2 px-4 border-b text-center font-bold text-green-600">${sub.bestScore} / ${totalMaxScore}</td>
                ${resultHtml}
                <td class="py-2 px-4 border-b text-center font-semibold text-blue-600">${(sub.points || 0).toLocaleString()}</td>
                ${isStudentView ? "" : `<td class="py-2 px-4 border-b text-center">${sub.attempts?.length || 1}</td>`}
                ${isStudentView ? "" : `<td class="py-2 px-4 border-b text-sm text-gray-600">${new Date(sub.latestSubmittedAt).toLocaleString('th-TH')}</td>`}
                <td class="py-2 px-4 border-b">${badgesHTML || '-'}</td>
            </tr>
        `;
    });
    tableBody.innerHTML = html;

    // --- ส่วนแสดงสัญลักษณ์ ▲ ▼ ---
    if (table && !isStudentView) {
        table.querySelectorAll('thead .sortable-header').forEach(th => {
            const indicator = th.querySelector('.sort-indicator');
            if (indicator) indicator.remove(); 
            if (th.dataset.sort === quizLeaderboardSortBy) {
                th.innerHTML += `<span class="sort-indicator ml-2">${quizLeaderboardSortOrder === 'asc' ? '▲' : '▼'}</span>`;
            }
        });
    }
}

/**
 * จัดการการลบผลการสอบของนักเรียนรายบุคคล
 * @param {string} studentName - ชื่อของนักเรียนที่ต้องการลบผลสอบ
 */
async function handleDeleteSubmission(studentName) {
    if (!currentQuizData || !currentQuizData.id || !studentName) {
        showMessage("ข้อมูลไม่เพียงพอที่จะลบผลสอบ");
        return;
    }

    showConfirmation(
        `คุณแน่ใจหรือไม่ว่าต้องการลบผลการสอบของ "${studentName}"? นักเรียนจะต้องทำแบบทดสอบนี้ใหม่อีกครั้ง`,
        async () => {
            const quizId = currentQuizData.id;
            const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`, studentName);
            
            try {
                await deleteDoc(submissionRef);
                showMessage(`ลบผลสอบของ ${studentName} สำเร็จ`);
                // ระบบจะ re-render ตารางให้อัตโนมัติเพราะ onSnapshot ทำงานอยู่
            } catch (error) {
                console.error("Error deleting submission:", error);
                showMessage("เกิดข้อผิดพลาดในการลบผลสอบ");
            }
        }
    );
}

        // --- Student Flow ---
        async function handleLoadQuiz() {
    const quizIdInput = document.getElementById('quiz-id-input');
    const quizId = quizIdInput.value.trim();
    if (!quizId) {
        showMessage("กรุณาป้อนรหัสแบบทดสอบ");
        return;
    }

    loadQuizBtn.disabled = true;
    loadQuizBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>กำลังโหลด...';

    try {
        const quizDocRef = doc(db, `artifacts/${appId}/public/data/quizzes`, quizId);
        const quizDocSnap = await getDoc(quizDocRef);

        if (!quizDocSnap.exists()) {
            showMessage("ไม่พบแบบทดสอบสำหรับรหัสนี้");
            return;
        }

        currentQuizData = { id: quizDocSnap.id, ...quizDocSnap.data() };

        // Check Quiz Status
        const status = currentQuizData.status || 'active';
        const now = new Date();
        if (status === 'inactive') {
            showMessage("แบบทดสอบนี้ปิดใช้งานอยู่");
            return;
        }
        if (status === 'scheduled') {
            const startTime = currentQuizData.startTime ? new Date(currentQuizData.startTime) : null;
            const endTime = currentQuizData.endTime ? new Date(currentQuizData.endTime) : null;
            
            if (startTime && now < startTime) {
                showMessage(`แบบทดสอบนี้จะเปิดให้ทำในวันที่ ${startTime.toLocaleString('th-TH', { hour12: false })}`);
                return;
            }
            if (endTime && now > endTime) {
                showMessage("แบบทดสอบนี้หมดเวลาแล้ว");
                return;
            }
        }
        
        const projectId = currentQuizData.projectId;
        currentProjectId = projectId;   // <-- เพิ่มบรรทัดนี้
        const projectDocRef = doc(db, `artifacts/${appId}/public/data/projects`, projectId);
        const projectDocSnap = await getDoc(projectDocRef);

        if (!projectDocSnap.exists()) {
            showMessage("เกิดข้อผิดพลาด: ไม่พบโปรเจคที่เกี่ยวข้องกับแบบทดสอบนี้");
            return;
        }
        
        const projectData = projectDocSnap.data();
        currentStudentProjectData = projectData; 
        displayStudentNameSelector(projectData.students, currentQuizData.topic);

    } catch (error) {
        console.error("Error loading quiz for student:", error);
        showMessage("เกิดข้อผิดพลาดในการโหลดแบบทดสอบ");
    } finally {
        loadQuizBtn.disabled = false;
        loadQuizBtn.innerHTML = '<i class="fas fa-search mr-2"></i>ค้นหาแบบทดสอบ';
    }
}

async function handleManualEditPoints(studentName, newPoints) {
    if (!currentQuizData || !currentQuizData.id) return;

    const quizId = currentQuizData.id;
    const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`, studentName);

    try {
        // 1. อัปเดต Points ที่หน้า Submission
        // เราจะอัปเดตที่ root level และ attempt ล่าสุดด้วย เพื่อความชัวร์
        const submissionSnap = await getDoc(submissionRef);
        if (!submissionSnap.exists()) return;

        const data = submissionSnap.data();
        const attempts = data.attempts || [];
        
        // อัปเดต points ใน attempt ล่าสุด (ถ้ามี)
        if (attempts.length > 0) {
            attempts[attempts.length - 1].points = newPoints;
            // เพิ่ม Flag พิเศษ เพื่อป้องกันการคำนวณทับในอนาคต
            attempts[attempts.length - 1].isSyncGame = true; 
        }

        await updateDoc(submissionRef, {
            points: newPoints, // อัปเดตค่าหลัก
            attempts: attempts
        });

        // 2. สำคัญมาก! สั่งคำนวณ Leaderboard ใหม่ทันที
        if (currentProjectData && currentProjectId) {
            await updateStudentProfile(currentProjectId, studentName);
        }

        showMessage(`แก้ไข Points ของ ${studentName} เป็น ${newPoints} สำเร็จ!`);

    } catch (error) {
        console.error("Error updating points:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึกคะแนน");
    }
}

async function handleJoinLiveGame() {
    const pinInput = document.getElementById('game-pin-input');
    const nicknameInput = document.getElementById('nickname-input');
    const joinBtn = document.getElementById('confirm-join-game-btn');

    const gamePin = pinInput.value.trim();
    const nickname = nicknameInput.value.trim();

    if (!gamePin || !nickname) {
        showMessage("กรุณากรอกรหัสเข้าร่วมและชื่อเล่นให้ครบถ้วน");
        return;
    }

    joinBtn.disabled = true;
    joinBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>กำลังตรวจสอบ...';

    try {
        // 1. หาห้องเกมจาก PIN
        const gamesRef = collection(db, `artifacts/${appId}/public/data/syncGames`);
        // หาได้ทั้งห้องที่รอ (lobby) และห้องที่เริ่มไปแล้ว (question, summary, results)
        const q = query(gamesRef, where("pin", "==", gamePin), where("status", "in", ["lobby", "question", "summary", "results"]));
        const snapshot = await getDocs(q);

        if (snapshot.empty) {
            // ถ้าไม่เจอใน Sync Game ลองไปหาใน Team Game (เผื่อเข้าผิดโหมด)
            const teamGamesRef = collection(db, `artifacts/${appId}/public/data/liveGames`); // team/live race uses liveGames collection
            const qTeam = query(teamGamesRef, where("gamePin", "==", gamePin));
            const snapTeam = await getDocs(qTeam);
            
            if (!snapTeam.empty) {
                // ถ้าเจอใน Team Mode ให้ไปใช้ Logic เดิม
                await proceedWithTeamQuizJoin(snapTeam.docs[0]);
                return;
            }
            
            showMessage("ไม่พบห้องเกมด้วยรหัสนี้ หรือเกมจบไปแล้ว");
            return;
        }

        const gameDoc = snapshot.docs[0];
        currentLiveGameId = gameDoc.id;
        const gameData = gameDoc.data();

        // 2. เชื่อมโยงข้อมูล Quiz และ Project
        const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, gameData.quizId);
        const quizSnap = await getDoc(quizRef);
        if (quizSnap.exists()) {
             currentQuizData = gameData.shuffledQuiz; // ใช้ Quiz ที่สลับแล้วจากในห้อง
        }

        // 3. [จุดที่แก้ไข] ตรวจสอบว่าผู้เล่นคนนี้มีอยู่แล้วหรือยัง
        const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, nickname);
        const playerSnap = await getDoc(playerRef);

        if (playerSnap.exists()) {
            // === กรณีเก่า (Re-join) ===
            joinBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>กำลังกู้คืนข้อมูล...';
            
            // แค่อัปเดตสถานะเป็น active ห้ามรีเซ็ตคะแนน
            await updateDoc(playerRef, { status: 'active' });
            
            showMessage(`ยินดีต้อนรับกลับ ${nickname}! ข้อมูลของคุณถูกกู้คืนแล้ว`);
        } else {
            // === กรณีใหม่ (New Join) ===
            // ตรวจสอบว่าเกมเริ่มไปหรือยัง ถ้าเริ่มไปแล้วอาจจะห้ามเข้า หรือเข้าแบบ 0 คะแนน
            if (gameData.status !== 'lobby') {
                // (Optional: ถ้าอยากให้เข้าได้แต่เริ่ม 0 ก็ลบ Block นี้ทิ้ง)
                // แต่ปกติตลาดมืดถ้าเข้ามาทีหลังจะเสียเปรียบมาก
            }

            joinBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>กำลังเข้าร่วม...';
            
            const newPlayerData = {
                name: nickname,
                score: 0,
                totalPoints: 0,
                pointsLastRound: 0,
                powerups: {
                    fiftyFifty: 0, secondChance: 0, buyTime: 0, poll: 0,
                    wagerMultiplier: 0, forceConfident: 0, cutOne: 0, insurance: 0, strategyScan: 0, jinx: 0, revealOptions: 0
                },
                answered: false,
                status: 'active',
                answers: [],
                joinedAt: serverTimestamp(),
                isJinxed: false,
                isForcedConfident: false,
                timeBonusThisQuestion: 0
            };
            await setDoc(playerRef, newPlayerData);
        }

        // 4. ตั้งค่าตัวแปร Local และเริ่มฟังข้อมูล
        currentStudentName = nickname;
        localTeamPlayers = [nickname];
        
        showView('live-game');
        listenForSyncGameUpdates();

        // เก็บ Session เพื่อกัน Refresh แล้วหลุด
        const gameState = {
            gameId: currentLiveGameId,
            mode: 'sync',
            players: localTeamPlayers,
            turnIndex: 0
        };
        sessionStorage.setItem('activeGameSession', JSON.stringify(gameState));

    } catch (error) {
        console.error("Error joining live game:", error);
        showMessage("เกิดข้อผิดพลาดในการเข้าร่วม: " + error.message);
    } finally {
        joinBtn.disabled = false;
        if (joinBtn.innerHTML.includes('spinner')) joinBtn.innerHTML = '<i class="fas fa-sign-in-alt mr-2"></i>เข้าร่วม';
    }
}

        function displayStudentNameSelector(students, topic) {
            const studentNameSelect = document.getElementById('student-name-select');
            document.getElementById('student-quiz-topic').textContent = `แบบทดสอบ: ${topic}`;
            
            if (!students || students.length === 0) {
                studentNameSelect.innerHTML = `<option value="">ไม่พบรายชื่อนักเรียนในโปรเจคนี้</option>`;
                startQuizBtn.disabled = true;
            } else {
                studentNameSelect.innerHTML = '<option value="">-- กรุณาเลือกชื่อ --</option>';
                students.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    studentNameSelect.appendChild(option);
                });
                startQuizBtn.disabled = false;
            }

            studentInitialView.classList.add('hidden');
            studentNameSelectionView.classList.remove('hidden');
        }

        // Helper to shuffle arrays
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
		
		/**
         * สร้างสำเนาของแบบทดสอบและทำการสลับข้อ/ตัวเลือกตามการตั้งค่า
         * @param {object} originalQuizData - ข้อมูลแบบทดสอบต้นฉบับ
         * @returns {object} ข้อมูลแบบทดสอบชุดใหม่ที่ผ่านการสลับแล้ว
         */
        function getShuffledQuiz(originalQuizData) {
            // สร้างสำเนาข้อมูลทั้งหมดเพื่อไม่ให้กระทบต้นฉบับ
            let processedQuiz = JSON.parse(JSON.stringify(originalQuizData)); 
            const shuffleSetting = processedQuiz.settings?.shuffle || 'none';

            if (shuffleSetting === 'none') {
                return processedQuiz; // ถ้าไม่สลับ ก็ส่งข้อมูลเดิมกลับไปเลย
            }

            // 1. สลับลำดับคำถาม (ถ้าตั้งค่าไว้)
            if (shuffleSetting === 'questions_only' || shuffleSetting === 'both') {
                shuffleArray(processedQuiz.questions);
            }

            // 2. สลับลำดับตัวเลือกในแต่ละคำถาม (ถ้าตั้งค่าไว้)
            if (shuffleSetting === 'choices_only' || shuffleSetting === 'both') {
                processedQuiz.questions.forEach(q => {
                    const questionType = q.questionType || processedQuiz.quizType;
                    // สลับตัวเลือกสำหรับ Multiple Choice
                    if (q.options) { 
                        let optionsToShuffle = q.options.map((opt, index) => ({
                            text: opt,
                            isCorrect: index === q.correctAnswerIndex
                        }));
                        shuffleArray(optionsToShuffle);
                        // อัปเดต options และ correctAnswerIndex ใหม่ตามลำดับที่สลับแล้ว
                        q.options = optionsToShuffle.map(opt => opt.text);
                        q.correctAnswerIndex = optionsToShuffle.findIndex(opt => opt.isCorrect);
                    }
                    // สลับตัวเลือกสำหรับ Matching
                    if (questionType === 'matching_item' && q.allResponses) {
                        shuffleArray(q.allResponses);
                    }
                });
            }
            
            return processedQuiz;
        }

function displayQuizForStudent(quizData) {
    studentQuizArea.classList.remove('hidden');
    currentDisplayedQuiz = getShuffledQuiz(quizData);

    // --- [ เริ่มส่วนที่แก้ไข ] ---
    // ตรวจสอบก่อนว่าไม่ใช่โหมดทดสอบของ Admin
    if (currentMode !== 'admin-testing') {
        // ถ้าไม่ใชโหมดทดสอบ ให้เปิดใช้งานฟีเจอร์ป้องกันทั้งหมด
        requestWakeLock(); // ป้องกันจอดับ

        isQuizActive = true;
        cheatAttempts = 0;
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('visibilitychange', handleVisibilityChange);
        enterFullscreen(); // เข้าโหมดเต็มจอ

        // เริ่มต้นการจับเวลาสำหรับหรี่แสง
        window.addEventListener('mousemove', resetDimTimer);
        window.addEventListener('mousedown', resetDimTimer);
        window.addEventListener('touchstart', resetDimTimer);
        window.addEventListener('keydown', resetDimTimer);
        resetDimTimer(); // เริ่มนับครั้งแรก
    }
    // --- [ สิ้นสุดส่วนที่แก้ไข ] ---

    const timerMode = currentDisplayedQuiz.settings?.timerMode || 'none';
    if (timerMode === 'whole_quiz') {
        renderFullQuizForm();
        startWholeQuizTimer(currentDisplayedQuiz.settings.timerDuration);
    } else if (timerMode === 'per_question') {
        currentQuestionIndex = 0;
        studentAnswersPerQuestion = [];
        renderPerQuestionView();
    } else {
        renderFullQuizForm();
    }
}

window.toggleMathDropdown = function(index) {
    const list = document.getElementById(`dropdown-list-${index}`);
    const allLists = document.querySelectorAll('[id^="dropdown-list-"]');
    
    // ปิด Dropdown อื่นๆ ก่อน
    allLists.forEach(el => {
        if (el.id !== `dropdown-list-${index}`) el.classList.add('hidden');
    });

    // สลับเปิด/ปิด อันที่คลิก
    if (list) list.classList.toggle('hidden');
};

window.selectMathOption = function(qIndex, optIndex) {
    const quiz = currentDisplayedQuiz;
    if (!quiz) return;

    const question = quiz.questions[qIndex];
    const selectedValue = question.allResponses[optIndex];

    // 1. อัปเดตค่าลงใน Hidden Input (เพื่อส่งฟอร์ม)
    const input = document.getElementById(`input-${qIndex}`);
    if (input) input.value = selectedValue;

    // 2. อัปเดตข้อความบนปุ่ม และสั่ง Render MathJax
    const displayBtn = document.getElementById(`selected-text-${qIndex}`);
    if (displayBtn) {
        displayBtn.innerHTML = selectedValue; // ใส่สูตรลงไป
        if (window.MathJax) MathJax.typesetPromise([displayBtn]); // แปลงสูตรทันที
        displayBtn.classList.add('text-indigo-700', 'font-bold'); // เปลี่ยนสีให้รู้ว่าเลือกแล้ว
    }

    // 3. ปิด Dropdown
    const list = document.getElementById(`dropdown-list-${qIndex}`);
    if (list) list.classList.add('hidden');
};

// ปิด Dropdown เมื่อคลิกที่อื่น
document.addEventListener('click', (e) => {
    if (!e.target.closest('.custom-math-dropdown')) {
        document.querySelectorAll('[id^="dropdown-list-"]').forEach(el => el.classList.add('hidden'));
    }
});
        
function renderFullQuizForm() {
    const confidenceScoringEnabled = currentDisplayedQuiz.settings?.isConfidenceScoringEnabled === true;
    const confidenceMode = currentDisplayedQuiz.settings?.confidenceMode || 'checkbox';
    
    // ตัวแปรสำหรับเช็คว่าแสดงหัวข้อ "จับคู่" ไปหรือยัง
    let hasShownMatchingHeader = false;

    let html = `
         <div id="timer-container" class="mb-4"></div>
         <div class="flex justify-between items-center mb-4">
             <h3 class="text-xl font-bold">แบบทดสอบ: ${currentDisplayedQuiz.topic}</h3>
             ${currentMode === 'admin-testing' ? '<button id="cancel-test-btn" class="text-sm text-gray-500 hover:text-red-600 font-semibold py-1 px-2 rounded-md hover:bg-red-50"><i class="fas fa-times-circle mr-1"></i> ยกเลิกการทดสอบ</button>' : ''}
         </div>
         <form id="quiz-form">
    `;
    
    currentDisplayedQuiz.questions.forEach((q, questionIndex) => {
        const questionType = q.questionType || currentDisplayedQuiz.quizType;
        const zIndexStyle = `z-index: ${100 - questionIndex};`;
        
        // --- [ส่วนที่ 1] แสดงหัวข้อใหญ่ "จับคู่..." แค่ครั้งเดียว ---
        if (questionType === 'matching_item' && !hasShownMatchingHeader) {
            html += `
                <div class="w-full mb-6 p-4 bg-indigo-50 border-l-4 border-indigo-500 text-indigo-900 rounded-r-lg shadow-sm">
                    <h4 class="text-lg font-bold flex items-center">
                        <i class="fas fa-exchange-alt mr-3"></i> คำชี้แจง: จับคู่ข้อความต่อไปนี้ให้ถูกต้อง
                    </h4>
                </div>
            `;
            hasShownMatchingHeader = true; // ปักธงว่าแสดงแล้ว
        }
        // -----------------------------------------------------

        html += `<div class="mb-6 p-4 border rounded-lg bg-gray-50 relative" style="${zIndexStyle}">`;

        // --- [ส่วนที่ 2] ส่วนหัวข้อคำถาม (ถ้าไม่ใช่ Matching ให้แสดงปกติ) ---
        if (questionType !== 'matching_item') {
            html += `
                <div class="font-semibold mb-3">
                    <p>${questionIndex + 1}. ${q.instructions || q.questionText}</p>
                    ${q.imageCode ? `<div class="my-4 flex justify-center">${q.imageCode}</div>` : ''}
                </div>
            `;
        }
        // -------------------------------------------------------------
        
        html += `<div class="space-y-2">`;
        
        // 1. Matching (Custom Dropdown)
        if (questionType === 'matching_item' && q.allResponses) {
             html += `
                <div class="flex flex-col sm:flex-row sm:items-center gap-4">
                    <div class="w-full sm:w-1/2 p-3 bg-blue-50 rounded border border-blue-100 font-semibold text-blue-800 flex items-start gap-3">
                        <span class="font-bold text-indigo-600 text-lg mt-[-2px]">${questionIndex + 1}.</span>
                        <span class="leading-snug">${q.stem}</span>
                    </div>

                    <div class="w-full sm:w-1/2 relative custom-math-dropdown">
                        <input type="hidden" name="question${questionIndex}" id="input-${questionIndex}" required>
                        
                        <button type="button" 
                                class="w-full p-3 border border-gray-300 rounded-lg bg-white text-left flex justify-between items-center hover:border-indigo-500 focus:ring-2 focus:ring-indigo-200 transition-all"
                                onclick="window.toggleMathDropdown(${questionIndex})">
                            <span id="selected-text-${questionIndex}" class="truncate text-gray-500">-- เลือกคำตอบ --</span>
                            <i class="fas fa-chevron-down text-gray-400 text-sm"></i>
                        </button>

                        <div id="dropdown-list-${questionIndex}" 
                             class="hidden absolute top-full left-0 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-xl max-h-60 overflow-y-auto z-50">
                            ${q.allResponses.map((resp, optIndex) => `
                                <div class="p-3 border-b border-gray-100 hover:bg-indigo-50 cursor-pointer transition-colors text-sm"
                                     onclick="window.selectMathOption(${questionIndex}, ${optIndex})">
                                    ${resp}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        
        // 2. True/False
        } else if (questionType === 'true_false') {
            html += `<div><input type="radio" id="q${questionIndex}_opt0" name="question${questionIndex}" value="true" class="mr-2 accent-indigo-600" required><label for="q${questionIndex}_opt0">ใช่</label></div>`;
            html += `<div><input type="radio" id="q${questionIndex}_opt1" name="question${questionIndex}" value="false" class="mr-2 accent-indigo-600" required><label for="q${questionIndex}_opt1">ไม่ใช่</label></div>`;

        // 3. Multiple Choice
        } else if (q.options && Array.isArray(q.options) && q.options.length > 0) {
            html += q.options.map((opt, i) => `
                <div>
                    <input type="radio" id="q${questionIndex}_opt${i}" name="question${questionIndex}" value="${i}" class="mr-2 accent-indigo-600" required>
                    <label for="q${questionIndex}_opt${i}">${opt}</label>
                </div>
            `).join('');
            
        // 4. Short Answer
        } else {
            html += `<textarea name="question${questionIndex}" class="w-full p-2 border border-gray-300 rounded-lg" rows="3" required placeholder="พิมพ์คำตอบของคุณ..."></textarea>`;
        }

        html += `</div>`;

        if (confidenceScoringEnabled) {
            html += `<div class="mt-4 pt-3 border-t border-gray-200">`;
            if (confidenceMode === 'mandatory') {
                html += `
                    <p class="text-sm font-medium text-gray-700 mb-2">คุณมั่นใจในคำตอบข้อนี้แค่ไหน?:</p>
                    <input type="hidden" id="confidence-input-${questionIndex}" name="confidence${questionIndex}" value="">
                    <div class="flex gap-2">
                        <button type="button" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold confidence-choice-btn confident" data-question-index="${questionIndex}" data-value="confident">
                            <i class="far fa-smile-beam mr-2"></i>มั่นใจ
                        </button>
                        <button type="button" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold confidence-choice-btn not-confident" data-question-index="${questionIndex}" data-value="not_confident">
                            <i class="far fa-meh mr-2"></i>ไม่มั่นใจ
                        </button>
                    </div>
                `;
            } else {
                html += `
                    <input type="checkbox" id="confidence${questionIndex}" name="confidence${questionIndex}" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="confidence${questionIndex}" class="ml-2 text-sm font-medium text-gray-700 cursor-pointer">ฉันมั่นใจในคำตอบข้อนี้</label>
                `;
            }
            html += `</div>`;
        }

        html += `</div>`;
    });
    
    html += `<button type="submit" class="w-full mt-4 bg-purple-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-purple-700">
                 <i class="fas fa-check-circle mr-2"></i>ส่งคำตอบ
                </button>`;
    html += `</form>`;
    studentQuizArea.innerHTML = html;
    
    if (currentMode === 'admin-testing') {
        const cancelBtn = document.getElementById('cancel-test-btn');
        if(cancelBtn) cancelBtn.addEventListener('click', cancelAdminTest);
    }

    const quizForm = document.getElementById('quiz-form');
    if (quizForm) {
        quizForm.addEventListener('submit', handleSubmitQuiz);
        quizForm.addEventListener('click', (e) => {
            if (e.target.classList.contains('confidence-choice-btn')) {
                const btn = e.target;
                const index = btn.dataset.questionIndex;
                const value = btn.dataset.value;
                document.getElementById(`confidence-input-${index}`).value = value;
                const parent = btn.parentElement;
                parent.querySelectorAll('.confidence-choice-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            }
        });
    }

    if (window.MathJax) {
        setTimeout(() => {
            window.MathJax.typesetPromise([studentQuizArea]);
        }, 50);
    }
}

async function handleSubmitQuiz(event) {
    if(event) event.preventDefault();
    if(quizTimerInterval) clearInterval(quizTimerInterval);
    
    const form = document.getElementById('quiz-form');
    if (!form) return;
    
    // --- Logic ใหม่: ตรวจสอบก่อนส่ง ---
    const confidenceEnabled = currentDisplayedQuiz.settings?.isConfidenceScoringEnabled === true;
    const confidenceMode = currentDisplayedQuiz.settings?.confidenceMode || 'checkbox';

    if (confidenceEnabled && confidenceMode === 'mandatory') {
        let allConfidenceSelected = true;
        for (let i = 0; i < currentDisplayedQuiz.questions.length; i++) {
            const confidenceInput = form.querySelector(`#confidence-input-${i}`);
            if (!confidenceInput || confidenceInput.value === '') {
                allConfidenceSelected = false;
                break;
            }
        }
        if (!allConfidenceSelected) {
            showMessage("กรุณาเลือกระดับความมั่นใจให้ครบทุกข้อก่อนส่งคำตอบครับ");
            return; // หยุดการทำงาน
        }
    }
    // --- สิ้นสุด Logic ใหม่ ---
    
    const submitButton = form.querySelector('button[type="submit"]');
    const hasShortAnswer = currentDisplayedQuiz.questions.some(q => q.questionType === 'short_answer');

    if(submitButton) {
        submitButton.disabled = true;
        submitButton.innerHTML = hasShortAnswer 
            ? '<i class="fas fa-spinner fa-spin mr-2"></i>AI กำลังตรวจคำตอบ...'
            : '<i class="fas fa-spinner fa-spin mr-2"></i>กำลังส่งคำตอบ...';
    }
    
    const formData = new FormData(form);
    
    const userAnswers = currentDisplayedQuiz.questions.map((q, questionIndex) => {
        const answer = formData.get(`question${questionIndex}`);
        
        // แก้ไขการอ่านค่า wasConfident ให้รองรับทั้ง 2 โหมด
        let wasConfident;
        if (confidenceMode === 'mandatory') {
            wasConfident = formData.get(`confidence${questionIndex}`); // จะได้ 'confident' หรือ 'not_confident'
        } else {
            wasConfident = formData.get(`confidence${questionIndex}`) === 'on'; // จะได้ true หรือ false
        }
        
        // ... (ส่วนที่เหลือของฟังก์ชันเหมือนเดิม) ...
        let parsedAnswer = null;
        if (answer !== null && answer !== undefined) {
             const questionType = q.questionType || currentDisplayedQuiz.quizType;
            if (questionType === 'multiple_choice' || questionType === 'fill_in_the_blank') {
                parsedAnswer = parseInt(answer);
            } else {
                parsedAnswer = answer;
            }
        }
        return { answer: parsedAnswer, wasConfident: wasConfident };
    });
    
    const quizId = currentQuizData.id;
    const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`, currentStudentName);
    const submissionSnap = await getDoc(submissionRef);
    const existingData = submissionSnap.exists() ? submissionSnap.data() : {};
    const previousAttempts = existingData.attempts || [];

    await processAndSubmitAnswers(userAnswers, previousAttempts);
}
        
        async function gradeShortAnswerWithAI(userAnswer, idealAnswer) {
            if (!userAnswer || !idealAnswer) return false;
            try {
                const prompt = `Please evaluate if the user's answer is correct based on the ideal answer. The context is a simple quiz, so be lenient with phrasing but strict with the core concept. User Answer: "${userAnswer}". Ideal Answer: "${idealAnswer}". Respond with only "true" or "false".`;
                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                const apiKey = "AIzaSyB8ziZtJkPE4_53A4djxRjAXI_DDOP_vdg"; // API key will be provided by the environment
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error('API call failed');
                
                const result = await response.json();
                const textResponse = result.candidates[0].content.parts[0].text.trim().toLowerCase();
                return textResponse === 'true';

            } catch (error) {
                console.error("AI grading failed:", error);
                return false; // Default to incorrect if AI fails
            }
        }


async function processAndSubmitAnswers(userAnswers, previousAttempts) {
    // 1. เคลียร์สถานะหน้าจอและระบบป้องกัน
    if (typeof releaseWakeLock === 'function') releaseWakeLock();
    if (typeof stopDimTimer === 'function') stopDimTimer();
    
    try {
        if (document.fullscreenElement) {
            await document.exitFullscreen();
        }
    } catch (e) {
        console.warn("Fullscreen exit failed (safe to ignore):", e);
    }
    
    isQuizActive = false;
    document.removeEventListener('fullscreenchange', handleFullscreenChange);
    document.removeEventListener('visibilitychange', handleVisibilityChange);

    // 2. เตรียมตัวแปรสำหรับคำนวณคะแนน
    let totalRawScore = 0; // คะแนนดิบรวม (ตามน้ำหนัก)
    let totalMaxScore = 0; // คะแนนเต็มรวม (ผลรวมน้ำหนักทุกข้อ)
    let totalPoints = 0;   // คะแนน Gamification
    
    const detailedAnswers = [];
    const questions = currentDisplayedQuiz.questions;
    const totalQuestionsCount = questions.length;
    
    let correctStreak = 0;
    let earnedBadges = [];

    // 3. เริ่มวนลูปตรวจคำตอบทีละข้อ
    for (let i = 0; i < questions.length; i++) {
        const q = questions[i];
        const userAnswerData = userAnswers[i];
        const userAnswer = userAnswerData ? userAnswerData.answer : null;
        const wasConfident = userAnswerData ? userAnswerData.wasConfident : null;
        
        // ดึงข้อมูลประเภทคำถามและน้ำหนักคะแนน
        const qType = q.questionType || currentDisplayedQuiz.quizType;
        const weight = getQuestionWeight(currentDisplayedQuiz, qType);
        
        totalMaxScore += weight; // บวกคะแนนเต็มของข้อนี้เข้าไป

        let isCorrect = false;
        
        // --- ตรวจคำตอบ ---
        if (qType === 'short_answer' || qType === 'fill_in_no_choices') {
            const cleanUser = String(userAnswer || '').trim().toLowerCase();
            const cleanIdeal = String(q.idealAnswer || '').trim().toLowerCase();
            isCorrect = (cleanUser === cleanIdeal); 
        } else if (qType === 'true_false') {
            const correctBool = (q.correctAnswer === true || String(q.correctAnswer).toLowerCase() === 'true');
            const userBool = (userAnswer === 'true' || userAnswer === true);
            isCorrect = (userBool === correctBool);
        } else if (qType === 'matching_item') {
            isCorrect = (userAnswer === q.correctResponse);
        } else {
            isCorrect = (parseInt(userAnswer) === q.correctAnswerIndex);
        }

        // --- คำนวณคะแนนดิบ (Raw Score) ---
        // ตอบถูกได้เต็มน้ำหนัก ตอบผิดได้ 0
        const rawScoreForQuestion = isCorrect ? weight : 0;
        totalRawScore += rawScoreForQuestion;

        // --- คำนวณ Points (Gamification) ตามสัดส่วน ---
        // สูตร: Point พื้นฐาน = น้ำหนักคะแนน
        // มั่นใจ + ถูก = น้ำหนัก x 2
        // มั่นใจ + ผิด = น้ำหนัก x -1
        // ไม่มั่นใจ + ผิด = 0
        let pointsForThisQuestion = 0;

        if (currentDisplayedQuiz.settings?.isConfidenceScoringEnabled) {
            if (isCorrect) {
                if (wasConfident === true || wasConfident === 'confident') {
                    pointsForThisQuestion = weight * 2;
                } else {
                    pointsForThisQuestion = weight;
                }
            } else {
                if (wasConfident === true || wasConfident === 'confident') {
                    pointsForThisQuestion = -weight;
                } else {
                    pointsForThisQuestion = 0;
                }
            }
        } else {
            // ถ้าปิดโหมดความมั่นใจ ได้ Point เท่ากับคะแนนดิบ
            pointsForThisQuestion = rawScoreForQuestion;
        }
        
        totalPoints += pointsForThisQuestion;

        if (isCorrect) {
            correctStreak++;
            if (correctStreak === 3) earnedBadges.push(BADGES.ON_FIRE.id);
        } else {
            correctStreak = 0;
        }
        
        let answerText = null;
        if (q.options && (qType === 'multiple_choice' || qType === 'fill_in_with_choices') && userAnswer !== null) {
            answerText = q.options[userAnswer];
        } else {
            answerText = userAnswer;
        }

        detailedAnswers.push({
            questionId: q.id,
            answer: userAnswer, 
            answerText: answerText, 
            isCorrect: isCorrect,
            wasConfident: wasConfident,
            pointsAwarded: pointsForThisQuestion,
            originalQuestionText: q.stem || q.questionText
        });
    }

    // 4. คำนวณเหรียญรางวัลและสถิติ
    // ใช้เกณฑ์ "ผ่าน" โดยเทียบจากคะแนนเต็มรวม (totalMaxScore)
    // ถ้าไม่ได้ตั้งค่า passingScore ไว้ ให้ใช้ 50% ของคะแนนเต็มรวมเป็นเกณฑ์
    const userDefinedPassingScore = currentDisplayedQuiz.settings?.passingScore;
    const passingThreshold = (userDefinedPassingScore !== undefined && userDefinedPassingScore !== null) 
                             ? userDefinedPassingScore 
                             : (totalMaxScore / 2);
    
    // เช็คคะแนนเต็ม (Perfect Score)
    if (totalRawScore === totalMaxScore && totalMaxScore > 0 && !currentDisplayedQuiz.isRemedial) {
        earnedBadges.push(BADGES.PERFECT_SCORE.id);
    }
    
    // ... (ส่วน Timer Badges คงเดิม) ...
    const timerMode = currentDisplayedQuiz.settings?.timerMode;
    if (timerMode === 'whole_quiz' && quizStartTime) {
        const timeTaken = (new Date() - quizStartTime) / 1000;
        const timeAllowed = currentDisplayedQuiz.settings.timerDuration * 60;
        if (totalRawScore >= passingThreshold && timeTaken < timeAllowed / 2) {
            earnedBadges.push(BADGES.QUICK_THINKER.id);
        }
    }

    if (previousAttempts.length === 0 && totalRawScore === totalMaxScore && totalMaxScore > 0) {
        earnedBadges.push(BADGES.FIRST_TRY_ACE.id);
    }
    if (previousAttempts.length > 0) {
        const firstAttemptScore = previousAttempts[0].score;
        // เช็คพัฒนาการ (ถ้าครั้งแรกไม่ผ่าน และครั้งนี้ผ่าน)
        if (firstAttemptScore < passingThreshold && totalRawScore >= passingThreshold) {
            const hasComebackBadge = previousAttempts.some(attempt => (attempt.badges || []).includes(BADGES.COMEBACK_KING.id));
            if (!hasComebackBadge) {
                earnedBadges.push(BADGES.COMEBACK_KING.id);
            }
        }
    }
    if (previousAttempts.length === 4) {
        earnedBadges.push(BADGES.PERSEVERANCE.id);
    }
    
    const displaySetting = currentDisplayedQuiz.settings.resultsDisplay;
    
    if (currentMode === 'admin-testing') {
        // ส่ง totalMaxScore ไปเพื่อให้หน้าผลลัพธ์แสดง 25 / 25
        handleResultDisplay(displaySetting, totalRawScore, totalPoints, earnedBadges, detailedAnswers, totalMaxScore);
        return;
    }

    // 5. บันทึกผลลง Firestore
    const quizId = currentQuizData.id;
    const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`, currentStudentName);

    try {
        const attempts = [...previousAttempts];
        const newAttempt = {
            score: totalRawScore, // บันทึกเป็นคะแนนดิบที่มีน้ำหนักแล้ว
            points: totalPoints,
            badges: Array.from(new Set(earnedBadges)),
            submittedAt: new Date().toISOString(),
            answers: detailedAnswers
        };
        attempts.push(newAttempt);

        const firstScore = previousAttempts.length === 0 ? totalRawScore : (previousAttempts[0].score || 0);
        const bestScore = Math.max(...attempts.map(a => a.score));

        await setDoc(submissionRef, {
            studentName: currentStudentName,
            // สำคัญ: บันทึก "คะแนนเต็มรวม" ลงในช่อง totalQuestions เพื่อให้หน้า Dashboard แสดงผลถูก (เช่น 25)
            totalQuestions: totalMaxScore, 
            totalQuestionsCount: totalQuestionsCount, // เก็บจำนวนข้อแยกไว้ (เผื่อใช้)
            attempts: attempts,
            firstScore: firstScore,
            bestScore: bestScore,
            latestScore: totalRawScore,
            points: totalPoints,
            latestSubmittedAt: newAttempt.submittedAt
        }, { merge: true });

        await updateStudentProfile(currentQuizData.projectId, currentStudentName);
        
        // ส่ง totalMaxScore ไปเป็น parameter สุดท้าย เพื่อให้แสดงผลเป็น X / MaxScore
        handleResultDisplay(displaySetting, totalRawScore, totalPoints, earnedBadges, detailedAnswers, totalMaxScore);
        
    } catch (error) {
        console.error("Error saving submission:", error);
        showMessage("เกิดข้อผิดพลาดในการบันทึกคำตอบของคุณ");
    }
}

function getQuestionWeight(quizData, questionType) {
    const typeScoring = quizData.settings?.typeScoring || { mcq: 1, sa: 1, tf: 1 };
    
    // แปลงค่าเป็น Float เพื่อความชัวร์ (กรณีรับมาเป็น String)
    const getVal = (val) => {
        const num = parseFloat(val);
        return isNaN(num) ? 1 : num;
    };

    if (questionType === 'short_answer' || questionType === 'fill_in_no_choices') {
        return getVal(typeScoring.sa);
    } else if (questionType === 'true_false') {
        return getVal(typeScoring.tf);
    } else {
        // multiple_choice, matching, etc.
        return getVal(typeScoring.mcq);
    }
}
        
        async function updateStudentProfile(projectId, studentName) {
    const profileRef = doc(db, `artifacts/${appId}/public/data/projects/${projectId}/studentProfiles`, studentName);

    try {
        // ดึงข้อมูล Quiz ทั้งหมดใน Project (ยอมเสีย Read ตรงนี้เพื่อให้ข้อมูลแม่นยำเวลาสั่ง Recalculate)
        const quizzesQuery = query(
            collection(db, `artifacts/${appId}/public/data/quizzes`),
            where("projectId", "==", projectId)
        );
        const quizzesSnapshot = await getDocs(quizzesQuery);
        const quizIds = quizzesSnapshot.docs.map(doc => doc.id);

        let calculatedTotalPoints = 0;
        const finalBadgesCount = {};

        // ใช้ Promise.all เพื่อดึงข้อมูลพร้อมกัน (เร็วกว่า แต่เสีย Read เท่าเดิม)
        const submissionPromises = quizIds.map(quizId => 
            getDoc(doc(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`, studentName))
        );
        
        const submissionSnaps = await Promise.all(submissionPromises);

        submissionSnaps.forEach(docSnap => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                // ใช้ Points ที่ดีที่สุดของแต่ละ Quiz มารวมกัน
                calculatedTotalPoints += (data.points || 0);

                // นับ Badge
                if (data.attempts) {
                    data.attempts.forEach(attempt => {
                        if (attempt.badges) {
                            attempt.badges.forEach(b => {
                                // นับเฉพาะ Badge ที่ได้จริงๆ ไม่ใช่นับซ้ำซ้อน (อันนี้ Logic เดิมของคุณอาจจะนับซ้ำ)
                                // แต่เพื่อความง่าย เราจะนับรวมไปก่อนตาม Logic เดิม
                            });
                        }
                    });
                    
                    // *หมายเหตุ: Logic การนับ Badge แบบละเอียดอาจซับซ้อน 
                    // ในที่นี้เราเน้นแก้เรื่อง Total Points ให้ถูกต้องที่สุดก่อน
                }
            }
        });
        
        // บันทึกทับลงไปเลย
        await setDoc(profileRef, {
            studentName: studentName,
            totalPoints: calculatedTotalPoints,
            // badgesCount: ... (ถ้าต้องการคำนวณ Badge ใหม่ต้องเขียน Logic วนลูปละเอียดกว่านี้)
        }, { merge: true });

    } catch (error) {
        console.error("Profile recalculation error:", error);
    }
}

        function startAdminTest() {
            if (!currentQuizData) {
                showMessage("ไม่พบข้อมูลแบบทดสอบสำหรับทดลอง");
                return;
            }

            // Create a temporary, deep copy of the quiz data for the test.
            // This copy already contains the correct settings from the quiz itself.
            let testQuizData = JSON.parse(JSON.stringify(currentQuizData));
            
            currentMode = 'admin-testing';
            currentStudentName = 'ผู้ควบคุม (ทดสอบ)';

            adminView.classList.add('hidden');
            studentView.classList.remove('hidden');
            studentInitialView.classList.add('hidden');
            studentNameSelectionView.classList.add('hidden');
            studentResultArea.classList.add('hidden');
            studentQuizArea.classList.remove('hidden');
            
            quizStartTime = new Date(); // Record start time for admin test
            // Pass the quiz data to the display function.
            displayQuizForStudent(testQuizData);
        }

function handleResultDisplay(displaySetting, score, points, earnedBadges, detailedAnswers, totalQuestions) {
    if (displaySetting === 'manual_release') {
        displaySubmissionConfirmation();
        return;
    }

    const passingScore = currentDisplayedQuiz.settings?.passingScore ?? Math.floor(totalQuestions / 2);
    const isAdaptive = currentDisplayedQuiz.settings?.isAdaptive ?? false;
    const loopUntilPassEnabled = currentDisplayedQuiz.settings?.loopUntilPass === true;
    const didFail = score < passingScore;
    
    // --- [ ส่วนที่แก้ไข ] ---
    // 1. ตรวจสอบก่อนว่า displaySetting เป็นรูปแบบใหม่หรือไม่
    const isNewDisplayMode = displaySetting === 'half_mark_status' || displaySetting === 'perfect_score_status';
    
    // 2. เพิ่มเงื่อนไข !isNewDisplayMode เข้าไป เพื่อไม่ให้โหมดวนลูปทำงานกับรูปแบบใหม่
    if (loopUntilPassEnabled && didFail && !isNewDisplayMode) {
    // --- [ สิ้นสุดการแก้ไข ] ---
        if (displaySetting === 'show_results_and_answers') {
            displayResultsWithAnswers(score, points, earnedBadges, detailedAnswers, totalQuestions, true);
        } else {
            displayLoopScreen(score, totalQuestions, displaySetting);
        }
        return;
    }

    if (isAdaptive && didFail) {
        startAdaptiveFlow(detailedAnswers, score, totalQuestions);
        return;
    }

    // ส่วน switch case ที่เหลือทำงานเหมือนเดิม
    switch (displaySetting) {
        case 'show_results_and_answers':
            displayResultsWithAnswers(score, points, earnedBadges, detailedAnswers, totalQuestions);
            break;
        case 'show_results_only':
            displayResultsScoreOnly(score, points, earnedBadges, totalQuestions);
            break;
        case 'show_pass_fail_only':
            displayPassFailOnly(score, totalQuestions);
            break;
        case 'half_mark_status':
            displayHalfMarkResult(score, totalQuestions);
            break;
        case 'perfect_score_status':
            displayPerfectScoreResult(score, totalQuestions);
            break;
        default:
            displaySubmissionConfirmation();
            break;
    }
}

async function generateRemedialQuiz(weaknessExplanations) {
    // แสดงสถานะกำลังโหลดให้นักเรียนทราบ
    studentReadingArea.innerHTML = `
        <div class="text-center p-8">
            <div class="loader mx-auto"></div>
            <p class="mt-4 text-gray-600">เยี่ยมเลย! AI กำลังสร้างแบบทดสอบชุดใหม่เพื่อทบทวนความเข้าใจ...</p>
        </div>
    `;

    // 1. สร้าง Prompt เพื่อให้ AI สร้างข้อสอบซ่อม
    const remedialQuizPrompt = `
        จากหัวข้อเหล่านี้ที่นักเรียนยังไม่เข้าใจ:
        ${weaknessExplanations}

        โปรดสร้างแบบทดสอบปรนัยชุดใหม่จำนวน 2 ข้อ เพื่อทดสอบความเข้าใจในหัวข้อเหล่านี้โดยเฉพาะ
        แต่ละข้อต้องมี 4 ตัวเลือก, คำตอบที่ถูกต้อง

        ให้ผลลัพธ์เป็น JSON object ที่มีโครงสร้างดังนี้:
        - topic: (string) ตั้งชื่อหัวข้อว่า "แบบทดสอบซ่อมเสริม"
        - questions: (array of objects) โดยแต่ละ object มี:
          - questionText: (string)
          - options: (array of 4 strings)
          - correctAnswerIndex: (number)
		  ${simpleMathPrompt}
    `;

    // 2. กำหนด Schema สำหรับการสร้างข้อสอบ (ใช้ mcqSchema ที่มีอยู่แล้วได้)
    const mcqSchema = {
        type: "OBJECT",
        properties: {
            questionText: { type: "STRING" },
            options: { type: "ARRAY", items: { type: "STRING" } },
            correctAnswerIndex: { type: "NUMBER" }
        },
        required: ["questionText", "options", "correctAnswerIndex"]
    };

    const remedialQuizSchema = {
        type: "OBJECT",
        properties: {
            topic: { type: "STRING" },
            questions: { type: "ARRAY", items: mcqSchema }
        },
        required: ["topic", "questions"]
    };

    try {
        // 3. เรียก API เพื่อสร้างข้อสอบซ่อม
        // เราจะใช้ฟังก์ชัน handleApiCall ที่มีอยู่แล้ว แต่ส่ง Prompt และ Schema ใหม่เข้าไป
        // และเนื่องจากเราไม่ต้องการให้ผลลัพธ์ไปแสดงในส่วนของผู้ควบคุม (admin) เราจึงต้องจัดการเอง
        const remedialQuizData = await callAnalysisApi(remedialQuizPrompt, remedialQuizSchema);
        remedialQuizData.isRemedial = true;

        // 4. เมื่อได้ข้อสอบชุดใหม่มาแล้ว ให้แสดงผลให้นักเรียนทำ
        studentReadingArea.classList.add('hidden'); // ซ่อนส่วนของเนื้อหาทบทวน
        
        // เราต้องแน่ใจว่าข้อสอบซ่อมนี้มี settings ที่เหมาะสม
        // โดยอาจจะคัดลอก settings บางอย่างมาจากข้อสอบเดิม แต่ปิดโหมด adaptive เพื่อไม่ให้วนซ้ำ
        const newQuizSettings = {
            ...currentDisplayedQuiz.settings,
            isAdaptive: false, // ปิดโหมดปรับพื้นฐานสำหรับข้อสอบซ่อม
            resultsDisplay: 'show_results_and_answers' // บังคับให้แสดงเฉลยหลังทำเสร็จ
        };
        remedialQuizData.settings = newQuizSettings;
        
        // เริ่มทำข้อสอบซ่อม
        displayQuizForStudent(remedialQuizData);

    } catch (error) {
        console.error("Remedial quiz generation failed:", error);
        showMessage("เกิดข้อผิดพลาดในการสร้างแบบทดสอบซ่อมเสริม");
        // หากล้มเหลว ให้กลับไปหน้าแรก
        showView('student');
    }
}

function displayPassFailOnly(score, totalQuestions) {
    const passingScore = currentDisplayedQuiz.settings?.passingScore ?? -1;
    const isRemedialQuiz = currentDisplayedQuiz.isRemedial === true;
    let passFailHTML = '';
    let isPass = false;

    if (isRemedialQuiz || passingScore !== -1) {
        isPass = isRemedialQuiz ? (score === totalQuestions) : (score >= passingScore);
        const resultClass = isPass ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
        const resultText = isPass ? 'ผ่าน' : 'ไม่ผ่าน';
        passFailHTML = `<div class="my-4"><span class="text-4xl font-bold px-6 py-2 rounded-full inline-block ${resultClass}">${resultText}</span></div>`;
    } else {
        passFailHTML = `<p class="mt-4 text-gray-600">(ไม่ได้ตั้งค่าเกณฑ์ผ่านสำหรับแบบทดสอบนี้)</p>`;
    }

    let resultHTML = `
        <div class="text-center p-8 bg-indigo-100 rounded-lg">
            <i class="fas fa-award text-5xl text-indigo-500 mb-4"></i>
            <p class="text-gray-600 mb-2">ผู้เข้าสอบ: <span class="font-semibold text-indigo-800">${currentStudentName}</span></p>
            <h3 class="text-2xl font-bold text-indigo-800 mb-2">ส่งคำตอบเรียบร้อยแล้ว</h3>
            <p class="text-gray-700 mb-2">ผลการทดสอบของคุณคือ:</p>
            ${passFailHTML}
        </div>
    `;
    studentResultArea.innerHTML = resultHTML;
    studentResultArea.classList.remove('hidden');
    studentQuizArea.classList.add('hidden');
    
    setupResultScreenBackButton({ showRankings: true, showImproveButton: !isPass });
}

// --- วางทับฟังก์ชัน cancelAdminTest เดิมทั้งหมด ---
function cancelAdminTest() {
    if (quizTimerInterval) clearInterval(quizTimerInterval);
    if (perQuestionTimerInterval) clearInterval(perQuestionTimerInterval);
			
	releaseWakeLock();
	stopDimTimer();
	exitFullscreen();
	document.removeEventListener('fullscreenchange', handleFullscreenChange);
    document.removeEventListener('visibilitychange', handleVisibilityChange);
            
    currentMode = 'admin'; // Reset mode
    studentView.classList.add('hidden');
    adminView.classList.remove('hidden');

    // [แก้ไข] เพิ่มเงื่อนไขเพื่อตรวจสอบ "ความจำ"
    if (cameFromBlueprint && currentBlueprintProjectId) {
        displayBlueprintProjectManager(currentBlueprintProjectId);
        cameFromBlueprint = false; // ล้างความจำ
    } else {
        showView('project-detail'); // ทำงานตามปกติ
    }
}

function setupResultScreenBackButton(options) {
    // กำหนดค่าเริ่มต้น
    const config = {
        isLooping: false,
        score: 0,
        totalQuestions: 1,
        showRankings: true, // แสดงปุ่มอันดับเป็นค่าเริ่มต้น
        showImproveButton: undefined, // undefined หมายถึงให้ตัดสินใจจาก score
        ...options 
    };

    if (config.isLooping) {
        const buttonHTML = `
            <div class="mt-6 pt-6 border-t flex items-center justify-center gap-4 w-full max-w-md mx-auto">
                <button id="retake-quiz-loop-btn" class="w-full bg-red-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-red-700 flex items-center justify-center gap-2 transition-transform hover:scale-105 whitespace-nowrap">
                    <i class="fas fa-redo-alt mr-2"></i>ทำแบบทดสอบอีกครั้ง
                </button>
            </div>
        `;
        studentResultArea.insertAdjacentHTML('beforeend', buttonHTML);
        document.getElementById('retake-quiz-loop-btn').addEventListener('click', () => {
            studentResultArea.classList.add('hidden');
            quizStartTime = new Date();
            displayQuizForStudent(currentQuizData);
        });
        return;
    }

    const backButtonId = 'back-from-results-btn';
    const isTesting = currentMode === 'admin-testing';
    const backButtonText = isTesting ? '<i class="fas fa-arrow-left mr-2"></i>กลับไปหน้าจัดการ' : '<i class="fas fa-home mr-2"></i>กลับหน้าแรก';
    
    let buttonsHTML = '';

    // เงื่อนไข: แสดงปุ่ม "ดูอันดับ"
    if (config.showRankings) {
        buttonsHTML += `<button id="view-rankings-btn" class="w-full sm:w-auto flex-1 bg-yellow-500 text-white py-3 px-4 rounded-lg font-semibold hover:bg-yellow-600 flex items-center justify-center gap-2 whitespace-nowrap"><i class="fas fa-trophy"></i>ดูอันดับ</button>`;
    }

    // เงื่อนไข: แสดงปุ่ม "ปรับปรุงคะแนน"
    let shouldShowImprove = config.showImproveButton;
    if (shouldShowImprove === undefined) {
        shouldShowImprove = config.score < config.totalQuestions;
    }

    if (shouldShowImprove) {
         buttonsHTML += `<button id="retake-for-improvement-btn" class="w-full sm:w-auto flex-1 bg-orange-500 text-white py-3 px-4 rounded-lg font-semibold hover:bg-orange-600 flex items-center justify-center gap-2 whitespace-nowrap"><i class="fas fa-redo-alt"></i>ปรับปรุงคะแนน</button>`;
    }
    
    // ปุ่ม "กลับ" (มีเสมอ)
    buttonsHTML += `<button id="${backButtonId}" class="w-full sm:w-auto flex-1 bg-blue-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-blue-700 flex items-center justify-center gap-2 whitespace-nowrap">${backButtonText}</button>`;

    const finalContainerHTML = `<div class="mt-6 pt-6 border-t flex flex-col sm:flex-row items-center justify-center gap-4 w-full max-w-lg mx-auto">${buttonsHTML}</div>`;
    studentResultArea.insertAdjacentHTML('beforeend', finalContainerHTML);

    // เพิ่ม Event Listeners
    studentResultArea.querySelector('#view-rankings-btn')?.addEventListener('click', handleShowStudentRankings);
    
    const retakeBtn = studentResultArea.querySelector('#retake-for-improvement-btn');
    if (retakeBtn) {
         retakeBtn.addEventListener('click', () => {
            studentResultArea.classList.add('hidden');
            quizStartTime = new Date();
            displayQuizForStudent(currentQuizData);
        });
    }

    document.getElementById(backButtonId).addEventListener('click', () => {
        if (isTesting) {
            currentMode = 'admin';
            studentView.classList.add('hidden');
            adminView.classList.remove('hidden');
            showView('project-detail');
        } else {
            showView('student');
            document.getElementById('quiz-id-input').value = '';
        }
    });
}

 function displayResultsWithAnswers(score, points, earnedBadges, detailedAnswers, totalQuestions, isLooping = false) {
    const percentage = totalQuestions > 0 ? (score / totalQuestions) * 100 : 0;
    const passingScore = currentDisplayedQuiz.settings?.passingScore ?? -1;
    const isRemedialQuiz = currentDisplayedQuiz.isRemedial === true;
    let passFailHTML = '';

    if (isRemedialQuiz || passingScore !== -1) {
        let isPass = isRemedialQuiz ? (score === totalQuestions) : (score >= passingScore);
        const resultClass = isPass ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
        const resultText = isPass ? 'ผ่าน' : 'ไม่ผ่าน';
        passFailHTML = `<p class="text-2xl font-bold mt-2 px-4 py-1 rounded-full inline-block ${resultClass}">${resultText}</p>`;
    }
    
    let resultHTML = `
        <div class="text-center p-6 bg-indigo-100 rounded-lg mb-6">
            <p class="text-gray-600 mb-2">ผู้เข้าสอบ: <span class="font-semibold text-indigo-800">${currentStudentName}</span></p>
            <h3 class="text-2xl font-bold text-purple-700 mb-2">ผลการทดสอบ</h3>
            <p class="text-4xl font-bold my-2">${score} <span class="text-xl font-normal text-gray-600">/ ${totalQuestions}</span></p>
            ${passFailHTML}
            <p class="text-lg font-semibold text-blue-600 mt-2">+${points} Points</p>
            <p class="text-md">คุณได้คะแนน ${percentage.toFixed(0)}%</p>
            <div id="earned-badges-container" class="mt-4 flex justify-center gap-4 flex-wrap"></div>
        </div>
        <h4 class="text-xl font-bold mb-4">ทบทวนคำตอบ</h4>
    `;
    
    currentDisplayedQuiz.questions.forEach((q, index) => {
        const detailedAnswer = detailedAnswers[index];
        const userAnswer = detailedAnswer.answer;
        const isCorrect = detailedAnswer.isCorrect;
        const questionType = q.questionType || currentDisplayedQuiz.quizType;

        resultHTML += `<div class="mb-4 p-4 border rounded-lg ${isCorrect ? 'border-green-300 bg-green-50' : 'border-red-300 bg-red-50'}"><p class="font-semibold">${index + 1}. ${q.stem || q.questionText}</p><div class="mt-3 space-y-2 text-sm">`;
        
        switch(questionType) {
            case 'matching_item':
                const userResponseText = userAnswer || 'ไม่ได้ตอบ';
                const correctResponseText = q.correctResponse;
                resultHTML += `<p><strong>คำตอบของคุณ:</strong> <span class="${!isCorrect ? 'line-through text-red-700' : ''}">${userResponseText}</span></p>`;
                if (!isCorrect) { resultHTML += `<p class="text-green-700"><strong>คำตอบที่ถูกต้อง:</strong> ${correctResponseText}</p>`; }
                break;
            
            // === [แก้ไข] เพิ่มเคส fill_in_no_choices ให้แสดงผลแบบเติมคำ ===
            case 'fill_in_no_choices':
            case 'short_answer':
                resultHTML += `<p><strong>คำตอบของคุณ:</strong> ${userAnswer || 'ไม่ได้ตอบ'}</p>`;
                resultHTML += `<p class="text-green-700"><strong>คำตอบที่เหมาะสม:</strong> ${q.idealAnswer}</p>`;
                break;
            
            case 'true_false':
                resultHTML += `<p class="${q.correctAnswer === true ? 'font-bold text-green-700' : ''} ${userAnswer === 'true' && !isCorrect ? 'line-through text-red-700' : ''}">ใช่</p>`;
                resultHTML += `<p class="${q.correctAnswer === false ? 'font-bold text-green-700' : ''} ${userAnswer === 'false' && !isCorrect ? 'line-through text-red-700' : ''}">ไม่ใช่</p>`;
                break;
            
            case 'multiple_choice':
            case 'fill_in_with_choices':
            default:
                if (q.options && Array.isArray(q.options)) {
                    resultHTML += q.options.map((opt, i) => {
                        let style = ''; let icon = '';
                        if (i === q.correctAnswerIndex) { style = 'font-bold text-green-700'; icon = '<i class="fas fa-check-circle mr-2 text-green-600"></i>';
                        } else if (i === userAnswer) { style = 'font-bold text-red-700 line-through'; icon = '<i class="fas fa-times-circle mr-2 text-red-600"></i>'; }
                        return `<div class="${style}">${icon}${opt}</div>`; }).join('');
                } else {
                    // Fallback กรณีข้อมูลผิดพลาด (เช่น type ผิด และไม่มี options)
                    resultHTML += `<p><strong>คำตอบของคุณ:</strong> ${userAnswer || 'ไม่ได้ตอบ'}</p>`;
                    if (!isCorrect) resultHTML += `<p class="text-green-700"><strong>(ไม่มีข้อมูลตัวเลือก)</strong></p>`;
                }
                break;
        }
        
        if (!isCorrect) {
            const practiceTopic = q.stem || q.questionText;
            resultHTML += `<div class="mt-3 text-right"><button class="practice-topic-btn bg-yellow-500 text-white text-xs font-semibold py-1 px-3 rounded-md hover:bg-yellow-600 flex items-center gap-1 ml-auto" data-topic="${escape(practiceTopic)}"><i class="fas fa-pencil-alt"></i> ฝึกฝนเรื่องนี้เพิ่มเติม</button></div>`;
        }
        resultHTML += `</div>`;
    });
   
    studentResultArea.innerHTML = resultHTML;
    renderEarnedBadges(earnedBadges, 'earned-badges-container');
    studentResultArea.classList.remove('hidden');
    studentQuizArea.classList.add('hidden');
    
    setupResultScreenBackButton({ isLooping, score, totalQuestions, showRankings: true });
    
    if (window.MathJax) window.MathJax.typesetPromise([studentResultArea]);
}

function displayResultsScoreOnly(score, points, earnedBadges, totalQuestions) {
    const percentage = totalQuestions > 0 ? (score / totalQuestions) * 100 : 0;
    const passingScore = currentDisplayedQuiz.settings?.passingScore ?? -1;
    const isRemedialQuiz = currentDisplayedQuiz.isRemedial === true;
    let passFailHTML = '';

    if (isRemedialQuiz || passingScore !== -1) {
        let isPass = isRemedialQuiz ? (score === totalQuestions) : (score >= passingScore);
        const resultClass = isPass ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
        const resultText = isPass ? 'ผ่าน' : 'ไม่ผ่าน';
        passFailHTML = `<p class="text-2xl font-bold mt-2 px-4 py-1 rounded-full inline-block ${resultClass}">${resultText}</p>`;
    }
    
    let resultHTML = `
        <div class="text-center p-8 bg-indigo-100 rounded-lg">
            <i class="fas fa-award text-5xl text-indigo-500 mb-4"></i>
            <p class="text-gray-600 mb-2">ผู้เข้าสอบ: <span class="font-semibold text-indigo-800">${currentStudentName}</span></p>
            <h3 class="text-2xl font-bold text-indigo-800 mb-2">ส่งคำตอบเรียบร้อยแล้ว</h3>
            <p class="text-gray-700 mb-2">นี่คือคะแนนของคุณ:</p>
            <p class="text-5xl font-bold my-2">${score} <span class="text-2xl font-normal text-gray-600">/ ${totalQuestions}</span></p>
            ${passFailHTML}
            <p class="text-lg font-semibold text-blue-600 mt-2">+${points} Points</p>
            <p class="text-xl">คิดเป็น ${percentage.toFixed(0)}%</p>
            <div id="earned-badges-container" class="mt-4 flex justify-center gap-4 flex-wrap"></div>
        </div>
    `;
    studentResultArea.innerHTML = resultHTML;
    renderEarnedBadges(earnedBadges, 'earned-badges-container');
    studentResultArea.classList.remove('hidden');
    studentQuizArea.classList.add('hidden');
    
    setupResultScreenBackButton({ score, totalQuestions, showRankings: true });
}

        function displaySubmissionConfirmation() {
    let resultHTML = `
        <div class="text-center p-8 bg-green-100 rounded-lg">
            <i class="fas fa-check-circle text-5xl text-green-500 mb-4"></i>
            <p class="text-gray-600 mb-2">ผู้เข้าสอบ: <span class="font-semibold text-green-800">${currentStudentName}</span></p>
            <h3 class="text-2xl font-bold text-green-800 mb-2">ส่งคำตอบเรียบร้อยแล้ว</h3>
            <p class="text-gray-600">ผู้ควบคุมจะแจ้งผลคะแนนให้ทราบภายหลัง</p>

            <div class="mt-6 pt-6 border-t flex justify-center">
                <button id="back-to-home-manual-release" class="bg-blue-600 text-white py-3 px-6 rounded-lg font-semibold hover:bg-blue-700 flex items-center justify-center gap-2">
                    <i class="fas fa-home mr-2"></i>กลับไปหน้าแรก
                </button>
            </div>
        </div>
    `;
    studentResultArea.innerHTML = resultHTML;
    studentResultArea.classList.remove('hidden');
    studentQuizArea.classList.add('hidden');

    // เพิ่ม Event Listener ให้กับปุ่มที่สร้างขึ้นใหม่
    document.getElementById('back-to-home-manual-release').addEventListener('click', () => {
        showView('student');
        document.getElementById('quiz-id-input').value = '';
    });
}

        function renderEarnedBadges(badgeIds, containerId) {
            const container = document.getElementById(containerId);
            if (!container || !badgeIds || badgeIds.length === 0) return;

            let badgesHTML = '';
            badgeIds.forEach((badgeId, index) => {
                const badgeInfo = Object.values(BADGES).find(b => b.id === badgeId);
                if (badgeInfo) {
                    badgesHTML += `
                        <div class="badge-icon text-center p-2 bg-white rounded-lg shadow" style="animation-delay: ${index * 0.2}s;" title="${badgeInfo.description}">
                            <i class="fas ${badgeInfo.icon} text-3xl"></i>
                            <p class="text-xs font-semibold mt-1">${badgeInfo.name}</p>
                        </div>
                    `;
                }
            });
            container.innerHTML = badgesHTML;
        }

        // --- Presentation Mode Functions ---
        function startPresentation(quizData) {
            currentQuizData = getShuffledQuiz(quizData); // แก้เป็น quizData
            currentPresentationSlide = 0;
            presentationModal.style.display = 'flex'; // Use style to show
            renderPresentationSlide(currentPresentationSlide);
        }

        function closePresentation() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            }
            presentationModal.style.display = 'none';
        }

        function renderPresentationSlide(index) {
            const container = document.getElementById('presentation-slide-container');
            if (!currentQuizData || !currentQuizData.questions || !currentQuizData.questions[index]) {
                container.innerHTML = `<p class="text-2xl">เกิดข้อผิดพลาด: ไม่พบข้อมูลคำถาม</p>`;
                return;
            }
            const question = currentQuizData.questions[index];
            const questionType = question.questionType || currentQuizData.quizType;
            
            container.innerHTML = ''; // Clear previous slide

            let slideHTML = `
               <div class="bg-white text-gray-800 p-6 md:p-12 rounded-2xl shadow-2xl w-full max-h-[90vh] overflow-y-auto fade-in flex flex-col">
                    ${question.imageCode ? `<div class="my-4 flex justify-center">${question.imageCode}</div>` : ''}
                    <p class="text-2xl sm:text-3xl lg:text-4xl font-bold mb-6 md:mb-12 text-left" style="line-height: 1.8;">${index + 1}. ${question.stem || question.questionText}</p>
                    <div id="presentation-options" class="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6 items-stretch justify-center">
            `;

            switch(questionType) {
                case 'matching_item':
                    slideHTML += question.allResponses.map((resp) => `
                        <button class="presentation-option p-4 md:p-6 rounded-lg text-lg md:text-2xl border-4 border-gray-300 hover:bg-indigo-100 transition-all leading-normal flex items-center justify-center text-center">
                            ${resp}
                        </button>
                    `).join('');
                    break;
                case 'true_false':
                    slideHTML += `<button class="presentation-option p-4 md:p-6 rounded-lg text-lg md:text-2xl border-4 border-gray-300 hover:bg-indigo-100 transition-all leading-normal flex items-center justify-center text-center" data-answer="true">ใช่</button>`;
                    slideHTML += `<button class="presentation-option p-4 md:p-6 rounded-lg text-lg md:text-2xl border-4 border-gray-300 hover:bg-indigo-100 transition-all leading-normal flex items-center justify-center text-center" data-answer="false">ไม่ใช่</button>`;
                    break;
                case 'fill_in_no_choices':
                case 'short_answer':
                     slideHTML += `
                        <div class="w-full md:col-span-2">
                            <textarea id="presentation-short-answer-input" class="w-full p-4 text-2xl border-2 border-gray-300 rounded-lg bg-white text-gray-800" rows="2" placeholder="พิมพ์คำตอบที่นี่..."></textarea>
                            <button id="check-presentation-answer-btn" class="mt-4 bg-blue-600 text-white py-3 px-6 rounded-lg text-xl hover:bg-blue-700">
                                <i class="fas fa-check"></i> ตรวจคำตอบ
                            </button>
                            <div id="presentation-ai-result" class="hidden mt-4 text-2xl font-bold"></div>
                        </div>
                    `;
                    break;
                case 'fill_in_the_blank':
                case 'multiple_choice':
                default:
                    slideHTML += question.options.map((opt, i) => `
                        <button class="presentation-option p-4 md:p-6 rounded-lg text-lg md:text-2xl border-4 border-gray-300 hover:bg-indigo-100 transition-all leading-normal flex items-center justify-center text-center" data-index="${i}">
                            ${opt}
                        </button>
                    `).join('');
                    break;
            }

            slideHTML += `
                    </div>
                </div>
            `;
            
            container.innerHTML = slideHTML;
            if (window.MathJax) window.MathJax.typesetPromise([container]);

            // ▼▼▼ --- ส่วนที่แก้ไข --- ▼▼▼
            // 1. เตรียมข้อมูลตัวเลือก (เหมือนเดิม)
            let optionsForScratchpad = [];
            switch(questionType) {
                case 'matching_item': optionsForScratchpad = question.allResponses || []; break;
                case 'true_false': optionsForScratchpad = ['ใช่', 'ไม่ใช่']; break;
                default: optionsForScratchpad = question.options || []; break;
            }
            
            // 2. ค้นหาปุ่ม "ทดเลข" ที่ตอนนี้อยู่ใน HTML แล้ว
            const scratchpadBtn = document.getElementById('presentation-scratchpad-btn');
            
            // 3. เปลี่ยนจากการ "สร้างปุ่มใหม่" มาเป็น "อัปเดต Event `onclick`" ของปุ่มเดิม
            // การใช้ .onclick จะเป็นการเขียนทับ Listener เก่าทุกครั้ง ทำให้ข้อมูลถูกต้องเสมอ
            if (scratchpadBtn) {
                scratchpadBtn.onclick = () => {
                    openScratchpad(question, optionsForScratchpad);
                };
            }
            // ▲▲▲ --- สิ้นสุดการแก้ไข --- ▲▲▲

            document.querySelectorAll('.presentation-option').forEach(btn => {
                btn.addEventListener('click', (e) => revealAnswerForPresentation(index, e.currentTarget));
            });
            
            const checkBtn = document.getElementById('check-presentation-answer-btn');
            if (checkBtn) {
                checkBtn.addEventListener('click', () => checkShortAnswerForPresentation(index));
            }

            document.getElementById('slide-counter').textContent = `ข้อที่ ${index + 1} / ${currentQuizData.questions.length}`;
            document.getElementById('prev-question-btn').disabled = index === 0;
            document.getElementById('next-question-btn').disabled = index === currentQuizData.questions.length - 1;
        }
        
        async function checkShortAnswerForPresentation(questionIndex) {
    const question = currentQuizData.questions[questionIndex];
    const input = document.getElementById('presentation-short-answer-input');
    const checkBtn = document.getElementById('check-presentation-answer-btn');
    const resultContainer = document.getElementById('presentation-ai-result');
    // const explanationContainer = document.getElementById('presentation-explanation'); // <--- ลบบรรทัดนี้ทิ้ง

    // แก้ไขเงื่อนไข if: เอา !explanationContainer ออก
    if (!input || !checkBtn || !resultContainer) return; 

    const userAnswer = input.value.trim();
    if (userAnswer === '') {
        return;
    }

    checkBtn.disabled = true;
    checkBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>กำลังตรวจ...';
    input.disabled = true;

    const isCorrect = await gradeShortAnswer(userAnswer, question);

    if (isCorrect) {
        resultContainer.innerHTML = '<span class="text-green-500"><i class="fas fa-check-circle"></i> ถูกต้อง</span>';
    } else {
        resultContainer.innerHTML = `<span class="text-red-500"><i class="fas fa-times-circle"></i> ไม่ถูกต้อง</span> (คำตอบที่คาดหวัง: ${question.idealAnswer})`;
    }
    
    resultContainer.classList.remove('hidden');
    // explanationContainer.classList.remove('hidden'); // <--- ลบบรรทัดนี้ทิ้ง
    checkBtn.classList.add('hidden'); 
}

        function revealAnswerForPresentation(questionIndex, selectedButton) {
            const question = currentQuizData.questions[questionIndex];
            const questionType = question.questionType || currentQuizData.quizType;
            
            document.querySelectorAll('.presentation-option').forEach(btn => {
                btn.disabled = true;
                btn.classList.remove('hover:bg-indigo-100');
                
                let isCorrect = false;
                if(questionType === 'multiple_choice' || questionType === 'fill_in_the_blank') {
                    const optionIndex = parseInt(btn.dataset.index);
                    isCorrect = optionIndex === question.correctAnswerIndex;
                } else if (questionType === 'true_false') {
                    const optionAnswer = btn.dataset.answer === 'true';
                    isCorrect = optionAnswer === question.correctAnswer;
                } else if (questionType === 'matching_item') {
                    isCorrect = btn.textContent.trim() === question.correctResponse;
                }

                if (isCorrect) {
                    btn.classList.add('bg-green-500', 'text-white', 'border-green-700');
                } else {
                    btn.classList.add('opacity-50');
                }
            });
            
            selectedButton.classList.remove('opacity-50');

            let wasSelectionCorrect = false;
            if (questionType === 'multiple_choice') {
                wasSelectionCorrect = parseInt(selectedButton.dataset.index) === question.correctAnswerIndex;
            } else if (questionType === 'true_false') {
                wasSelectionCorrect = (selectedButton.dataset.answer === 'true') === question.correctAnswer;
            } else if (questionType === 'matching_item') {
                wasSelectionCorrect = selectedButton.textContent.trim() === question.correctResponse;
            }

            if (!wasSelectionCorrect) {
                selectedButton.classList.add('bg-red-500', 'text-white', 'border-red-700');
            }

        }

        // --- Timer Functions ---
        function startWholeQuizTimer(durationInMinutes) {
            const timerContainer = document.getElementById('timer-container');
            if (!timerContainer) return;

            const endTime = Date.now() + durationInMinutes * 60 * 1000;
            timerContainer.innerHTML = `
                <div class="flex justify-between items-center bg-gray-100 p-2 rounded-lg">
                    <span class="font-semibold text-indigo-700">เวลาที่เหลือ:</span>
                    <span id="countdown-display" class="font-bold text-lg text-red-600">--:--</span>
                </div>
            `;
            const countdownDisplay = document.getElementById('countdown-display');

            quizTimerInterval = setInterval(() => {
                const remaining = endTime - Date.now();
                if (remaining <= 0) {
                    clearInterval(quizTimerInterval);
                    countdownDisplay.textContent = "00:00";
                    showMessage("หมดเวลา! กำลังส่งคำตอบ...");
                    handleSubmitQuiz(null); // Auto-submit
                } else {
                    const minutes = Math.floor((remaining / 1000 / 60) % 60).toString().padStart(2, '0');
                    const seconds = Math.floor((remaining / 1000) % 60).toString().padStart(2, '0');
                    countdownDisplay.textContent = `${minutes}:${seconds}`;
                }
            }, 1000);
        }

// ▼▼▼ วางทับฟังก์ชัน renderPerQuestionView เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
function renderPerQuestionView() {
    if (perQuestionTimerInterval) clearInterval(perQuestionTimerInterval);
    
    const q = currentDisplayedQuiz.questions[currentQuestionIndex];
    const questionType = q.questionType || currentDisplayedQuiz.quizType;
    // --- เพิ่มส่วนนี้: ตรวจสอบว่าเปิดใช้งานโหมดความมั่นใจหรือไม่ ---
    const confidenceScoringEnabled = currentDisplayedQuiz.settings?.isConfidenceScoringEnabled === true;

    // 1. สร้างโครงสร้างหลักของหน้าจอ
    let html = `
        <div class="flex justify-between items-center mb-2">
            <p class="text-sm text-gray-500">คำถามที่ ${currentQuestionIndex + 1} จาก ${currentDisplayedQuiz.questions.length}</p>
            ${currentMode === 'admin-testing' ? '<button id="cancel-test-btn" class="text-sm text-gray-500 hover:text-red-600 font-semibold py-1 px-2 rounded-md hover:bg-red-50"><i class="fas fa-times-circle mr-1"></i> ยกเลิกการทดสอบ</button>' : ''}
        </div>
        <h3 class="text-xl font-bold mb-2 text-center">แบบทดสอบ: ${currentDisplayedQuiz.topic}</h3>
        
        <div id="per-question-timer-container" class="mb-4"></div>

        <div class="mb-6 p-4 border rounded-lg bg-gray-50">
            <div class="font-semibold mb-3" id="per-question-text">
            </div>
            <div class="space-y-2" id="per-question-options">
            </div>
        </div>
    `;
    studentQuizArea.innerHTML = html;

    // 2. เตรียม HTML สำหรับคำถามและตัวเลือก
    let questionTextHTML = (q.stem || q.questionText);
    if (q.imageCode) {
        questionTextHTML += `<div class="my-4 flex justify-center">${q.imageCode}</div>`;
    }
    
    let optionsHTML = '';
    switch(questionType) {
        case 'short_answer':
        case 'fill_in_no_choices':
            optionsHTML = `<textarea name="question_single" class="w-full p-2 border border-gray-300 rounded-lg" rows="3" required></textarea>`;
            break;
        case 'true_false':
            optionsHTML = `<div><input type="radio" id="q_single_opt0" name="question_single" value="true" class="mr-2 accent-indigo-600" required><label for="q_single_opt0">ใช่</label></div>
                         <div><input type="radio" id="q_single_opt1" name="question_single" value="false" class="mr-2 accent-indigo-600" required><label for="q_single_opt1">ไม่ใช่</label></div>`;
            break;
        case 'matching_item':
             optionsHTML = `<select name="question_single" class="w-full p-2 border border-gray-300 rounded-lg" required>
                                <option value="">-- เลือกคำตอบ --</option>
                                ${(q.allResponses || []).map(resp => `<option value="${resp}">${resp}</option>`).join('')}
                            </select>`;
            break;
        default:
            if(q.options) {
                optionsHTML = q.options.map((opt, i) => `<div><input type="radio" id="q_single_opt${i}" name="question_single" value="${i}" class="mr-2 accent-indigo-600" required><label for="q_single_opt${i}">${opt}</label></div>`).join('');
            }
            break;
    }

    // 3. นำ HTML ของคำถามและตัวเลือกไปใส่ในหน้า
    document.getElementById('per-question-text').innerHTML = questionTextHTML;
    document.getElementById('per-question-options').innerHTML = optionsHTML;

const confidenceEnabled = currentDisplayedQuiz.settings?.isConfidenceScoringEnabled === true;
const confidenceMode = currentDisplayedQuiz.settings?.confidenceMode || 'checkbox';

// ▼▼▼ จุดที่แก้ไข: เพิ่มเงื่อนไข `&& confidenceMode === 'checkbox'` เข้าไป ▼▼▼
if (confidenceEnabled && confidenceMode === 'checkbox') {
    // เงื่อนไขใหม่นี้จะทำให้ Checkbox แสดงผล "เฉพาะเมื่อ" เลือกโหมด checkbox เท่านั้น
    const confidenceHTML = `
        <div class="mt-4 pt-3 border-t border-gray-200">
            <input type="checkbox" id="confidence_single" name="confidence_single" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
            <label for="confidence_single" class="ml-2 text-sm font-medium text-gray-700 cursor-pointer">ฉันมั่นใจในคำตอบข้อนี้</label>
        </div>
    `;
    studentQuizArea.querySelector('.mb-6.p-4').insertAdjacentHTML('beforeend', confidenceHTML);
}

    // 4. เพิ่มปุ่ม "ถัดไป" และเริ่ม Timer
    studentQuizArea.insertAdjacentHTML('beforeend', `
        <button id="next-question-timed-btn" class="w-full mt-4 bg-indigo-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-indigo-700">
            <i class="fas fa-arrow-right mr-2"></i>
            ${currentQuestionIndex === currentDisplayedQuiz.questions.length - 1 ? 'ส่งคำตอบ' : 'คำถามถัดไป'}
        </button>
    `);

    if (currentMode === 'admin-testing') {
        document.getElementById('cancel-test-btn')?.addEventListener('click', cancelAdminTest);
    }
    document.getElementById('next-question-timed-btn').addEventListener('click', () => handleNextQuestionInTimedMode(false));
    if (window.MathJax) window.MathJax.typesetPromise([studentQuizArea]);
    if (currentDisplayedQuiz.settings?.timerMode === 'per_question') {
        startPerQuestionTimer();
    }
}

        function startPerQuestionTimer() {
            const durationInSeconds = currentDisplayedQuiz.settings.timerDuration;
            const timerContainer = document.getElementById('per-question-timer-container');
            if (!timerContainer) return;

            let remainingTime = durationInSeconds;
            timerContainer.innerHTML = `
                <div id="timer-bar-container" class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="timer-bar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 100%"></div>
                </div>
                <p class="text-center text-sm text-gray-600 mt-1">เหลือเวลา <span id="per-q-countdown">${remainingTime}</span> วินาที</p>
            `;
            const timerBar = document.getElementById('timer-bar');
            const countdownDisplay = document.getElementById('per-q-countdown');

            perQuestionTimerInterval = setInterval(() => {
                remainingTime--;
                const percentage = (remainingTime / durationInSeconds) * 100;
                timerBar.style.width = `${percentage}%`;
                countdownDisplay.textContent = remainingTime;

                if (remainingTime <= 0) {
                    clearInterval(perQuestionTimerInterval);
                    showMessage("หมดเวลาสำหรับข้อนี้!");
                    handleNextQuestionInTimedMode(true); // Auto-advance, true means skipped
                }
            }, 1000);
        }
        
// ▼▼▼ วางทับฟังก์ชัน handleNextQuestionInTimedMode เดิมทั้งหมดด้วยโค้ดนี้ ▼▼▼
function handleNextQuestionInTimedMode(wasSkipped = false) {
    if (perQuestionTimerInterval) clearInterval(perQuestionTimerInterval);

    let selectedAnswer = null;
    let wasConfident = false; // ค่าเริ่มต้น

    if (!wasSkipped) {
        // --- ส่วนดึงข้อมูลจากฟอร์ม (เหมือนเดิม) ---
        const currentQuestion = currentDisplayedQuiz.questions[currentQuestionIndex];
        const questionType = currentQuestion.questionType || currentDisplayedQuiz.quizType;
        if (questionType === 'short_answer' || questionType === 'fill_in_no_choices') {
            selectedAnswer = document.querySelector('textarea[name="question_single"]')?.value.trim() ?? "";
        } else if (questionType === 'matching_item') {
            selectedAnswer = document.querySelector('select[name="question_single"]')?.value ?? "";
        } else {
            const checkedRadio = document.querySelector('input[name="question_single"]:checked');
            if (checkedRadio) {
                selectedAnswer = checkedRadio.value;
            }
        }
        if (selectedAnswer === null || selectedAnswer === "") {
            showMessage("กรุณาเลือกคำตอบก่อนกดปุ่มถัดไปครับ");
            startPerQuestionTimer();
            return;
        }

        // --- ส่วน Logic ใหม่ที่เพิ่มเข้ามา ---
        const confidenceEnabled = currentDisplayedQuiz.settings?.isConfidenceScoringEnabled === true;
        const confidenceMode = currentDisplayedQuiz.settings?.confidenceMode || 'checkbox';

        // **เงื่อนไขสำคัญ:** ถ้าเปิดใช้งาน และเป็นโหมดบังคับเลือก
if (confidenceEnabled && confidenceMode === 'mandatory') {
            // [แก้ไข] บอก Modal ว่านี่คือโหมดจับเวลารายข้อ
            document.getElementById('confidence-modal').dataset.currentMode = 'timed';
            
            // 1. "พัก" คำตอบไว้ใน hidden input
            document.getElementById('selected-answer-index-hidden').value = selectedAnswer;
            // 2. แสดง Modal
            document.getElementById('confidence-modal').classList.remove('hidden');
            // 3. หยุดการทำงานของฟังก์ชันนี้ทันที! (รอให้ผู้ใช้คลิกปุ่มใน Modal)
            return;
        }
        
        // ถ้าเป็นโหมด Checkbox (ของเดิม) ให้ดึงค่าตามปกติ
        const confidenceCheckbox = document.getElementById('confidence_single');
        if (confidenceCheckbox) {
            wasConfident = confidenceCheckbox.checked;
        }
        // --- สิ้นสุด Logic ใหม่ ---
    }
    
    // สร้าง object คำตอบ
    const answerData = { 
        answer: selectedAnswer, 
        wasConfident: wasConfident 
    };

    // เรียกใช้ฟังก์ชันใหม่เพื่อไปข้อต่อไป
    proceedToNextQuestion(answerData);
}

        async function finalizePerQuestionQuiz() {
            const hasShortAnswer = currentDisplayedQuiz.questions.some(q => q.questionType === 'short_answer');
            if (hasShortAnswer) {
                showMessage("สิ้นสุดการทำแบบทดสอบ AI กำลังตรวจคำตอบอัตนัย...");
            } else {
                showMessage("สิ้นสุดการทำแบบทดสอบ กำลังส่งคำตอบ...");
            }
            // --- เพิ่มโค้ดส่วนนี้เข้าไป ---
const quizId = currentQuizData.id;
const submissionRef = doc(db, `artifacts/${appId}/public/data/quizzes/${quizId}/submissions`, currentStudentName);
const submissionSnap = await getDoc(submissionRef);
const existingData = submissionSnap.exists() ? submissionSnap.data() : {};
const previousAttempts = existingData.attempts || [];

// --- แก้ไขบรรทัดเดิมให้เป็นแบบนี้ ---
await processAndSubmitAnswers(studentAnswersPerQuestion, previousAttempts);
        }

        // --- Export Functions ---
        function getResultsFilename() {
            const quizTitle = document.getElementById('results-quiz-title').textContent.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            return `results_${quizTitle || 'quiz'}`;
        }

        function exportResultsAsImage() {
            const resultsTable = document.getElementById('results-table-container');
            showMessage("กำลังสร้างรูปภาพ...");
            html2canvas(resultsTable).then(canvas => {
                const link = document.createElement('a');
                link.download = `${getResultsFilename()}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                messageModal.classList.add('hidden');
            });
        }

        function exportResultsAsPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Note: jsPDF has limited support for non-latin characters without custom fonts.
            // This will work for basic text but might not render Thai characters correctly.
            // For full Thai support, a font like 'Sarabun' would need to be embedded.
            doc.setFont('helvetica', 'normal'); 
            doc.autoTable({ html: '#results-table' });
            doc.save(`${getResultsFilename()}.pdf`);
        }

        function exportResultsAsWord() {
            const header = "<html xmlns:o='urn:schemas-microsoft-com:office:office' "+
                "xmlns:w='urn:schemas-microsoft-com:office:word' "+
                "xmlns='http://www.w3.org/TR/REC-html40'>"+
                "<head><meta charset='utf-8'><title>Export HTML to Word</title></head><body>";
            const footer = "</body></html>";
            const sourceHTML = header + document.getElementById("results-table-container").innerHTML + footer;
            
            const source = 'data:application/vnd.ms-word;charset=utf-8,' + encodeURIComponent(sourceHTML);
            const fileDownload = document.createElement("a");
            document.body.appendChild(fileDownload);
            fileDownload.href = source;
            fileDownload.download = `${getResultsFilename()}.doc`;
            fileDownload.click();
            document.body.removeChild(fileDownload);
        }

        function exportResultsAsExcel() {
            const table = document.getElementById('results-table');
            let csv = [];
            for (let i = 0; i < table.rows.length; i++) {
                let row = [], cols = table.rows[i].querySelectorAll('td, th');
                for (let j = 0; j < cols.length; j++) {
                    // Escape double quotes and wrap in double quotes
                    row.push('"' + cols[j].innerText.replace(/"/g, '""') + '"');
                }
                csv.push(row.join(','));
            }
            const csvFile = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csv.join('\n')], {type: 'text/csv;charset=utf-8;'}); // Add BOM for Excel
            const link = document.createElement('a');
            link.href = URL.createObjectURL(csvFile);
            link.download = `${getResultsFilename()}.csv`;
            link.click();
        }
		
		function exportTableAsImage(containerId, filename) {
    const element = document.getElementById(containerId);
    const titleElement = document.getElementById('results-quiz-title'); 
    
    if (!element) {
        showMessage("ไม่พบตารางสำหรับ Export");
        return;
    }

    showMessage("กำลังสร้างรูปภาพ (ซ่อนผลลัพธ์)...");

    // 1. สร้าง Container ชั่วคราว
    const wrapper = document.createElement('div');
    wrapper.style.backgroundColor = '#ffffff';
    wrapper.style.padding = '30px';
    wrapper.style.width = '1000px'; 
    wrapper.style.position = 'fixed'; 
    wrapper.style.left = '-9999px';
    wrapper.style.top = '0';
    wrapper.style.zIndex = '-1';
    
    // 2. สร้างหัวข้อจำลอง
    const headerClone = document.createElement('h1');
    headerClone.innerText = titleElement ? titleElement.innerText : 'รายงานผลคะแนน';
    headerClone.style.textAlign = 'center';
    headerClone.style.fontFamily = "'Sarabun', sans-serif";
    headerClone.style.fontSize = '28px';
    headerClone.style.fontWeight = 'bold';
    headerClone.style.color = '#4338ca'; 
    headerClone.style.marginBottom = '20px';
    
    // 3. สร้างตารางจำลอง (Clone Table)
    const tableClone = element.cloneNode(true);
    tableClone.style.maxHeight = 'none';
    tableClone.style.overflow = 'visible';

    // --- [เพิ่ม Logic: ซ่อนคอลัมน์ "ผล"] ---
    // ค้นหา index ของหัวข้อตารางที่เขียนว่า "ผล"
    const headers = tableClone.querySelectorAll('th');
    let resultColumnIndex = -1;

    headers.forEach((th, index) => {
        if (th.textContent.trim() === 'ผล') {
            th.style.display = 'none'; // ซ่อนหัวข้อ
            resultColumnIndex = index;
        }
    });

    // ถ้าเจอคอลัมน์ "ผล" ให้วนลูปซ่อนข้อมูลในทุกแถว
    if (resultColumnIndex !== -1) {
        const rows = tableClone.querySelectorAll('tr');
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            // ตรวจสอบว่าแถวนี้มี cell ครบตามจำนวนหรือไม่ (เพื่อป้องกัน error)
            if (cells.length > resultColumnIndex) {
                cells[resultColumnIndex].style.display = 'none'; // ซ่อนช่องข้อมูล
            }
        });
    }
    // ---------------------------------------
    
    // 4. ประกอบร่าง
    wrapper.appendChild(headerClone);
    wrapper.appendChild(tableClone);
    document.body.appendChild(wrapper);

    // 5. สั่ง html2canvas ถ่ายรูป
    html2canvas(wrapper, {
        scale: 2, 
        useCORS: true,
        backgroundColor: '#ffffff'
    }).then(canvas => {
        const link = document.createElement('a');
        link.download = `${filename}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
        
        document.body.removeChild(wrapper);
        messageModal.classList.add('hidden');
    }).catch(err => {
        console.error("Export Image Error:", err);
        document.body.removeChild(wrapper);
        showMessage("เกิดข้อผิดพลาดในการสร้างรูปภาพ");
    });
}

        // REFACTORED exportResultsAsPDF to exportTableAsPDF
        function exportTableAsPDF(tableId, filename) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            doc.setFont('helvetica', 'normal'); 
            doc.autoTable({ html: `#${tableId}` });
            doc.save(`${filename}.pdf`);
        }

        // REFACTORED exportResultsAsWord to exportTableAsWord
        function exportTableAsWord(containerId, filename) {
            const element = document.getElementById(containerId);
            if (!element) {
                showMessage("ไม่พบตารางสำหรับ Export");
                return;
            }
            const header = "<html xmlns:o='urn:schemas-microsoft-com:office:office' "+
                "xmlns:w='urn:schemas-microsoft-com:office:word' "+
                "xmlns='http://www.w3.org/TR/REC-html40'>"+
                "<head><meta charset='utf-8'><title>Export HTML to Word</title></head><body>";
            const footer = "</body></html>";
            const sourceHTML = header + element.innerHTML + footer;
            
            const source = 'data:application/vnd.ms-word;charset=utf-8,' + encodeURIComponent(sourceHTML);
            const fileDownload = document.createElement("a");
            document.body.appendChild(fileDownload);
            fileDownload.href = source;
            fileDownload.download = `${filename}.doc`;
            fileDownload.click();
            document.body.removeChild(fileDownload);
        }

        // REFACTORED exportResultsAsExcel to exportTableAsExcel
        function exportTableAsExcel(tableId, filename) {
            const table = document.getElementById(tableId);
            if (!table) {
                showMessage("ไม่พบตารางสำหรับ Export");
                return;
            }
            let csv = [];
            for (let i = 0; i < table.rows.length; i++) {
                let row = [], cols = table.rows[i].querySelectorAll('td, th');
                for (let j = 0; j < cols.length; j++) {
                    row.push('"' + cols[j].innerText.replace(/"/g, '""') + '"');
                }
                csv.push(row.join(','));
            }
            const csvFile = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csv.join('\n')], {type: 'text/csv;charset=utf-8;'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(csvFile);
            link.download = `${filename}.csv`;
            link.click();
        }

 function renderAnalytics(quizData, submissions) {
    // 1. กรองเอาเฉพาะ submission ที่มีข้อมูลคะแนนแล้วจริงๆ
    const completeSubmissions = submissions.filter(sub => sub.latestScore !== undefined);

    const totalStudents = currentProjectData.students.length;
    const submittedCount = completeSubmissions.length;
    const notSubmittedCount = totalStudents - submittedCount;
    const submissionRate = totalStudents > 0 ? (submittedCount / totalStudents) * 100 : 0;
    
    // 2. คำนวณคะแนนเฉลี่ย (Average Score)
    const scores = completeSubmissions.map(s => s.latestScore);
    const averageScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;

    // --- [จุดที่แก้ไข] คำนวณคะแนนเต็มรวม (Total Max Weighted Score) ---
    // แทนที่จะนับแค่จำนวนข้อ (questions.length) เราต้องบวกน้ำหนักคะแนนทุกข้อรวมกัน
    let totalMaxWeightedScore = 0;
    quizData.questions.forEach(q => {
        const qType = q.questionType || quizData.quizType;
        // เรียกใช้ Helper function ที่เราสร้างไว้ก่อนหน้านี้
        totalMaxWeightedScore += getQuestionWeight(quizData, qType);
    });

    // ป้องกันการหารด้วย 0
    if (totalMaxWeightedScore === 0) totalMaxWeightedScore = quizData.questions.length || 1;

    // คำนวณเปอร์เซ็นต์จากคะแนนเต็มรวมที่ถูกต้อง
    const averagePercentage = (averageScore / totalMaxWeightedScore) * 100;
    // -----------------------------------------------------------

    const itemAnalysisForReliability = calculateItemAnalysis(quizData, completeSubmissions);
    const kr20 = calculateReliabilityKR20(quizData, completeSubmissions, itemAnalysisForReliability.perQuestionStats);
    let kr20CardHTML = '';

    if (kr20 !== null) {
        let reliabilityText = '';
        if (kr20 >= 0.9) reliabilityText = 'ยอดเยี่ยม';
        else if (kr20 >= 0.8) reliabilityText = 'ดีมาก';
        else if (kr20 >= 0.7) reliabilityText = 'ดี';
        else if (kr20 >= 0.6) reliabilityText = 'พอใช้';
        else reliabilityText = 'ควรปรับปรุง';
        
        kr20CardHTML = `
            <div class="bg-purple-100 p-4 rounded-lg text-center">
                <p class="text-sm text-purple-700 font-semibold">ความเชื่อมั่น (KR-20)</p>
                <p class="text-2xl font-bold text-purple-900">${kr20.toFixed(2)}</p>
                <p class="text-xs text-purple-600">${reliabilityText}</p>
            </div>
        `;
    }

    const summaryContainer = document.getElementById('analytics-summary-cards');
    summaryContainer.innerHTML = `
        <div class="bg-blue-100 p-4 rounded-lg text-center">
            <p class="text-sm text-blue-700 font-semibold">อัตราการส่ง</p>
            <p class="text-2xl font-bold text-blue-900">${submissionRate.toFixed(0)}%</p>
            <p class="text-xs text-blue-600">(${submittedCount}/${totalStudents} คน)</p>
        </div>
        <div class="bg-green-100 p-4 rounded-lg text-center">
            <p class="text-sm text-green-700 font-semibold">คะแนนเฉลี่ย</p>
            <p class="text-2xl font-bold text-green-900">${averageScore.toFixed(2)}</p>
            <p class="text-xs text-green-600">(${averagePercentage.toFixed(2)}%)</p> 
        </div>
        <div class="bg-yellow-100 p-4 rounded-lg text-center">
            <p class="text-sm text-yellow-700 font-semibold">คะแนนสูงสุด</p>
            <p class="text-2xl font-bold text-yellow-900">${scores.length > 0 ? Math.max(...scores).toFixed(2) : 'N/A'}</p>
        </div>
        <div class="bg-red-100 p-4 rounded-lg text-center">
            <p class="text-sm text-red-700 font-semibold">คะแนนต่ำสุด</p>
            <p class="text-2xl font-bold text-red-900">${scores.length > 0 ? Math.min(...scores).toFixed(2) : 'N/A'}</p>
        </div>
        ${kr20CardHTML}
    `;
    
    const oldStatsWrapper = document.getElementById('interesting-stats-wrapper');
    if (oldStatsWrapper) {
        oldStatsWrapper.remove();
    }

    const interestingStatsHtml = `
        <div id="interesting-stats-wrapper" class="mt-8">
            <details class="bg-gray-50 p-3 rounded-lg">
                <summary class="text-xl font-semibold cursor-pointer hover:text-indigo-600">
                    <i class="fas fa-chevron-right details-marker mr-2"></i>สถิติที่น่าสนใจ 📊
                </summary>
                <div id="interesting-stats-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-3 border-t pt-3">
                </div>
            </details>
        </div>
    `;
    summaryContainer.insertAdjacentHTML('afterend', interestingStatsHtml);

    const students = currentProjectData.students || [];
    // ส่ง totalMaxWeightedScore ไปให้กราฟด้วย เพื่อให้กราฟแสดงแกน X ได้ถูกต้อง (ถ้าจำเป็น)
    renderSubmissionChart(submittedCount, notSubmittedCount, completeSubmissions, students);
    
    // ตรงนี้อาจต้องปรับปรุง renderScoreDistributionChart เพิ่มเติมในอนาคตถ้าต้องการให้แกน X ละเอียดขึ้น
    // แต่เบื้องต้นให้ใช้ totalMaxWeightedScore เป็นเพดานคะแนน
    renderScoreDistributionChart(completeSubmissions, Math.ceil(totalMaxWeightedScore)); 
    
    renderQuestionAnalytics(quizData, completeSubmissions, students);
    renderInterestingStats(quizData, completeSubmissions);
}

async function handleExportLessonPDF() {
    const lessonContentEl = document.getElementById("lesson-plan-content");
    const quizTitle = document.getElementById('lesson-plan-title').textContent;
    
    // เปิดหน้าต่างใหม่เพื่อเตรียมพิมพ์
    const printWindow = window.open('', '_blank');

    // สร้างโครงสร้าง HTML ทั้งหมดสำหรับหน้าที่จะพิมพ์
    const printHtml = `
        <!DOCTYPE html>
        <html lang="th">
        <head>
            <meta charset="UTF-8">
            <title>${quizTitle}</title>
            <script src="https://cdn.tailwindcss.com"><\/script>
            <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
            
            <script>
                window.MathJax = {
                    tex: {
                        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]
                    }
                };
            <\/script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"><\/script>
            <style>
                body { 
                    font-family: 'Sarabun', sans-serif; 
                }
                @media print {
                    body { -webkit-print-color-adjust: exact; }
                }
                .content-section { 
                    page-break-inside: avoid; /* ป้องกันการตัดเนื้อหาข้ามหน้า */
                    margin-bottom: 2rem;
                }
            </style>
        </head>
        <body class="p-8 max-w-4xl mx-auto">
            ${lessonContentEl.innerHTML} 
        </body>
        </html>
    `;
    
    // เขียน HTML ลงในหน้าต่างใหม่
    printWindow.document.write(printHtml);
    printWindow.document.close();

    // ตั้งเวลาหน่วงเพื่อให้ MathJax render สูตรคณิตศาสตร์ (ถ้ามี) ให้เสร็จก่อนสั่งพิมพ์
    printWindow.onload = function() {
        setTimeout(() => {
            printWindow.print();
        }, 1500); // หน่วงเวลา 1.5 วินาที
    };
}

// --- [ เพิ่มฟังก์ชันนี้เข้าไปใหม่ทั้งหมด ] ---
function renderInterestingStats(quizData, submissions) {
    const container = document.getElementById('interesting-stats-container');
    if (!container) return;
    if (submissions.length === 0) {
        container.innerHTML = '<p class="text-gray-500 col-span-full text-center">ยังไม่มีข้อมูลเพียงพอสำหรับสร้างสถิติ</p>';
        return;
    }

    // 1. คำนวณสถิติรายข้อ (หาข้อที่ถูก/ผิดมากที่สุด)
    const questionStats = quizData.questions.map((q, index) => ({
        index: index + 1,
        text: q.questionText || q.stem,
        correct: 0
    }));

    submissions.forEach(sub => {
        const latestAttempt = sub.attempts[sub.attempts.length - 1];
        if (latestAttempt && latestAttempt.answers) {
            latestAttempt.answers.forEach(ans => {
                // ค้นหาข้อที่ถูกต้องจาก "ข้อความของคำถาม" แทนที่จะใช้ "ตำแหน่ง"
                const statToUpdate = questionStats.find(q => q.text === ans.originalQuestionText);
                if (ans.isCorrect && statToUpdate) {
                    statToUpdate.correct++;
                }
            });
        }
    });

    const totalSubmissions = submissions.length;
    const maxCorrectCount = Math.max(...questionStats.map(q => q.correct));
    const minCorrectCount = Math.min(...questionStats.map(q => q.correct));

    const mostCorrectQuestions = questionStats
        .filter(q => q.correct === maxCorrectCount)
        .map(q => `ข้อ ${q.index}`);
        
    const leastCorrectQuestions = questionStats
        .filter(q => q.correct === minCorrectCount)
        .map(q => `ข้อ ${q.index}`);

    // 2. คำนวณสถิติรายคน (หาคนที่ถูก/ผิดมากที่สุด)
    const topScorers = submissions
        .sort((a, b) => b.latestScore - a.latestScore)
        .filter((s, i, arr) => s.latestScore === arr[0].latestScore);

    const lowestScorers = submissions
        .sort((a, b) => a.latestScore - b.latestScore)
        .filter((s, i, arr) => s.latestScore === arr[0].latestScore);

    // 3. สร้าง HTML สำหรับการ์ดแต่ละใบ
    const html = `
        <div class="bg-green-50 p-4 rounded-lg border border-green-200">
            <div class="flex items-center">
                <div class="bg-green-100 text-green-600 p-2 rounded-full mr-3">
                    <i class="fas fa-check-circle fa-lg"></i>
                </div>
                <div>
                    <p class="text-sm text-gray-600">ข้อที่ทำถูกมากที่สุด</p>
                    <p class="font-bold text-green-800 text-lg">${mostCorrectQuestions.join(', ')}</p>
                    <p class="text-xs text-gray-500">(${maxCorrectCount} / ${totalSubmissions} คน)</p>
                </div>
            </div>
        </div>

        <div class="bg-red-50 p-4 rounded-lg border border-red-200">
            <div class="flex items-center">
                <div class="bg-red-100 text-red-600 p-2 rounded-full mr-3">
                    <i class="fas fa-exclamation-circle fa-lg"></i>
                </div>
                <div>
                    <p class="text-sm text-gray-600">ข้อที่ทำผิดมากที่สุด</p>
                    <p class="font-bold text-red-800 text-lg">${leastCorrectQuestions.join(', ')}</p>
                    <p class="text-xs text-gray-500">(${totalSubmissions - minCorrectCount} / ${totalSubmissions} คน)</p>
                </div>
            </div>
        </div>

        <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
            <div class="flex items-center">
                <div class="bg-blue-100 text-blue-600 p-2 rounded-full mr-3">
                    <i class="fas fa-trophy fa-lg"></i>
                </div>
                <div>
                    <p class="text-sm text-gray-600">นักเรียนที่คะแนนสูงสุด</p>
                    <p class="font-bold text-blue-800 text-lg">${topScorers.map(s => s.studentName).join(', ')}</p>
                    <p class="text-xs text-gray-500">(ได้ ${topScorers[0].latestScore} คะแนน)</p>
                </div>
            </div>
        </div>

        <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
            <div class="flex items-center">
                <div class="bg-yellow-100 text-yellow-600 p-2 rounded-full mr-3">
                    <i class="fas fa-hands-helping fa-lg"></i>
                </div>
                <div>
                    <p class="text-sm text-gray-600">นักเรียนที่ควรดูแลเป็นพิเศษ</p>
                    <p class="font-bold text-yellow-800 text-lg">${lowestScorers.map(s => s.studentName).join(', ')}</p>
                    <p class="text-xs text-gray-500">(ได้ ${lowestScorers[0].latestScore} คะแนน)</p>
                </div>
            </div>
        </div>
    `;
    container.innerHTML = html;
}

        function renderSubmissionChart(submittedCount, notSubmittedCount, submissions, students) {
            const ctx = document.getElementById('submission-status-chart').getContext('2d');
            const submittedNames = submissions.map(s => s.studentName);
            const notSubmittedNames = students.filter(name => !submittedNames.includes(name));

            if (chartInstances.submission) {
                chartInstances.submission.destroy();
            }
            chartInstances.submission = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['ส่งแล้ว', 'ยังไม่ส่ง'],
                    datasets: [{
                        data: [submittedCount, notSubmittedCount],
                        backgroundColor: ['#10B981', '#F59E0B'],
                        borderColor: ['#ffffff', '#ffffff'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    label += context.raw;
                                    return label;
                                },
                                afterLabel: function(context) {
                                    let names;
                                    if (context.dataIndex === 0) { // Submitted
                                        names = submittedNames;
                                    } else { // Not Submitted
                                        names = notSubmittedNames;
                                    }
                                    return names.length > 0 ? names.join('\n') : 'ไม่มี';
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderScoreDistributionChart(submissions, totalQuestions) {
            const ctx = document.getElementById('score-distribution-chart').getContext('2d');
            const scoreCounts = {};
            for (let i = 0; i <= totalQuestions; i++) {
                scoreCounts[i] = 0;
            }
            submissions.forEach(sub => {
                if (scoreCounts[sub.latestScore] !== undefined) {
                    scoreCounts[sub.latestScore]++;
                }
            });

            if (chartInstances.score) {
                chartInstances.score.destroy();
            }
            chartInstances.score = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(scoreCounts),
                    datasets: [{
                        label: 'จำนวนนักเรียน',
                        data: Object.values(scoreCounts),
                         backgroundColor: 'rgba(79, 70, 229, 0.8)',
                        borderColor: 'rgba(79, 70, 229, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { stepSize: 1 }
                        },
                        x: {
                            title: { display: true, text: 'คะแนน' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const score = context.label;
                                    const studentsWithScore = submissions
                                        .filter(s => s.latestScore == score)
                                        .map(s => s.studentName);
                                    return studentsWithScore.length > 0 ? studentsWithScore.join('\n') : '';
                                }
                            }
                        }
                    }
                }
            });
        }
        
       function renderQuestionAnalytics(quizData, submissions, students) {
    const container = document.getElementById('question-analytics-container');
    if (students.length === 0) {
        container.innerHTML = '<p class="text-gray-500 text-center">ยังไม่มีนักเรียนในโปรเจคเพื่อวิเคราะห์รายข้อ</p>';
        return;
    }

    // --- ส่วนที่ 1: เรียกใช้ฟังก์ชันคำนวณสถิติทั้งหมดที่จำเป็น ---
    const itemAnalysis = calculateItemAnalysis(quizData, submissions);
    const distractorAnalysis = calculateDistractorAnalysis(quizData, submissions);

    // --- ส่วนที่ 2: สร้างกล่องสรุปภาพรวมของกลุ่มเก่งและกลุ่มอ่อน (ส่วนใหม่) ---
    let overallGroupsHTML = '';
    if (itemAnalysis.overallGroups) {
        overallGroupsHTML = `
            <div class="mb-4 p-4 border rounded-lg bg-gray-100">
                <h4 class="font-semibold mb-2">สรุปภาพรวมกลุ่มที่ใช้ในการวิเคราะห์</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                    <div>
                        <p class="font-semibold text-gray-800">กลุ่มเก่ง (${itemAnalysis.overallGroups.upperGroupNames.length} คน)</p>
                        <ul class="list-disc list-inside text-gray-600 mt-1">
                            ${itemAnalysis.overallGroups.upperGroupNames.map(name => `<li>${name}</li>`).join('')}
                        </ul>
                    </div>
                     <div>
                        <p class="font-semibold text-gray-800">กลุ่มอ่อน (${itemAnalysis.overallGroups.lowerGroupNames.length} คน)</p>
                        <ul class="list-disc list-inside text-gray-600 mt-1">
                            ${itemAnalysis.overallGroups.lowerGroupNames.map(name => `<li>${name}</li>`).join('')}
                        </ul>
                    </div>
                </div>
            </div>
        `;
    }

    // --- ส่วนที่ 3: สร้าง HTML สำหรับรายละเอียดแต่ละข้อ (วน Loop) ---
    let html = '';
    const submittedNames = submissions.map(s => s.studentName);

   // ฟังก์ชันสำหรับสร้าง Badge ของค่าความยาก (p)
const getPBadge = (p) => {
    if (p >= 0.80) return `<span class="bg-teal-100 text-teal-800 text-xs font-semibold px-2 rounded-full">ง่ายมาก</span>`;
    if (p >= 0.60) return `<span class="bg-green-100 text-green-800 text-xs font-semibold px-2 rounded-full">ง่าย</span>`;
    if (p >= 0.40) return `<span class="bg-blue-100 text-blue-800 text-xs font-semibold px-2 rounded-full">ปานกลาง (เหมาะสม)</span>`;
    if (p >= 0.20) return `<span class="bg-yellow-100 text-yellow-800 text-xs font-semibold px-2 rounded-full">ยาก</span>`;
    return `<span class="bg-red-100 text-red-800 text-xs font-semibold px-2 rounded-full">ยากมาก</span>`;
};
    // ฟังก์ชันสำหรับสร้าง Badge ของค่าอำนาจจำแนก (r)
const getRBadge = (r) => {
    if (r < 0) return `<span class="bg-pink-200 text-pink-900 text-xs font-semibold px-2 rounded-full" title="อาจทำให้เด็กอ่อนตอบถูกมากกว่าเด็กเก่ง ต้องแก้ไขหรือตัดทิ้ง">ผิดปกติ</span>`;
    if (r >= 0.40) return `<span class="bg-green-100 text-green-800 text-xs font-semibold px-2 rounded-full">ดีมาก</span>`;
    if (r >= 0.30) return `<span class="bg-blue-100 text-blue-800 text-xs font-semibold px-2 rounded-full">ดี</span>`;
    if (r >= 0.20) return `<span class="bg-yellow-100 text-yellow-800 text-xs font-semibold px-2 rounded-full">พอใช้</span>`;
    return `<span class="bg-red-100 text-red-800 text-xs font-semibold px-2 rounded-full">ควรปรับปรุง</span>`;
};

// ฟังก์ชันสำหรับสร้าง Badge ของเปอร์เซ็นต์คนตอบถูก (แก้ไขล่าสุด)
const getPercentCorrectBadge = (rate) => {
    const roundedRate = rate.toFixed(0);
    
    // === เงื่อนไขที่เพิ่มเข้ามาใหม่ ===
    // ถ้าคะแนนเท่ากับ 100% ให้เป็นสีเขียว
    if (parseFloat(roundedRate) === 100) {
        return `<span class="bg-green-200 text-green-900 font-semibold px-3 py-1 rounded-md text-xs">ตอบถูก ${roundedRate}%</span>`;
    }
    // ===============================

    // ถ้าเปอร์เซ็นต์มากกว่าหรือเท่ากับ 50% ให้เป็นป้ายสีเหลือง
    if (rate >= 50) {
        return `<span class="bg-yellow-200 text-yellow-900 font-semibold px-3 py-1 rounded-md text-xs">ตอบถูก ${roundedRate}%</span>`;
    }
    // น้อยกว่า 50% ให้เป็นป้ายสีแดง
    return `<span class="bg-red-200 text-red-900 font-semibold px-3 py-1 rounded-md text-xs">ตอบถูก ${roundedRate}%</span>`;
};

    quizData.questions.forEach((q, index) => {
        const analysis = itemAnalysis.perQuestionStats[index]; // ดึงข้อมูลจากโครงสร้างใหม่
        const distractors = distractorAnalysis[index];
        const questionDisplayText = q.stem || q.questionText || q.instructions;

        // คำนวณสัดส่วนคนตอบถูก/ผิด (ภาพรวม)
        let correctCount = 0;
        const correctStudents = [];
        const incorrectStudents = [];
        submissions.forEach(sub => {
            const latestAttempt = sub.attempts[sub.attempts.length - 1];
            if (latestAttempt && latestAttempt.answers) {
                const answerItem = latestAttempt.answers.find(ans => ans.originalQuestionText === questionDisplayText) ?? latestAttempt.answers[index] ?? null;
                if (answerItem) {
                    if (answerItem.isCorrect) {
                        correctCount++;
                        correctStudents.push(sub.studentName);
                    } else {
                        incorrectStudents.push(sub.studentName);
                    }
                }
            }
        });
        const correctRate = submissions.length > 0 ? (correctCount / submissions.length) * 100 : 0;
        const unsubmittedStudents = students.filter(name => !submittedNames.includes(name));

       const analysisHTML = analysis ? `
            <div class="flex items-center gap-4 border-l pl-4 ml-2">
                <div class="text-center"><p class="text-xs text-gray-500 font-sans">ค่าความยาก (p)</p><p class="font-bold text-indigo-700 text-lg">${analysis.p.toFixed(2)}</p><div>${getPBadge(analysis.p)}</div></div>
                <div class="text-center"><p class="text-xs text-gray-500 font-sans">ค่าอำนาจจำแนก (r)</p><p class="font-bold text-teal-700 text-lg">${analysis.r.toFixed(2)}</p><div>${getRBadge(analysis.r)}</div></div>
                
                <div class="flex items-center justify-center pl-2">
                    ${getPercentCorrectBadge(correctRate)}
                </div>
                </div>` : '';

        // สร้างตารางวิเคราะห์ตัวลวง
        let distractorTableHTML = '';
        if (distractors) {
            distractorTableHTML = `
                <div class="mt-4"><p class="font-semibold">การวิเคราะห์ตัวเลือก:</p>
                    <table class="min-w-full bg-white border mt-1 text-xs">
                        <thead class="bg-gray-200"><tr><th class="py-1 px-2 border-b text-left">ตัวเลือก</th><th class="py-1 px-2 border-b text-center">กลุ่มเก่ง</th><th class="py-1 px-2 border-b text-center">กลุ่มอ่อน</th><th class="py-1 px-2 border-b text-center">รวม</th></tr></thead>
                        <tbody>${Object.keys(distractors).map(optIndex => {
                                const data = distractors[optIndex];
                                const isCorrect = parseInt(optIndex) === q.correctAnswerIndex;
                                const isGoodDistractor = !isCorrect && data.lower_group_count > data.upper_group_count;
                                return `<tr class="${isCorrect ? 'bg-green-100 font-bold' : ''}"><td class="py-1 px-2 border-b">${isCorrect ? '✔ ' : ''}${data.text}</td><td class="py-1 px-2 border-b text-center">${data.upper_group_count}</td><td class="py-1 px-2 border-b text-center">${data.lower_group_count} ${isGoodDistractor ? '👍' : ''}</td><td class="py-1 px-2 border-b text-center">${data.total}</td></tr>`;
                            }).join('')}
                        </tbody></table></div>`;
        }

        // สร้างส่วนแสดงรายชื่อกลุ่มเก่ง/อ่อนสำหรับข้อนั้นๆ (ส่วนใหม่)
        let groupDetailsHTML = '';
        if (analysis && analysis.upperGroupResponders) {
            groupDetailsHTML = `
                <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><p class="font-semibold text-gray-800">กลุ่มเก่ง (${analysis.upperGroupResponders.length} คน):</p><ul class="text-xs text-gray-600 pl-2 space-y-1 mt-1">${analysis.upperGroupResponders.map(student => `<li>${student.isCorrect ? '<i class="fas fa-check-circle text-green-500"></i>' : '<i class="fas fa-times-circle text-red-500"></i>'} ${student.name}</li>`).join('')}</ul></div>
                    <div><p class="font-semibold text-gray-800">กลุ่มอ่อน (${analysis.lowerGroupResponders.length} คน):</p><ul class="text-xs text-gray-600 pl-2 space-y-1 mt-1">${analysis.lowerGroupResponders.map(student => `<li>${student.isCorrect ? '<i class="fas fa-check-circle text-green-500"></i>' : '<i class="fas fa-times-circle text-red-500"></i>'} ${student.name}</li>`).join('')}</ul></div>
                </div>`;
        }

        // ประกอบร่าง HTML ทั้งหมดของข้อนั้นๆ
        html += `
            <details class="bg-gray-50 p-3 rounded-lg">
                <summary class="flex justify-between items-center cursor-pointer font-semibold">
                    <span class="w-2/4 truncate">ข้อ ${index + 1}: ${questionDisplayText}</span>
                    <div class="flex items-center gap-4">${analysisHTML}<i class="fas fa-chevron-right details-marker"></i></div>
                </summary>
                <div class="mt-3 pt-3 border-t text-sm space-y-2">
                    <p><strong>คำถาม:</strong> ${questionDisplayText}</p>
                    <p><strong>สถิติ:</strong> นักเรียน ${correctCount} จาก ${submissions.length} คนที่ส่ง ตอบถูก (${correctRate.toFixed(0)}%)</p>
                    <div class="mt-2"><p class="font-semibold text-green-700">ตอบถูก (${correctStudents.length} คน):</p><p class="text-xs text-gray-600 pl-2">${correctStudents.length > 0 ? correctStudents.join(', ') : 'ไม่มี'}</p></div>
                    <div class="mt-2"><p class="font-semibold text-red-700">ตอบผิด (${incorrectStudents.length} คน):</p><p class="text-xs text-gray-600 pl-2">${incorrectStudents.length > 0 ? incorrectStudents.join(', ') : 'ไม่มี'}</p></div>
                    <div class="mt-2"><p class="font-semibold text-gray-500">ยังไม่ส่ง (${unsubmittedStudents.length} คน):</p><p class="text-xs text-gray-600 pl-2">${unsubmittedStudents.length > 0 ? unsubmittedStudents.join(', ') : 'ไม่มี'}</p></div>
                    ${distractorTableHTML}
                    ${groupDetailsHTML}
                </div>
            </details>
        `;
    });
    
    // --- ส่วนที่ 4: นำ HTML ทั้งหมดไปแสดงผลในหน้าเว็บ ---
    container.innerHTML = overallGroupsHTML + html;
    
    try {
        if (window.MathJax && MathJax.typesetPromise) {
            MathJax.typesetPromise([container]);
        }
    } catch (e) {
        console.error('MathJax typeset error (analytics):', e);
    }
}

/**
 * วิเคราะห์ประสิทธิภาพของตัวลวงในข้อสอบปรนัยแต่ละข้อ
 * @param {object} quizData ข้อมูลของแบบทดสอบ
 * @param {Array} submissions ข้อมูลการส่งงานของนักเรียนทุกคน
 * @returns {object} ผลการวิเคราะห์ตัวลวงของแต่ละข้อ
 */
function calculateDistractorAnalysis(quizData, submissions) {
    const distractorResults = {};
    if (submissions.length < 2) return distractorResults;

    const sortedSubmissions = [...submissions].sort((a, b) => {
    // 1. เรียงตามคะแนนล่าสุด (มากไปน้อย)
    const scoreDiff = b.latestScore - a.latestScore;
    if (scoreDiff !== 0) return scoreDiff;

    // 2. ถ้าคะแนนเท่ากัน ให้เรียงตามจำนวนครั้งที่ทำ (น้อยไปมาก)
    const attemptsA = a.attempts?.length || 1;
    const attemptsB = b.attempts?.length || 1;
    const attemptDiff = attemptsA - attemptsB;
    if (attemptDiff !== 0) return attemptDiff;

    // 3. ถ้าจำนวนครั้งเท่ากัน ให้เรียงตามเวลาที่ส่ง (ก่อนไปหลัง)
    const timeA = new Date(a.latestSubmittedAt);
    const timeB = new Date(b.latestSubmittedAt);
    const timeDiff = timeA - timeB;
    if (timeDiff !== 0) return timeDiff;

    // 4. ถ้าเวลาส่งเท่ากัน ให้เรียงตามชื่อ (ก-ฮ)
    return a.studentName.localeCompare(b.studentName, 'th');
});
    const totalStudents = sortedSubmissions.length;
    const groupSize = Math.max(1, Math.floor(totalStudents * 0.33)); // ป้องกัน groupSize เป็น 0

    const upperGroup = sortedSubmissions.slice(0, groupSize);
    const lowerGroup = sortedSubmissions.slice(-groupSize);

    quizData.questions.forEach((question, index) => {
        // ทำการวิเคราะห์เฉพาะข้อสอบปรนัยเท่านั้น
        if (question.questionType !== 'multiple_choice' || !question.options) {
            return;
        }

        const questionText = question.questionText;
        const analysis = {};
        // สร้างโครงสร้างสำหรับนับแต่ละตัวเลือก
        question.options.forEach((opt, optIndex) => {
            analysis[optIndex] = {
                text: opt,
                upper_group_count: 0,
                lower_group_count: 0,
                total: 0
            };
        });

        // วนลูปเพื่อนับจำนวนคนเลือกในแต่ละกลุ่ม
        sortedSubmissions.forEach(sub => {
            const latestAttempt = sub.attempts[sub.attempts.length - 1];
            const answerItem = latestAttempt.answers.find(ans => ans.originalQuestionText === questionText);
            
            if (answerItem && answerItem.answer !== null) {
                // --- จุดแก้ไขบั๊ก ---
                // ค้นหาดัชนีที่ถูกต้องจาก "ข้อความ" แทนที่จะใช้ "ตำแหน่ง" ที่ผิดเพี้ยน
                const correctOriginalIndex = question.options.findIndex(opt => opt === answerItem.answerText);

                if (correctOriginalIndex !== -1 && analysis[correctOriginalIndex]) {
                    analysis[correctOriginalIndex].total++;

                    // เช็คว่าเป็นคนในกลุ่มเก่งหรือกลุ่มอ่อน
                    if (upperGroup.includes(sub)) {
                        analysis[correctOriginalIndex].upper_group_count++;
                    }
                    if (lowerGroup.includes(sub)) {
                        analysis[correctOriginalIndex].lower_group_count++;
                    }
                }
            }
        });
        
        distractorResults[index] = analysis;
    });

    return distractorResults;
}

/**
 * คำนวณค่าความเชื่อมั่นของแบบทดสอบด้วยสูตร KR-20
 * @param {object} quizData ข้อมูลของแบบทดสอบ
 * @param {Array} submissions ข้อมูลการส่งงานของนักเรียนทุกคน
 * @param {object} itemAnalysis ผลการวิเคราะห์ค่า p ของแต่ละข้อ
 * @returns {number|null} ค่า KR-20 หรือ null ถ้าคำนวณไม่ได้
 */
// โค้ดที่แก้ไขแล้ว
function calculateReliabilityKR20(quizData, submissions, itemAnalysis) {
    const k = quizData.questions.length;
    if (k < 2 || submissions.length < 2) return null;

    // --- [แก้ไข] คำนวณคะแนนดิบแบบ "นับจำนวนข้อที่ถูก" (Unweighted Score) ---
    // เพื่อให้สอดคล้องกับสูตร KR-20 ที่ใช้ค่า p (สัดส่วนคนตอบถูก)
    const unweightedScores = submissions.map(sub => {
        // ดึงการทำครั้งล่าสุด
        const attempt = sub.attempts && sub.attempts.length > 0 
            ? sub.attempts[sub.attempts.length - 1] 
            : null;
            
        if (!attempt || !attempt.answers) return 0;
        
        // นับจำนวนข้อที่ตอบถูก (isCorrect = true) โดยไม่สนใจน้ำหนักคะแนน
        return attempt.answers.filter(a => a.isCorrect).length;
    });

    // คำนวณความแปรปรวน (Variance) จากคะแนนดิบที่นับจำนวนข้อ
    const mean = unweightedScores.reduce((a, b) => a + b, 0) / unweightedScores.length;
    const scoreVariance = unweightedScores.map(score => Math.pow(score - mean, 2)).reduce((a, b) => a + b, 0) / unweightedScores.length;

    if (scoreVariance === 0) return null;

    let sum_pq = 0;
    for (let i = 0; i < k; i++) {
        const p = itemAnalysis[i]?.p;
        if (p === undefined) continue;
        const q = 1 - p;
        sum_pq += p * q;
    }

    // ตรวจสอบความถูกต้องของ sum_pq
    if (sum_pq === 0) return null;

    const kr20 = (k / (k - 1)) * (1 - (sum_pq / scoreVariance));

    // ตรวจสอบค่าเกิน 1 (ผิดปกติ)
    if (kr20 > 1) return null;

    return kr20;
}

        async function handleAnalyzeClass() {
    // ตรวจสอบว่ามีข้อมูลแบบทดสอบที่กำลังดูอยู่หรือไม่
    if (!currentQuizData || !currentQuizData.id) {
        showMessage("เกิดข้อผิดพลาด: ไม่พบข้อมูลแบบทดสอบปัจจุบัน");
        return;
    }

    const submissionsRef = collection(db, `artifacts/${appId}/public/data/quizzes/${currentQuizData.id}/submissions`);
    const submissionsSnapshot = await getDocs(submissionsRef);
    const submissions = submissionsSnapshot.docs.map(doc => doc.data());

    if (submissions.length < 2) {
        showMessage("ต้องมีนักเรียนส่งงานอย่างน้อย 2 คนขึ้นไป จึงจะสามารถวิเคราะห์ภาพรวมได้");
        return;
    }

    const analysisContainer = document.getElementById('strength-weakness-analysis-container');
    analysisContainer.innerHTML = `
        <div class="text-center py-8">
            <div class="loader mx-auto"></div>
            <p class="mt-4 text-gray-600">AI กำลังวิเคราะห์ภาพรวม... อาจใช้เวลาสักครู่</p>
        </div>
    `;
    document.getElementById('analyze-strengths-btn').disabled = true;

    // สรุปข้อมูลคำตอบของนักเรียนทุกคนเพื่อส่งให้ AI
    const studentDataSummary = submissions.map((sub, index) => {
        const latestAttempt = sub.attempts[sub.attempts.length - 1];
        if (!latestAttempt) return ''; // ข้ามกรณีที่ไม่มีข้อมูลการทำข้อสอบ
        return `
            นักเรียนคนที่ ${index + 1} (${sub.studentName}):
            คะแนน: ${latestAttempt.score}/${sub.totalQuestions}
            คำตอบรายข้อ: ${JSON.stringify(latestAttempt.answers)}
        `;
    }).join('\n---\n');

    const analysisPrompt = `
        คุณคือนักวิเคราะห์การศึกษาผู้เชี่ยวชาญ ภารกิจของคุณคือการวิเคราะห์ภาพรวมของห้องเรียนจากข้อมูลการทำแบบทดสอบ

        แบบทดสอบเรื่อง: "${currentQuizData.topic}"
        ข้อมูลคำถามทั้งหมด: ${JSON.stringify(currentQuizData.questions)}

        นี่คือข้อมูลสรุปของนักเรียนในห้อง:
        ${studentDataSummary}

        จากข้อมูลทั้งหมด โปรดวิเคราะห์และสรุปผลออกมาเป็น JSON object ที่มีโครงสร้างดังนี้เท่านั้น:
        - classStrengths: จุดแข็งโดยรวมของห้องเรียนนี้ หรือคอนเซ็ปต์ที่นักเรียนส่วนใหญ่เข้าใจตรงกัน (array ของ string)
        - classWeaknesses: จุดอ่อนโดยรวม หรือความเข้าใจผิดที่พบบ่อยที่สุด (array ของ string)
        - teacherSuggestions: ข้อเสนอแนะเชิงปฏิบัติ 2-3 ข้อสำหรับครู เพื่อนำไปพัฒนาการสอนในครั้งต่อไป (array ของ string)

        ตอบเป็นภาษาไทยทั้งหมด
    `;

    const analysisSchema = {
        type: "OBJECT",
        properties: {
            classStrengths: { type: "ARRAY", items: { type: "STRING" } },
            classWeaknesses: { type: "ARRAY", items: { type: "STRING" } },
            teacherSuggestions: { type: "ARRAY", items: { type: "STRING" } }
        },
        required: ["classStrengths", "classWeaknesses", "teacherSuggestions"]
    };

    try {
        const analysisResult = await callAnalysisApi(analysisPrompt, analysisSchema);
        displayClassAnalysis(analysisResult);
    } catch (error) {
        console.error("Error during class analysis:", error);
        analysisContainer.innerHTML = `<div class="text-red-500 text-center"><p>ขออภัย, การวิเคราะห์ล้มเหลว: ${error.message}</p></div>`;
    } finally {
        document.getElementById('analyze-strengths-btn').disabled = false;
    }
}
function displayClassAnalysis(data) {
    const analysisContainer = document.getElementById('strength-weakness-analysis-container');
    if (!data) {
        analysisContainer.innerHTML = '<p class="text-center text-red-500">ไม่ได้รับข้อมูลการวิเคราะห์จาก AI</p>';
        return;
    }
    analysisContainer.innerHTML = `
        <div class="fade-in space-y-4 mt-4 border-t pt-4">
            <div>
                <h4 class="text-lg font-semibold text-green-700 mb-2"><i class="fas fa-check-circle mr-2"></i>จุดแข็งของห้องเรียน</h4>
                <ul class="list-disc list-inside space-y-1 bg-green-50 p-3 rounded-lg text-green-800">
                    ${data.classStrengths.map(item => `<li>${item}</li>`).join('')}
                </ul>
            </div>
             <div>
                <h4 class="text-lg font-semibold text-red-700 mb-2"><i class="fas fa-exclamation-circle mr-2"></i>จุดอ่อน / ความเข้าใจผิดที่พบบ่อย</h4>
                <ul class="list-disc list-inside space-y-1 bg-red-50 p-3 rounded-lg text-red-800">
                    ${data.classWeaknesses.map(item => `<li>${item}</li>`).join('')}
                </ul>
            </div>
             <div>
                <h4 class="text-lg font-semibold text-blue-700 mb-2"><i class="fas fa-chalkboard-teacher mr-2"></i>ข้อเสนอแนะสำหรับครู</h4>
                <ul class="list-disc list-inside space-y-1 bg-blue-50 p-3 rounded-lg text-blue-800">
                   ${data.teacherSuggestions.map(item => `<li>${item}</li>`).join('')}
                </ul>
            </div>
        </div>
    `;
}
function formatAndPrintWorksheet(quizData, worksheetWindow) { 
    const worksheetHtml = `
        <!DOCTYPE html>
        <html lang="th">
        <head>
            <meta charset="UTF-8">
            <title>ใบงาน: ${quizData.topic}</title>
            <script src="https://cdn.tailwindcss.com"><\/script>
            <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
            
            <script> window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } }; <\/script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"><\/script>
            <style>
                body { font-family: 'Sarabun', sans-serif; }
                @media print {
                    body { -webkit-print-color-adjust: exact; }
                    .no-print { display: none; }
                }
                .question-item { page-break-inside: avoid; }
                .answer-line {
                    border-bottom: 1px dotted black;
                    display: inline-block;
                    width: 80%;
                    margin-left: 1rem;
                }
            </style>
        </head>
        <body class="p-8">
            <div class="text-center mb-8">
                <h1 class="text-2xl font-bold">ใบงานเรื่อง: ${quizData.topic}</h1>
            </div>
            <div class="flex justify-between mb-8 text-lg">
                <p>ชื่อ: ....................................................................</p>
                <p>วันที่: ......./......./.........</p>
                <p>คะแนน: .................</p>
            </div>
            <div class="space-y-6">
                ${quizData.questions.map((q, index) => `
                    <div class="question-item">
                        <p class="text-lg font-semibold mb-2">${index + 1}. ${q.questionText}</p>
                        ${q.imageCode ? `<div class="my-2 flex justify-center">${q.imageCode}</div>` : ''}
                        <div class="mt-4">
                            <p><strong>ตอบ:</strong> <span class="answer-line"></span></p>
                        </div>
                    </div>
                `).join('')}
            </div>
        </body>
        </html>
    `;
    worksheetWindow.document.write(worksheetHtml);
    worksheetWindow.document.close();
    worksheetWindow.onload = function() {
        // เพิ่มการหน่วงเวลาเล็กน้อยเพื่อให้ MathJax ทำงานเสร็จก่อนพิมพ์
        setTimeout(() => {
            worksheetWindow.print();
        }, 1000); // หน่วงเวลา 1 วินาที
    };
}
async function generateWorksheet() {
    const topic = document.getElementById('worksheet-topic-input').value.trim();
    if (!topic) {
        showMessage("กรุณาป้อนหัวข้อสำหรับใบงาน");
        return;
    }

    const isNormalTopic = document.getElementById('force-math-checkbox').checked;
    const subjectPrefix = isNormalTopic ? "" : "คณิตศาสตร์";

    const worksheetWindow = window.open('', '_blank');
    worksheetWindow.document.write('<h1></h1>');
    
    const numQuestions = parseInt(document.getElementById('num-questions').value);
    const includeImages = document.getElementById('include-images-checkbox').checked;
    const imageInstruction = includeImages ? `สำหรับบางข้อ หากจำเป็น ให้สร้างโค้ด SVG ที่เกี่ยวข้องกับโจทย์ด้วย` : '';

    // ▼▼▼ ส่วนที่แก้ไข: เพิ่มตัวแปร simpleMathPrompt เข้าไปในคำสั่ง ▼▼▼
    const prompt = `
        สร้างชุดคำถามสำหรับใบงาน${subjectPrefix}ที่พิมพ์ได้ จำนวน ${numQuestions} ข้อ เกี่ยวกับหัวข้อ "${topic}". 
        คำถามควรเป็นแบบปลายเปิด, เติมคำ, หรือคำนวณ ที่นักเรียนสามารถเขียนคำตอบได้ 
        ${imageInstruction}

        ให้ผลลัพธ์เป็น JSON object ที่มีโครงสร้างดังนี้:
        - topic: ชื่อหัวข้อของใบงาน
        - questions: array ของ object คำถาม โดยแต่ละ object มี:
          - questionText: (string) ตัวคำถาม
          - imageCode: (string, optional) โค้ด SVG ถ้ามี
          
        ${simpleMathPrompt} 
    `;
    // ▲▲▲ สิ้นสุดส่วนที่แก้ไข ▲▲▲

    const schema = {
        type: "OBJECT",
        properties: {
            topic: { type: "STRING" },
            questions: {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        questionText: { type: "STRING" },
                        imageCode: { type: "STRING" }
                    },
                    required: ["questionText"]
                }
            }
        },
        required: ["topic", "questions"]
    };

    document.getElementById('loader-text').textContent = '';
    document.getElementById('loader').classList.remove('hidden');
    document.getElementById('quiz-generation-area').classList.remove('hidden');
    generateWorksheetBtn.disabled = true;

    try {
        const worksheetData = await callAnalysisApi(prompt, schema);
        
        formatAndPrintWorksheet(worksheetData, worksheetWindow);
    } catch (error) {
        console.error("Error generating worksheet:", error);
        if (worksheetWindow) worksheetWindow.close();
        showMessage("เกิดข้อผิดพลาดในการสร้างใบงาน");
    } finally {
        document.getElementById('loader').classList.add('hidden');
        document.getElementById('quiz-generation-area').classList.add('hidden');
        generateWorksheetBtn.disabled = false;
    }
}

async function callAnalysisApi(prompt, schema) {
    const payload = {
        contents: [{ role: "user", parts: [{ text: prompt }] }],
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: schema
        }
    };
    const apiKey = "AIzaSyB8ziZtJkPE4_53A4djxRjAXI_DDOP_vdg"; // Provided by environment
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
    if (!response.ok) {
        throw new Error(`API call failed with status: ${response.status}`);
    }
    const result = await response.json();
    
    if (result.candidates?.[0]?.content?.parts?.[0]) {
        return JSON.parse(result.candidates[0].content.parts[0].text);
    } else {
        // --- ส่วนที่แก้ไข ---
        // ตรวจสอบสาเหตุที่ AI ไม่ส่งคำตอบกลับมา เพื่อให้แสดง Error ที่ชัดเจนขึ้น
        let detailedError = "Invalid response structure from AI.";
        
        // กรณีที่ Prompt ถูกบล็อกทั้งหมดก่อนการประมวลผล
        if (result.promptFeedback?.blockReason) {
            detailedError = `AI request was blocked. Reason: ${result.promptFeedback.blockReason}.`;
        
        // กรณีที่การสร้างคำตอบถูกหยุดกลางคัน (เช่น พบเนื้อหาไม่เหมาะสม)
        } else if (result.candidates?.[0]?.finishReason && result.candidates[0].finishReason !== "STOP") {
            detailedError = `AI generation finished with an issue. Reason: ${result.candidates[0].finishReason}.`;
        }
        
        console.error(detailedError, JSON.stringify(result));
        throw new Error(detailedError);
        // --- สิ้นสุดส่วนที่แก้ไข ---
    }
}

async function handleStartSyncMode(quizId, shouldSave = false, variant = 'classic') {
    const quiz = allQuizzes.find(q => q.id === quizId) || allQuizzesGlobal.find(q => q.id === quizId);
    if (!quiz) { showMessage("ไม่พบข้อมูลแบบทดสอบ"); return; }

    currentQuizData = getShuffledQuiz(quiz);
    const gamePin = Math.floor(1000 + Math.random() * 9000).toString();

    const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, quiz.projectId);
    const projectSnap = await getDoc(projectRef);
    if (!projectSnap.exists()) { showMessage("ไม่พบโปรเจค"); return; }
    const studentsInProject = projectSnap.data().students || [];
    
    const playerNicknames = {};
    if (variant === 'anonymous' || variant === 'anonymous_reveal_end') {
        const shuffledNames = [...ANONYMOUS_NAMES].sort(() => 0.5 - Math.random());
        studentsInProject.forEach((studentName, index) => {
            playerNicknames[studentName] = shuffledNames[index] || `ผู้เล่น ${index + 1}`;
        });
    }
    
    // 1. [แก้ไข] ยกเลิกการอ่านค่าจาก Checkbox และตั้งเป็น false ถาวร
    const isOnetMode = false;

    // 2. ตั้งค่า Timer
    const timerEnabled = document.getElementById('sync-timer-enable-checkbox').checked;
    const timerDuration = parseInt(document.getElementById('sync-timer-duration-input').value, 10);
    let timerSettings = { timerMode: 'none', timerDuration: 0 };
    if (timerEnabled) {
        timerSettings.timerMode = 'per_question';
        timerSettings.timerDuration = timerDuration || 300;
    }
    
    const showAnswerInAnonymous = document.getElementById('anon-show-answer-toggle').checked;
    
    // 3. กำหนดฟีเจอร์เกม
    // อ่านค่าโดยตรงจาก Checkbox ตลาดมืด โดยไม่ต้องสนใจ O-NET Mode
    const blackMarketEnabled = document.getElementById('enable-black-market-checkbox').checked;
    
    // ใช้ค่าความมั่นใจจาก Quiz Settings
    const confidenceEnabled = quiz.settings?.isConfidenceScoringEnabled || false;

    try {
        const syncGameRef = await addDoc(collection(db, `artifacts/${appId}/public/data/syncGames`), {
            quizId: quiz.id,
            pin: gamePin,
            status: "lobby",
            currentQuestionIndex: -1,
            shuffledQuiz: currentQuizData,
            shouldSaveResults: shouldSave,
            players: {},
            gameVariant: variant,
            reviewQuestionIndex: 0,
            playerNicknames: playerNicknames, 
            isAnonymousRevealed: false,
            ...timerSettings,
            showAnswerInAnonymous: showAnswerInAnonymous,
            
            // บันทึกการตั้งค่า
            isOnetMode: false, // บังคับปิดเสมอ
            isBlackMarketEnabled: blackMarketEnabled,     
            isConfidenceScoringEnabled: confidenceEnabled, 
            
            showSlowResponders: true,
            slowResponderCount: 3
        });
        
        currentLiveGameId = syncGameRef.id;
        showView('live-game');
        
        // แสดงชื่อหัวข้อแบบปกติ
        renderSyncLobbyView(gamePin, quiz.topic); 
        
        listenForSyncGameUpdates();

        const adminGameState = { gameId: currentLiveGameId, mode: 'sync', role: 'admin' };
        sessionStorage.setItem('activeGameSession', JSON.stringify(adminGameState));

    } catch(err) {
        console.error("Error starting sync game:", err);
        showMessage("เกิดข้อผิดพลาดในการสร้างห้อง Sync Game");
    }
}

function calculateFinalPodiumScores(gameData) {
    if (!gameData || !gameData.shuffledQuiz || !gameData.players) {
        return gameData.players || {};
    }

    const finalPlayers = JSON.parse(JSON.stringify(gameData.players)); 

    Object.values(finalPlayers).forEach(player => {
        player.realScore = player.score || 0;
        player.totalPoints = player.totalPoints || 0; 
        
        // ตัด Logic การบวก +1 Bonus ออกตามที่ขอ
        player.hasPerfectScoreBonus = false; 
    });

    return finalPlayers;
}

// ตัวแปรสำหรับเก็บข้อมูลชั่วคราว (Data Optimization)
let cachedGameData = null;
let cachedPlayerData = {}; 
let unsubscribePlayerDocListener = null;
let unsubscribePlayersCollectionListener = null;

function listenForSyncGameUpdates() {
    // 1. เคลียร์ Listener เก่า
    if (unsubscribeLiveGameListener) unsubscribeLiveGameListener();
    if (unsubscribePlayerDocListener) unsubscribePlayerDocListener();
    if (unsubscribePlayersCollectionListener) unsubscribePlayersCollectionListener();

    // === [เพิ่มส่วนนี้] ล้างข้อมูลเก่าทิ้งก่อนเริ่มฟังห้องใหม่เสมอ ===
    cachedPlayerData = {}; 
    cachedGameData = null;
    // ======================================================

    const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);

    // 2. ฟังข้อมูลสถานะเกม (Main Doc)
    unsubscribeLiveGameListener = onSnapshot(gameRef, (docSnap) => {
        if (!docSnap.exists()) {
            sessionStorage.removeItem('activeGameSession');
            showMessage("กิจกรรมสิ้นสุดลงแล้ว");
            if (cameFromBlueprint && currentBlueprintProjectId) {
                displayBlueprintProjectManager(currentBlueprintProjectId);
                cameFromBlueprint = false;
            } else if (currentMode === 'admin') {
                showView('project-detail');
            } else {
                showView('student');
            }
            return;
        }

        cachedGameData = docSnap.data();
        if (cachedGameData.shuffledQuiz) {
            currentQuizData = cachedGameData.shuffledQuiz;
        }
        syncDataAndRender();
    });

    // 3. ฟังข้อมูลผู้เล่น (Subcollection)
    const playersColRef = collection(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`);

    if (currentMode === 'admin') {
        unsubscribePlayersCollectionListener = onSnapshot(playersColRef, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                if (change.type === "added" || change.type === "modified") {
                    cachedPlayerData[change.doc.id] = change.doc.data();
                } else if (change.type === "removed") {
                    delete cachedPlayerData[change.doc.id];
                }
            });
            syncDataAndRender();
        });

    } else {
        if (localTeamPlayers && localTeamPlayers.length > 0) {
            const q = query(playersColRef, where('name', 'in', localTeamPlayers));
            unsubscribePlayersCollectionListener = onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added" || change.type === "modified") {
                        cachedPlayerData[change.doc.id] = change.doc.data();
                    }
                });
                syncDataAndRender();
            });
        }
    }
}

function syncDataAndRender() {
    if (!cachedGameData) return;

    // คำนวณสถานะ 'answered' อัตโนมัติ (เพื่อไม่ต้องเขียน Database บ่อยๆ)
    const playersDisplay = {};
    const currentIndex = cachedGameData.currentQuestionIndex;

    Object.keys(cachedPlayerData).forEach(pid => {
        const p = cachedPlayerData[pid];
        // ตรวจสอบว่าผู้เล่นตอบข้อปัจจุบันหรือยัง
        const hasAnsweredThisTurn = p.answers && p.answers.some(a => a.questionIndex === currentIndex);
        
        playersDisplay[pid] = {
            ...p,
            answered: hasAnsweredThisTurn // Override ค่านี้ให้ UI เดิมเอาไปใช้
        };
    });

    // รวมร่างข้อมูล
    const mergedGameData = {
        ...cachedGameData,
        players: playersDisplay
    };

    // ส่งให้ UI เดิมของคุณทำงานต่อ (ไม่ต้องแก้ UI)
    if (currentMode === 'admin') {
        updateAdminSyncView(mergedGameData);
    } else {
        updateStudentSyncView(mergedGameData);
    }
}

function renderSyncLobbyView(pin, topic) {
    liveGameView.innerHTML = `
        <div class="bg-indigo-700 text-white rounded-lg p-8 text-center flex flex-col items-center justify-center h-full">
            <h2 class="text-2xl font-bold mb-2">Sync Mode: ${topic}</h2>
            <p class="text-lg mb-4">ให้นักเรียนเข้าร่วมด้วยรหัสนี้:</p>
            <div class="bg-white text-gray-800 rounded-lg p-4 mb-4">
                <p class="text-6xl font-bold tracking-widest">${pin}</p>
            </div>
            <div class="w-full max-w-lg bg-white/20 p-4 rounded-lg">
                <h3 class="text-xl font-semibold mb-2">ผู้เล่นที่เข้าร่วม (<span id="player-count">0</span>)</h3>
                <div id="player-list-lobby" class="flex flex-wrap justify-center gap-2">
                    <p class="text-indigo-200">กำลังรอผู้เล่น...</p>
                </div>
            </div>

            <div class="w-full max-w-lg bg-black/20 p-4 rounded-lg mt-4 text-left">
                <label for="confidence-scoring-toggle" class="flex items-center cursor-pointer">
                    <input id="confidence-scoring-toggle" type="checkbox" class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" checked>
                    <span class="ml-3 text-lg font-semibold">เปิดใช้งานระบบคะแนนความมั่นใจ</span>
                </label>
                <div id="confidence-scoring-description" class="mt-2 text-sm text-indigo-200 pl-8 space-y-1">
                    <p class="font-bold text-white">คะแนนพิเศษที่จะถูกคำนวณในตอนท้าย:</p>
                    <p>- ตอบถูก & มั่นใจ = ได้โบนัส <strong class="text-white">+1</strong> คะแนน</p>
                    <p>- ตอบผิด & มั่นใจ = ถูกหัก <strong class="text-white">-1</strong> คะแนน</p>
                    <p class="text-gray-400">(กรณี "ไม่มั่นใจ" จะไม่มีคะแนนพิเศษ)</p>
                </div>
                <p class="mt-3 text-sm text-yellow-300 pl-8">
                    <i class="fas fa-star"></i> พิเศษ: ผู้ที่ได้คะแนนหลักเต็ม จะได้รับโบนัส <strong class="text-white">+1</strong> คะแนนในหน้าสรุปผลสุดท้าย
                </p>
            </div>
            <button id="start-sync-game-btn" class="mt-6 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-2xl disabled:bg-gray-400" disabled>
                <i class="fas fa-play"></i> เริ่มเกม
            </button>
        </div>
    `;
    
    // เพิ่ม Event Listener ให้ Checkbox ซ่อน/แสดงคำอธิบาย
    const toggle = document.getElementById('confidence-scoring-toggle');
    const description = document.getElementById('confidence-scoring-description');
    toggle.addEventListener('change', () => {
        description.style.display = toggle.checked ? 'block' : 'none';
    });

    // แก้ไข Event Listener ของปุ่มเริ่มเกมให้บันทึกค่า setting นี้ด้วย
    document.getElementById('start-sync-game-btn').addEventListener('click', async () => {
        const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
        // อ่านค่าจาก Checkbox
        const confidenceEnabled = document.getElementById('confidence-scoring-toggle').checked;
        // ส่งค่า setting ไปพร้อมกับการเริ่มเกม
        await updateDoc(gameRef, {
            status: 'question',
            currentQuestionIndex: 0,
            questionDisplayedAt: serverTimestamp(),
            isConfidenceScoringEnabled: confidenceEnabled // <-- บันทึกค่านี้ลง Firestore
        });
    });
}

function updateAdminSyncView(gameData) {
    if (syncQuestionTimerInterval) clearInterval(syncQuestionTimerInterval);

    switch (gameData.status) {
        case 'lobby':
            renderSyncLobbyView(gameData.pin, gameData.shuffledQuiz.topic);
            const activePlayers = Object.entries(gameData.players || {}).filter(([name, data]) => data.status !== 'inactive');
            document.getElementById('player-count').textContent = activePlayers.length;
            document.getElementById('player-list-lobby').innerHTML = activePlayers.map(([name, data]) => `
                <div class="bg-black/30 px-3 py-1 rounded-full text-sm flex items-center gap-2">
                    <span>${name}</span>
                    <button data-player-name="${name}" class="kick-player-btn-sync text-red-300 hover:text-white font-bold" title="นำผู้เล่นนี้ออก">&times;</button>
                </div>
            `).join('') || '<p class="text-indigo-200">กำลังรอผู้เล่น...</p>';
            document.getElementById('start-sync-game-btn').disabled = activePlayers.length === 0;
            break;

        case 'question':
            const playersInGame = Object.values(gameData.players || {}).filter(p => p.status !== 'inactive');
            
            const answeredPlayers = playersInGame.filter(p => p.answered === true || p.answeredCurrentQuestion === true);
            const waitingPlayers = playersInGame.filter(p => !p.answered && !p.answeredCurrentQuestion);

            const answeredCount = answeredPlayers.length;
            const waitingCount = waitingPlayers.length;
            const totalActive = playersInGame.length;
            const allAnswered = answeredCount === totalActive && totalActive > 0;
            
            // ... (โค้ดเช็ค allAnswered เดิม คงไว้) ...
            if (allAnswered && gameData.status === 'question') {
                const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
                updateDoc(gameRef, { status: 'summary' }); 
                return;
            }

            if (document.getElementById('sync-player-management') === null) {
                renderAdminSyncQuestionView(gameData);
            } else {
                 // ... (โค้ด update player list เดิม คงไว้) ...
                 const answerCounter = document.getElementById('answer-counter');
                 if (answerCounter) { answerCounter.textContent = `${answeredCount}/${totalActive}`; }
                 
                 const showResBtn = document.getElementById('show-results-btn');
                 if (showResBtn) showResBtn.disabled = !allAnswered;

                 const playerListContainer = document.getElementById('sync-player-list');
                 if (playerListContainer) {
                     // ... (โค้ด render list เดิม) ...
                     playerListContainer.innerHTML = playersInGame.map(player => {
                         const hasAnswered = player.answered === true || player.answeredCurrentQuestion === true;
                         const bgColor = hasAnswered ? 'bg-green-500' : 'bg-gray-600';
                         const icon = hasAnswered ? '<i class="fas fa-check-circle"></i>' : '<i class="fas fa-hourglass-half"></i>';
                         return `<div class="flex items-center gap-2 px-3 py-1 rounded-full text-white text-sm ${bgColor} border border-white/10 shadow-sm">${icon}<span>${player.name}</span><button data-player-name="${player.name}" class="kick-player-btn-sync text-red-200 hover:text-white font-bold ml-1 hover:bg-red-500/20 rounded-full w-5 h-5 flex items-center justify-center" title="นำผู้เล่นนี้ออก">&times;</button></div>`;
                     }).join('');
                 }

                 // ... (โค้ด update waiting count เดิม) ...
                 const totalEl = document.getElementById('manage-total-players');
                 const waitingEl = document.getElementById('manage-waiting-players');
                 if (totalEl) totalEl.textContent = totalActive;
                 if (waitingEl) waitingEl.textContent = waitingCount;

                 const fastResponderBottom = document.getElementById('fast-responder-container'); 
                    const fastResponderHeader = document.getElementById('header-fast-responder');

                    // 1. ถ้าเปลี่ยนข้อใหม่ ให้เคลียร์ค่าที่จำไว้ เพื่อเริ่มหาคนเก่งรอบใหม่
                    if (gameData.currentQuestionIndex !== lastLockedQuestionIndex) {
                        lockedFastestResponderName = null;
                        lastLockedQuestionIndex = gameData.currentQuestionIndex;
                        if(fastResponderHeader) fastResponderHeader.innerHTML = '';
                        if(fastResponderBottom) fastResponderBottom.innerHTML = '';
                    }

                    // 2. Logic การหาและจำชื่อคนไวสุด (ทำงานเมื่อมีคนตอบ และยังไม่ได้จำชื่อใครไว้)
                    if (answeredPlayers.length > 0 && !lockedFastestResponderName) {
                        
                        // เรียงลำดับเวลา: ใครไม่มีเวลา (null) ให้ไปต่อท้าย (Infinity) ป้องกันการแย่งที่
                        const sortedByTime = [...answeredPlayers].sort((a, b) => {
                            const getTime = (p) => {
                                if (!p.submittedAt) return Infinity; 
                                return p.submittedAt.toDate ? p.submittedAt.toDate().getTime() : new Date(p.submittedAt).getTime();
                            };
                            return getTime(a) - getTime(b);
                        });

                        // จำชื่อคนแรกที่เรียงได้ (คนนี้คือแชมป์ของข้อนี้แน่นอน)
                        if (sortedByTime.length > 0) {
                            lockedFastestResponderName = sortedByTime[0].name;
                        }
                    }

                    // 3. ส่วนแสดงผล (ใช้ชื่อ lockedFastestResponderName ที่จำไว้เสมอ)
                    if (lockedFastestResponderName) {
                        
                        if (answeredPlayers.length === 1) {
                            // === กรณีมีคนตอบแค่ 1 คน: แสดงป้ายใหญ่สีเขียวด้านล่าง (เหมือนเดิม) ===
                            if(fastResponderHeader) fastResponderHeader.innerHTML = ''; // เคลียร์ข้างบน
                            if(fastResponderBottom) {
                                fastResponderBottom.innerHTML = `
                                   <div class="bg-gradient-to-r from-green-500 to-emerald-600 text-white text-center py-2 px-6 rounded-xl shadow-lg border-2 border-green-300 relative overflow-hidden flex items-center justify-center gap-3 animate-bounce">
                                       <div class="absolute top-0 left-0 w-full h-full bg-white opacity-20 transform skew-x-12"></div>
                                       <i class="fas fa-bolt text-yellow-300 text-2xl"></i>
                                       <span class="font-bold text-lg">คนส่งไวที่สุด:</span>
                                       <span class="font-extrabold text-2xl text-yellow-100 drop-shadow-md">${lockedFastestResponderName}</span>
                                   </div>
                                `;
                            }
                        } else {
                            // === กรณีมีคนตอบ 2 คนขึ้นไป: ย้ายชื่อคนแรกไปแปะป้ายเล็กด้านบน ===
                            if(fastResponderBottom) fastResponderBottom.innerHTML = ''; // เคลียร์ข้างล่าง
                            if(fastResponderHeader) {
                                fastResponderHeader.innerHTML = `
                                   <div class="flex items-center gap-2 bg-green-600/90 backdrop-blur-sm text-white px-4 py-1 rounded-full border border-green-400 shadow-lg animate-pulse transform transition-all ml-4">
                                       <i class="fas fa-bolt text-yellow-300"></i>
                                       <span class="text-sm font-bold">ไวสุด: <span class="text-yellow-100">${lockedFastestResponderName}</span></span>
                                   </div>
                                `;
                            }
                        }
                    } else {
                        // ยังไม่มีใครตอบ (เคลียร์ทั้งคู่)
                        if(fastResponderHeader) fastResponderHeader.innerHTML = '';
                        if(fastResponderBottom) fastResponderBottom.innerHTML = '';
                    }

                 // ============================================================
                 // ส่วนที่ 2: Logic แจ้งเตือนคนช้า (Slow Responder) - อันนี้คืออันเดิมที่หายไป
                 // ============================================================
                 const showSlow = gameData.showSlowResponders !== false;
                 const limit = parseInt(gameData.slowResponderCount || 3, 10);
                 const slowContainer = document.getElementById('slow-responder-container');
                 
                 if (slowContainer) {
                     // เงื่อนไข: เปิดโหมดแจ้งเตือน + เหลือคนน้อยกว่า Limit + มีคนเล่นมากกว่าคนรอ (ไม่ใช่เพิ่งเริ่ม)
                     if (showSlow && waitingCount > 0 && waitingCount <= limit && totalActive > waitingCount) {
                        const names = waitingPlayers.map(p => p.name).join(', ');
                        slowContainer.innerHTML = `
                            <div class="bg-red-600 text-white text-center py-4 px-6 rounded-xl shadow-2xl animate-pulse border-4 border-red-800 relative overflow-hidden mt-4">
                                <div class="absolute top-0 left-0 w-full h-full bg-white opacity-10 transform -skew-x-12"></div>
                                <div class="relative z-10">
                                    <div class="text-xl font-bold mb-2 flex items-center justify-center gap-2">
                                        <i class="fas fa-shipping-fast fa-lg"></i> 
                                        <span>รออีก ${waitingCount} คนสุดท้าย!</span>
                                    </div>
                                    <div class="text-3xl font-extrabold text-yellow-300 tracking-wide drop-shadow-md">
                                        ${names}
                                    </div>
                                    <div class="text-sm mt-2 opacity-90 font-medium bg-black/20 inline-block px-3 py-1 rounded-full">
                                        รีบตอบหน่อยจ้า! เพื่อนรออยู่
                                    </div>
                                </div>
                            </div>`;
                     } else {
                        slowContainer.innerHTML = ''; 
                     }
                 }
            }
            
            // Timer Logic
            const isTimerOn = gameData.timerMode === 'per_question' && gameData.questionDisplayedAt;
            if (isTimerOn) {
                const startTime = gameData.questionDisplayedAt.toDate().getTime();
                const duration = gameData.timerDuration * 1000;
                const adminEndTime = startTime + duration; 
                const timerBar = document.getElementById('sync-timer-bar');
                const countdown = document.getElementById('sync-timer-countdown');

                syncQuestionTimerInterval = setInterval(() => {
                    const now = Date.now();
                    const allPlayersDone = playersInGame.length > 0 && playersInGame.every(p => {
                        if (p.answered) return true; 
                        const bonus = p.timeBonusThisQuestion || 0;
                        return (now >= startTime + duration + bonus); 
                    });

                    if (allPlayersDone) {
                        clearInterval(syncQuestionTimerInterval);
                        const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
                        updateDoc(gameRef, { status: 'summary' });
                        return;
                    }
                    const adminRemaining = adminEndTime - now;
                    if (adminRemaining <= 0) {
                        if (timerBar) timerBar.style.width = '0%';
                        if (countdown) countdown.textContent = '0 (รอโบนัส)';
                    } else {
                        if (timerBar && countdown) {
                            const percentage = (adminRemaining / duration) * 100;
                            timerBar.style.width = `${percentage}%`;
                            countdown.textContent = Math.ceil(adminRemaining / 1000);
                        }
                    }
                }, 500);
            }
            break;
            
        case 'summary':
            const qIndexForSummary = gameData.currentQuestionIndex;
            const questionForSummary = gameData.shuffledQuiz.questions[qIndexForSummary];
            renderSyncSummaryView(gameData, questionForSummary, true);
            break;
            
        case 'results':
            const variant = gameData.gameVariant || 'classic';
            if (variant === 'reveal_at_end' || variant === 'anonymous_reveal_end') {
                renderAdminSyncDashboard(gameData, true, gameData.reviewQuestionIndex);
            } else {
                // ตรวจสอบว่าคำนวณคะแนนรอบนี้ไปหรือยัง
                if (gameData.status === 'results' && !gameData.scoresCalculated) {
                    (async () => {
                        try {
                            const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
                            // 1. ล็อคสถานะเพื่อป้องกันการคำนวณซ้ำ
                            await updateDoc(gameRef, { scoresCalculated: true }); 

                            const playersToCalculate = cachedPlayerData || {}; 
                            const totalQuestions = gameData.shuffledQuiz.questions.length;
                            const currentIndex = gameData.currentQuestionIndex;
                            const batch = writeBatch(db);

                            // --- 2. ระบบคำนวณกองกลาง (The Pot System) ---
                            let potFromLosers = 0;
                            const wagerWinners = []; 

                            Object.entries(playersToCalculate).forEach(([pid, player]) => {
                                if (player.status !== 'inactive') {
                                    const currentAns = (player.answers || []).find(a => a.questionIndex === currentIndex);
                                    
                                    if (currentAns && currentAns.powerupUsed === 'wagerMultiplier') {
                                        const wager = currentAns.wagerAmount || 0;
                                        if (currentAns.isCorrect) {
                                            wagerWinners.push(pid); 
                                        } else {
                                            potFromLosers += wager; 
                                        }
                                    }
                                }
                            });

                            const previousPot = gameData.centralPot || 0;
                            const totalPotToDistribute = previousPot + potFromLosers;
                            
                            let sharePerWinner = 0;
                            let newRemainder = totalPotToDistribute;

                            if (wagerWinners.length > 0 && totalPotToDistribute > 0) {
                                sharePerWinner = Math.floor(totalPotToDistribute / wagerWinners.length);
                                newRemainder = totalPotToDistribute % wagerWinners.length;
                            }

                            const newPublicLeaderboard = []; 

                            // 3. อัปเดตข้อมูลผู้เล่นแต่ละคน
                            Object.values(playersToCalculate).forEach(player => {
                                if (player.status !== 'inactive') {
                                    const playerName = player.name;
                                    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, playerName);
                                    
                                    // หาคำตอบของรอบนี้
                                    const currentAns = (player.answers || []).find(a => a.questionIndex === currentIndex);
                                    
                                    let pointsToAdd = 0;
                                    let updatedAnswers = player.answers;
                                    // ▼▼▼ [แก้ไขจุดนี้] ถ้าไม่มีคำตอบ (หมดเวลา) ให้รีเซ็ต Streak ▼▼▼
                                    let newStreak = player.correctStreak;
                                    if (!currentAns) {
                                        newStreak = 0; // ไม่ตอบ = Streak หลุด
                                    }
                                    // ▲▲▲
                                    
                                    if (wagerWinners.includes(playerName) && sharePerWinner > 0) {
                                        pointsToAdd = sharePerWinner;
                                        updatedAnswers = (player.answers || []).map(a => {
                                            if (a.questionIndex === currentIndex) {
                                                return { ...a, potBonus: sharePerWinner };
                                            }
                                            return a;
                                        });
                                        batch.update(playerRef, { answers: updatedAnswers });
                                    }

                                    const rawScore = player.score || 0;
                                    let finalPoints = player.totalPoints || 0;
                                    finalPoints += pointsToAdd;

                                    const isOnetMode = gameData.isOnetMode === true; // เช็คโหมด
                    if (!isOnetMode && totalQuestions > 0 && rawScore === totalQuestions) {
                        finalPoints += 1;
                    }

                                    batch.update(playerRef, { 
                                        score: rawScore,
                                        totalPoints: finalPoints,
                                        pointsLastRound: finalPoints,
                                        correctStreak: newStreak // <-- บันทึก Streak ใหม่ลง DB
                                    });

                                    newPublicLeaderboard.push({
                                        ...player, 
                                        score: rawScore,
                                        totalPoints: finalPoints, 
                                        pointsLastRound: finalPoints,
                                        answers: updatedAnswers, 
                                        correctStreak: newStreak // <-- ส่งค่าใหม่ไปแสดงผลที่หน้าจอทุกคน
                                    });
                                }
                            });
                            
                            batch.update(gameRef, { 
                                centralPot: newRemainder,
                                publicLeaderboard: newPublicLeaderboard 
                            });
                            
                            await batch.commit();
                            console.log(`Pot Distributed. Leaderboard Updated.`);

                        } catch (error) {
                            console.error("Error calculating final scores with pot:", error);
                        }
                    })();
                }
                renderAdminSyncDashboard(gameData, true, gameData.currentQuestionIndex);
            }
            break;
            
        case 'podium':
            const hasPlayersToCheck = Object.keys(gameData.players || {}).length > 0;
            const isAlreadySaved = gameData.resultsSaved === true;
            const shouldSaveConfig = gameData.shouldSaveResults === true;

            if (shouldSaveConfig && !isAlreadySaved && hasPlayersToCheck) {
                console.log("Detecting unsaved game upon resume... Saving now.");
                saveGameResultsAsSubmissions(gameData);
            }
            
            sessionStorage.removeItem('activeGameSession');
            const finalScoresAdmin = calculateFinalPodiumScores(gameData);
            showPodiumView(finalScoresAdmin, 'sync', gameData); 
            break;
    }
}

function renderAdminSyncQuestionView(gameData) {
    const qIndex = gameData.currentQuestionIndex;
    const question = gameData.shuffledQuiz.questions[qIndex];
    const totalQuestions = gameData.shuffledQuiz.questions.length;
    
    // 1. คำนวณตัวเลข
    const playersInGame = Object.values(gameData.players || {}).filter(p => p.status !== 'inactive');
    const answeredPlayers = playersInGame.filter(p => p.answered === true || p.answeredCurrentQuestion === true);
    const waitingPlayers = playersInGame.filter(p => !p.answered && !p.answeredCurrentQuestion);
    
    const answeredCount = answeredPlayers.length;
    const totalActive = playersInGame.length;      
    const waitingCount = waitingPlayers.length;    
    const allAnswered = answeredCount === totalActive && totalActive > 0;

    // ค่าเริ่มต้น
    const showSlowResponders = gameData.showSlowResponders !== false; 
    const slowLimit = parseInt(gameData.slowResponderCount || 3, 10);
    const potHTML = getCentralPotHTML(gameData);

    // Options HTML
    const questionType = question.questionType || gameData.shuffledQuiz.quizType;
    let optionsHTML = '';
    if ((questionType === 'short_answer' || questionType === 'fill_in_no_choices') && question.options && question.options.length > 0) {
        optionsHTML = `<div class="col-span-full text-center p-8 bg-black/20 rounded-lg border-2 border-dashed border-white/30"><i class="fas fa-eye-slash text-4xl text-yellow-300 mb-4"></i><p class="text-xl font-bold text-white">ตัวเลือกถูกซ่อนอยู่</p></div>`;
    } else {
        optionsHTML = (question.options || []).map(opt => `<div class="p-4 rounded-lg text-xl text-center bg-white/30 backdrop-blur-sm border border-white/10 shadow-sm">${opt}</div>`).join('');
    }

    let timerHTML = '';
    if (gameData.timerMode === 'per_question') {
        timerHTML = `<div class="my-4"><div id="sync-timer-bar-container" class="w-full bg-gray-200/50 rounded-full h-2.5"><div id="sync-timer-bar" class="bg-yellow-400 h-2.5 rounded-full" style="width: 100%"></div></div><p class="text-center text-sm text-yellow-300 mt-1">เหลือเวลา <span id="sync-timer-countdown" class="font-bold">${gameData.timerDuration}</span> วินาที</p></div>`;
    }
    
    // Player List HTML
    const playerListHTML = playersInGame.map(player => {
         const hasAnswered = player.answered === true || player.answeredCurrentQuestion === true;
         const bgColor = hasAnswered ? 'bg-green-500' : 'bg-gray-600';
         const icon = hasAnswered ? '<i class="fas fa-check-circle"></i>' : '<i class="fas fa-hourglass-half"></i>';
         return `<div class="flex items-center gap-2 px-3 py-1 rounded-full text-white text-sm ${bgColor} border border-white/10 shadow-sm">${icon}<span>${player.name}</span><button data-player-name="${player.name}" class="kick-player-btn-sync text-red-200 hover:text-white font-bold ml-1 hover:bg-red-500/20 rounded-full w-5 h-5 flex items-center justify-center" title="นำผู้เล่นนี้ออก">&times;</button></div>`;
    }).join('');

    // Slow Responders HTML
    let slowRespondersHTML = '';
    if (showSlowResponders && waitingCount > 0 && waitingCount <= slowLimit && totalActive > waitingCount) {
        const names = waitingPlayers.map(p => p.name).join(', ');
        slowRespondersHTML = `
            <div class="mt-6 w-full max-w-4xl mx-auto px-4 fade-in" id="slow-responder-container">
                <div class="bg-red-600 text-white text-center py-3 px-6 rounded-xl shadow-2xl animate-pulse border-4 border-red-800 relative overflow-hidden">
                    <div class="relative z-10">
                        <div class="text-lg font-bold mb-1 flex items-center justify-center gap-2">
                            <i class="fas fa-shipping-fast"></i> <span>รออีก ${waitingCount} คนสุดท้าย!</span>
                        </div>
                        <div class="text-2xl font-extrabold text-yellow-300 drop-shadow-md">${names}</div>
                    </div>
                </div>
            </div>
        `;
    } else {
        slowRespondersHTML = '<div id="slow-responder-container" class="mt-6 w-full max-w-4xl mx-auto px-4"></div>';
    }

    // ▼▼▼ [เพิ่มใหม่] สร้าง Container เปล่าๆ สำหรับคนส่งคนแรก ▼▼▼
    const fastResponderHTML = '<div id="fast-responder-container" class="mt-2 w-full max-w-4xl mx-auto px-4"></div>';
    // ▲▲▲ [สิ้นสุดส่วนที่เพิ่ม] ▲▲▲

    liveGameView.innerHTML = `
        <div class="bg-indigo-700 text-white rounded-lg p-8 flex flex-col h-full">
            
            <div class="flex justify-between items-center text-lg flex-shrink-0">
                <div class="flex items-center gap-4">
    <span>ข้อที่ ${qIndex + 1} / ${totalQuestions}</span>
    <span class="bg-white/20 px-3 py-1 rounded-full text-base font-mono"><i class="fas fa-key mr-2 opacity-70"></i>${gameData.pin}</span>
    ${potHTML}
    <div id="header-fast-responder" class="transition-all duration-500"></div>
</div>
                <div class="flex items-center gap-4">
                    <span class="bg-white/20 px-3 py-1 rounded-full text-base">
                        ตอบแล้ว: <span id="answer-counter" class="font-bold">${answeredCount}/${totalActive}</span>
                    </span>
                    <button id="sync-manage-players-btn" class="text-xs bg-white/20 hover:bg-white/40 px-2 py-1 rounded-md border border-white/30">
                        <i class="fas fa-users-cog mr-1"></i> จัดการ
                    </button>
                    <button id="end-sync-game-btn" class="bg-red-600 text-white py-1 px-3 rounded-md hover:bg-red-700 text-sm">จบเกม</button>
                </div>
            </div>

            <div id="sync-player-management" class="hidden w-full bg-black/20 p-4 rounded-lg mt-4 text-sm border border-white/10 shadow-inner">
                <div class="flex flex-wrap items-center justify-between mb-3 pb-2 border-b border-white/10 gap-4">
                    <div class="flex items-center gap-4">
                        <label class="flex items-center cursor-pointer text-yellow-300 hover:text-yellow-200 select-none bg-black/20 px-2 py-1 rounded">
                            <input type="checkbox" id="toggle-slow-responders" class="h-4 w-4 text-indigo-600 rounded" ${showSlowResponders ? 'checked' : ''}>
                            <span class="ml-2 font-semibold"><i class="fas fa-bell"></i> แจ้งเตือนคนช้า</span>
                        </label>
                        
                        <div class="flex items-center gap-2 text-gray-300">
                            <span>เตือนเมื่อเหลือ:</span>
                            <input type="number" id="input-slow-count" value="${slowLimit}" min="1" max="${Math.max(1, totalActive - 1)}" class="w-12 p-0.5 text-black text-center rounded font-bold">
                            <span>คน</span>
                        </div>
                    </div>
                    <button id="close-manage-btn" class="text-gray-400 hover:text-white px-2"><i class="fas fa-chevron-up"></i> ซ่อน</button>
                </div>

                <div id="sync-player-list" class="flex flex-wrap justify-start gap-2 max-h-32 overflow-y-auto custom-scrollbar">
                    ${playerListHTML}
                </div>
            </div>
            ${timerHTML} 
            
            <div class="flex-grow flex flex-col items-center justify-center relative">
                <h2 class="text-3xl font-bold mb-8 text-center leading-tight max-w-5xl">${question.questionText || question.stem}</h2>
                <div class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-4">${optionsHTML}</div>
                
                ${fastResponderHTML}
                ${slowRespondersHTML}
            </div>

            <div class="text-center mt-8 flex items-center justify-center gap-4 flex-shrink-0">
                <button id="open-sync-scratchpad-btn" class="bg-white/20 hover:bg-white/30 text-white font-bold py-3 px-8 rounded-lg text-xl flex items-center gap-2 backdrop-blur-sm border border-white/20">
                    <i class="fas fa-pencil-alt"></i> ทดเลข
                </button>
                <button id="show-results-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-8 rounded-lg text-2xl disabled:bg-gray-500 disabled:cursor-not-allowed shadow-lg" ${!allAnswered ? 'disabled' : ''}>
                    <i class="fas fa-chart-bar mr-2"></i> แสดงผลลัพธ์
                </button>
            </div>
        </div>
    `;

    if (window.MathJax) MathJax.typesetPromise();
    
    const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);

    document.getElementById('show-results-btn').addEventListener('click', async () => { await updateDoc(gameRef, { status: 'summary' }); });
    document.getElementById('open-sync-scratchpad-btn').onclick = () => { openScratchpad(question, question.options || []); };
    
    // Toggle Area
    const manageContainer = document.getElementById('sync-player-management');
    document.getElementById('sync-manage-players-btn').addEventListener('click', () => { manageContainer.classList.remove('hidden'); });
    document.getElementById('close-manage-btn').addEventListener('click', () => { manageContainer.classList.add('hidden'); });

    document.getElementById('toggle-slow-responders').addEventListener('change', async (e) => {
        await updateDoc(gameRef, { showSlowResponders: e.target.checked });
    });
    document.getElementById('input-slow-count').addEventListener('change', async (e) => {
        let val = parseInt(e.target.value); if (val < 1) val = 1; await updateDoc(gameRef, { slowResponderCount: val });
    });
    const endBtn = document.getElementById('end-sync-game-btn');
    if (endBtn) { endBtn.onclick = () => { showConfirmation('คุณแน่ใจหรือไม่ว่าต้องการจบเกมนี้?', async () => { await updateDoc(gameRef, { status: 'podium' }); }); }; }
}

function renderSyncLeaderboardView(gameData, isAdmin) {
    const players = Object.values(gameData.players || {});
    players.sort((a, b) => b.score - a.score);
    const top5 = players.slice(0, 5);

    let actionButtonHTML = '';
    if (isAdmin) {
        const isLastQuestion = gameData.currentQuestionIndex >= gameData.shuffledQuiz.questions.length - 1;
        actionButtonHTML = `<button id="next-sync-question-btn" class="bg-gray-800 hover:bg-black text-white font-bold py-3 px-8 rounded-lg text-2xl mt-8">${isLastQuestion ? 'ดูผลสรุปสุดท้าย' : 'ข้อต่อไป'} <i class="fas fa-arrow-right"></i></button>`;
    } else {
        actionButtonHTML = `<p class="mt-8 text-lg text-indigo-200">เตรียมตัวสำหรับข้อต่อไป...</p>`;
    }

    liveGameView.innerHTML = `
        <div class="bg-indigo-700 text-white rounded-lg p-8 flex flex-col h-full items-center justify-between">
            <h2 class="text-4xl font-bold mb-6">ตารางคะแนน</h2>
            <div class="w-full max-w-lg space-y-3">${top5.map((player, index) => `<div class="bg-black/20 p-3 rounded-lg flex justify-between items-center text-xl"><span class="font-semibold">${index + 1}. ${player.name}</span><span class="font-bold">${player.score}</span></div>`).join('')}</div>
            ${actionButtonHTML}
        </div>
    `;

    if (isAdmin) {
        document.getElementById('next-sync-question-btn').addEventListener('click', async () => {
            const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
            const nextIndex = gameData.currentQuestionIndex + 1;

            if (nextIndex < gameData.shuffledQuiz.questions.length) {
                const playerUpdates = {};
                Object.keys(gameData.players).forEach(name => { playerUpdates[`players.${name}.answered`] = false; });
                await updateDoc(gameRef, { 
    status: 'question', 
    currentQuestionIndex: nextIndex,
    questionDisplayedAt: serverTimestamp(),
    scoresCalculated: false // <--- เพิ่มบรรทัดนี้เพื่อรีเซ็ตค่าเมื่อเริ่มข้อใหม่
});
            } else {
                await updateDoc(gameRef, { status: 'podium' });
            }
        });
    }
}

async function handleJoinSyncGame() {
    const pin = prompt("กรุณาป้อนรหัส Sync Game (2 หลัก):");
    if (!pin || pin.trim().length !== 2) {
        showMessage("รหัสไม่ถูกต้อง");
        return;
    }

    try {
        const gamesRef = collection(db, `artifacts/${appId}/public/data/syncGames`);
        const q = query(gamesRef, where("pin", "==", pin.trim()), where("status", "==", "lobby"));
        const snapshot = await getDocs(q);

        if (snapshot.empty) {
            showMessage("ไม่พบ Sync Game ด้วยรหัสนี้ หรือกิจกรรมได้เริ่มไปแล้ว");
            return;
        }

        const gameDoc = snapshot.docs[0];
        currentLiveGameId = gameDoc.id; // ใช้ตัวแปรกลางเดิม
        const gameData = gameDoc.data();

        // ดึงข้อมูล Project จาก quizId ที่อยู่ใน gameData
        const quizRef = doc(db, `artifacts/${appId}/public/data/quizzes`, gameData.quizId);
        const quizSnap = await getDoc(quizRef);
        if (!quizSnap.exists()) throw new Error("ไม่พบข้อมูลแบบทดสอบที่ใช้ในเกมนี้");
        const quizData = quizSnap.data();
        
        const projectRef = doc(db, `artifacts/${appId}/public/data/projects`, quizData.projectId);
        const projectSnap = await getDoc(projectRef);
        if (!projectSnap.exists()) throw new Error("ไม่พบข้อมูลโปรเจค");

        currentQuizData = gameData.shuffledQuiz; // ใช้ข้อสอบที่สลับแล้วจากในเกม
        const projectData = projectSnap.data();

        // *** จุดเปลี่ยนสำคัญ: เรียกใช้หน้าจอเลือกผู้เล่นของ Team Mode ***
        showView('student-team-join'); // สั่งให้แสดงหน้าจอ checkbox
        showTeamPlayerSelection(projectData.students, quizData.topic);

        // เปลี่ยน Event Listener ของปุ่มยืนยันให้เรียกฟังก์ชันของ Sync Mode
        const confirmBtn = document.getElementById('confirm-team-players-btn');
        confirmBtn.onclick = confirmAndJoinSyncGame; // เปลี่ยนให้ไปเรียกฟังก์ชันใหม่

    } catch (error) {
        console.error("Error joining sync game:", error);
        showMessage("เกิดข้อผิดพลาด: " + error.message);
    }
}

function updateStudentSyncView(gameData) {
    const myName = localTeamPlayers[0];
    const myData = gameData.players[myName] || {}; 

    if (syncQuestionTimerInterval) clearInterval(syncQuestionTimerInterval);
    
    switch (gameData.status) {
        case 'lobby':
            showView('live-game');
            liveGameView.innerHTML = `<div class="bg-indigo-700 text-white rounded-lg p-8 text-center flex flex-col items-center justify-center h-full"><h2>เข้าร่วมสำเร็จ!</h2><p>รอผู้ควบคุมเริ่มเกม...</p></div>`;
            break;
            
        case 'question':
            // ตรวจสอบว่ามีการเปลี่ยนข้อใหม่หรือไม่
            if (gameData.currentQuestionIndex !== lastSeenQuestionIndex) {
                console.log("New question detected. Cleaning up.");
                
                // --- [จุดที่แก้ไข: ย้ายการรีเซ็ตลำดับมาไว้ตรงนี้] ---
                // จะรีเซ็ตเป็นคนแรก เฉพาะเมื่อ "ขึ้นข้อใหม่" เท่านั้น
                localPlayerTurnIndex = 0; 
                // -------------------------------------------

                // 1. ล้าง SessionStorage
                sessionStorage.removeItem('powerupUsedThisTurn'); 
                sessionStorage.removeItem('onSecondChance');
                sessionStorage.removeItem('pollUsedThisTurn'); 
                
                const oldMarketFlagPrefix = 'freeMarketEntryUsed_q' + lastSeenQuestionIndex;
                const oldPowerupFlagPrefix = 'powerupUsed_q' + lastSeenQuestionIndex; 
                const oldHiddenOptionsPrefix = 'hiddenOptions_q' + lastSeenQuestionIndex;

                Object.keys(sessionStorage).forEach(key => {
                    if (key.startsWith(oldMarketFlagPrefix) || key.startsWith(oldPowerupFlagPrefix) || key.startsWith(oldHiddenOptionsPrefix)) {
                        sessionStorage.removeItem(key);
                    }
                });

                // 2. ล้างสถานะค้างใน Database
                if (myData.isJinxed || myData.isForcedConfident || (myData.timeBonusThisQuestion || 0) > 0) {
                    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, myName);
                    updateDoc(playerRef, {
                        isJinxed: false,
                        isForcedConfident: false,
                        timeBonusThisQuestion: 0
                    }).catch(e => console.error("Auto-cleanup failed:", e));
                }

                lastSeenQuestionIndex = gameData.currentQuestionIndex;
            }

            // --- [จุดที่แก้ไข: ลบบรรทัดนี้ออก] ---
            // localPlayerTurnIndex = 0; <--- ลบออก เพราะมันทำให้เด้งกลับทุกครั้งที่ซื้อของ
            // -------------------------------

            const allLocalPlayersAnswered = localTeamPlayers.every(name => gameData.players[name]?.answered === true);
            
            if (allLocalPlayersAnswered) {
                liveGameView.innerHTML = `<div class="bg-indigo-700 text-white rounded-lg p-8 text-center flex flex-col items-center justify-center h-full"><h2>ส่งคำตอบครบแล้ว!</h2><p>รอผู้เล่นคนอื่นสักครู่...</p></div>`;
            } else {
                renderStudentSyncQuestionView(gameData);
                
                // Logic Timer (เหมือนเดิม)
                if (gameData.timerMode === 'per_question') {
                    if (!gameData.questionDisplayedAt) return; 
                    
                    const startTime = gameData.questionDisplayedAt.toDate().getTime();
                    const duration = gameData.timerDuration * 1000;

                    const myBonuses = localTeamPlayers.map(name => gameData.players[name]?.timeBonusThisQuestion || 0);
                    const activeBonusMs = Math.max(...myBonuses, 0);
                    const endTime = startTime + duration + activeBonusMs; 

                    syncQuestionTimerInterval = setInterval(() => {
                        const remaining = endTime - Date.now();
                        const timerBar = document.getElementById('sync-timer-bar');
                        const countdown = document.getElementById('sync-timer-countdown');
                        if (remaining <= 0) {
                            clearInterval(syncQuestionTimerInterval);
                            if (timerBar) timerBar.style.width = '0%';
                            if (countdown) countdown.textContent = '0';
                            
                            // ตรวจสอบว่าใครที่ยังไม่ได้ตอบเมื่อเวลาหมด
                            const currentPlayer = localTeamPlayers[localPlayerTurnIndex];
                            if (gameData.players[currentPlayer]?.answered !== true) {
                                liveGameView.innerHTML = `
                                    <div class="bg-indigo-700 text-white rounded-lg p-8 text-center flex flex-col items-center justify-center h-full">
                                        <i class="fas fa-clock fa-3x text-yellow-300 mb-4"></i>
                                        <h2 class="text-3xl font-bold">หมดเวลา!</h2>
                                        <p class="mt-4 text-xl text-indigo-200">รอผู้ควบคุม... (คำตอบของคุณไม่ถูกบันทึก)</p>
                                    </div>
                                `;
                            }
                        } else {
                            if (timerBar && countdown) {
                                const totalDurationWithBonus = duration + activeBonusMs;
                                const percentage = totalDurationWithBonus > 0 ? (remaining / totalDurationWithBonus) * 100 : 0;
                                timerBar.style.width = `${percentage}%`;
                                countdown.textContent = Math.ceil(remaining / 1000);
                            }
                        }
                    }, 500); 
                }
            }
            break;
        
        case 'summary':
            liveGameView.innerHTML = `
                <div class="bg-indigo-700 text-white rounded-lg p-8 text-center flex flex-col items-center justify-center h-full">
                    <div class="loader"></div>
                    <h2 class="text-3xl font-bold mt-4">ทุกคนตอบครบแล้ว!</h2>
                    <p class="mt-4 text-xl text-indigo-200">รอผู้ควบคุมแสดงผลลัพธ์...</p>
                </div>
            `;
            break;
            
       case 'results':
            localPlayerTurnIndex = 0; // รีเซ็ตตอนหน้าสรุปผลได้ (เพื่อเตรียมพร้อมสำหรับรอบหน้า)
            const variant = gameData.gameVariant || 'classic';
            
            if (variant === 'anonymous' || variant === 'anonymous_reveal_end') {
                renderStudentAnonymousResultsView(gameData, gameData.currentQuestionIndex);
            } else if (variant === 'competition') {
                renderStudentCompetitionResultsView(gameData, gameData.currentQuestionIndex); 
            } else {
                renderStudentSyncResultsView(gameData);
            }
            break;
            
        case 'podium':
            releaseWakeLock();
            stopDimTimer();
            exitFullscreen();
            isQuizActive = false;
            document.removeEventListener('fullscreenchange', handleFullscreenChange);
            document.removeEventListener('visibilitychange', handleVisibilityChange);
            sessionStorage.removeItem('activeGameSession');
            
            const currentHTML = liveGameView.innerHTML;
            const isAlreadyShowingResults = currentHTML.includes('สรุปคะแนนของคุณ') || currentHTML.includes('สรุปอันดับ');

            if (!isAlreadyShowingResults) {
                const finalVariant = gameData.gameVariant || 'classic';
                const lastQIndex = gameData.shuffledQuiz.questions.length - 1; 

                if (finalVariant === 'anonymous' || finalVariant === 'anonymous_reveal_end') {
                    renderStudentAnonymousResultsView(gameData, lastQIndex);
                } else if (finalVariant === 'competition') {
                    renderStudentCompetitionResultsView(gameData, lastQIndex); 
                } else {
                    renderStudentSyncResultsView(gameData);
                }
            }

            const allParagraphs = liveGameView.querySelectorAll('p');
            allParagraphs.forEach(p => {
                if (p.textContent.includes('เตรียมพบกับผลสรุปสุดท้าย') || 
                    p.textContent.includes('รอผู้ควบคุม')) {
                    p.style.display = 'none';
                }
            });

            if (!document.getElementById('student-exit-game-btn')) {
                const exitButtonHTML = `
                    <div class="w-full flex justify-center mt-8 pb-8 fade-in">
                        <button id="student-exit-game-btn" onclick="window.location.reload()" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg transition-transform transform hover:scale-105 flex items-center gap-2">
                            <i class="fas fa-sign-out-alt"></i> จบเกมและกลับหน้าหลัก
                        </button>
                    </div>
                `;
                if (liveGameView.firstElementChild) {
                    liveGameView.firstElementChild.insertAdjacentHTML('beforeend', exitButtonHTML);
                } else {
                    liveGameView.insertAdjacentHTML('beforeend', exitButtonHTML);
                }
            }
            break;
    }
}

function renderStudentSyncResultsView(gameData) {
    // 1. ดึงผู้เล่น "ทุกคน" ในห้อง
    let allPlayersSource = [];
    if (gameData.publicLeaderboard && Array.isArray(gameData.publicLeaderboard) && gameData.publicLeaderboard.length > 0) {
        allPlayersSource = gameData.publicLeaderboard;
    } else {
        allPlayersSource = Object.values(gameData.players || {});
    }

    const variant = gameData.gameVariant || 'classic';
    const isRevealAtEndMode = (variant === 'reveal_at_end' || variant === 'anonymous_reveal_end');
    const questions = gameData.shuffledQuiz.questions;
    
    const limitIndex = (isRevealAtEndMode && gameData.reviewQuestionIndex !== undefined) 
                       ? gameData.reviewQuestionIndex 
                       : gameData.currentQuestionIndex;
    
    const questionIndexToCheck = (isRevealAtEndMode) ? gameData.reviewQuestionIndex : gameData.currentQuestionIndex;

    // 2. คำนวณคะแนน
    const allPlayersCalculated = allPlayersSource.map(p => {
        const answersToConsider = (p.answers || []).filter(ans => ans.questionIndex <= limitIndex);
        let realScore = 0;
        let points = 0; 
        if (isRevealAtEndMode) {
            realScore = answersToConsider.filter(a => a.isCorrect).length;
            points = answersToConsider.reduce((sum, a) => sum + (a.pointsAwarded || 0), 0);
        } else {
            realScore = p.score || 0;
            points = p.totalPoints || 0;
        }
        
        // --- [FIX LOGIC START] คำนวณ Streak แบบเข้มงวด (เหมือน Admin) ---
        let dynamicStreak = 0;
        
        for (let i = 0; i <= limitIndex; i++) {
             const ans = answersToConsider.find(a => a.questionIndex === i);
             if (ans) {
                const isComboBreaker = (ans.powerupUsed && ans.powerupUsed !== 'wagerMultiplier') || ans.usedBuyTime;
                if (ans.isCorrect) {
                     dynamicStreak = isComboBreaker ? 0 : dynamicStreak + 1;
                } else {
                    dynamicStreak = 0;
                }
             } else {
                 // ถ้าไม่มีคำตอบในรอบนี้ = ผิด = รีเซ็ต
                 dynamicStreak = 0;
             }
        }
        // --- [FIX LOGIC END] ---

        return { ...p, realScore, totalPoints: points, answers: p.answers, correctStreak: dynamicStreak };
    });

    const maxPoints = Math.max(...allPlayersCalculated.map(p => p.totalPoints), -Infinity);
    const maxRawScore = Math.max(...allPlayersCalculated.map(p => p.realScore), -Infinity);
    const isMarketMode = gameData.isBlackMarketEnabled === true;

    // จัดเรียงและคำนวณอันดับ
    const sortedAllPlayers = [...allPlayersCalculated].sort((a, b) => {
        if (isMarketMode) {
            const pointsDiff = b.totalPoints - a.totalPoints;
            if (pointsDiff !== 0) return pointsDiff;
            const scoreDiff = b.realScore - a.realScore;
            if (scoreDiff !== 0) return scoreDiff;
            return (a.name || '').localeCompare(b.name || '', 'th');
        } else {
            const pointsDiff = b.totalPoints - a.totalPoints;
            if (pointsDiff !== 0) return pointsDiff;
            const scoreDiff = b.realScore - a.realScore;
            if (scoreDiff !== 0) return scoreDiff;
            return (a.name || '').localeCompare(b.name || '', 'th');
        }
    });

    let currentRank = 1;
    for (let i = 0; i < sortedAllPlayers.length; i++) {
        if (i > 0) {
            const prev = sortedAllPlayers[i - 1];
            const curr = sortedAllPlayers[i];
            let isTied = false;
            if (isMarketMode) {
                 isTied = (curr.totalPoints === prev.totalPoints) && (curr.realScore === prev.realScore);
            } else {
                 isTied = (curr.totalPoints === prev.totalPoints) && (curr.realScore === prev.realScore);
            }

            if (!isTied) {
                currentRank = i + 1;
            }
        }
        sortedAllPlayers[i].displayRank = currentRank;
    }

    // กรองเฉพาะผู้เล่นในเครื่องนี้
    let myPlayersToRender = sortedAllPlayers.filter(p => localTeamPlayers.includes(p.name));
    myPlayersToRender.sort((a, b) => (b.totalPoints || 0) - (a.totalPoints || 0));

    let footerMessageHTML = '';
    const isLastQuestion = (isRevealAtEndMode) ? (limitIndex >= questions.length - 1) : (gameData.currentQuestionIndex >= questions.length - 1);
    
    if (gameData.status === 'podium') {
        footerMessageHTML = ''; 
    } else if (isLastQuestion) {
        footerMessageHTML = `<p class="mt-8 text-xl font-bold text-yellow-300 animate-pulse">เตรียมพบกับผลสรุปสุดท้าย!</p>`;
    } else {
        footerMessageHTML = `<p class="mt-8 text-lg text-indigo-200">รอผู้ควบคุมไปข้อต่อไป...</p>`;
    }

    const potHTML = getCentralPotHTML(gameData);

    const resultsHTML = `
        <div class="bg-indigo-700 text-white rounded-lg p-6 flex flex-col h-full items-center justify-center">
            
            <div class="mb-4 scale-110">${potHTML}</div>

            <h2 class="text-3xl font-bold mb-6 text-center">สรุปคะแนนของคุณ</h2>
            <div class="w-full max-w-lg space-y-3">
                ${myPlayersToRender.map((player, index) => {
                    let bgClass = 'bg-white text-gray-800';
                    const currentAnswer = (player.answers || []).find(a => a.questionIndex === questionIndexToCheck);

                    let potBonusHTML = '';
                    if (currentAnswer && currentAnswer.potBonus > 0) {
                        potBonusHTML = `<span class="text-xs bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded-full font-bold ml-1 shadow-sm border border-yellow-300" title="ส่วนแบ่งจากคนตอบผิด">+${currentAnswer.potBonus} Pot</span>`;
                    }

                    let turnStatusIconsHTML = '';
                    if (currentAnswer) {
                        if (currentAnswer.wasForced) turnStatusIconsHTML += '<span title="โดนบังคับ">👻</span>';
                        if (currentAnswer.wasJinxed) turnStatusIconsHTML += '<span title="โดนคำสาป">😈</span>';
                        if (currentAnswer.usedBuyTime) turnStatusIconsHTML += '<span title="ใช้เวลา">⏳</span>';
                        const item = currentAnswer.powerupUsed;
                        if (item) {
                             const icons = { 'poll': '📊', 'cutOne': '✂️', 'insurance': '🛡️', 'fiftyFifty': '🌗', 'wagerMultiplier': '💰', 'secondChance': '🔁', 'revealOptions': '👁️' };
                             if (icons[item]) turnStatusIconsHTML += `<span title="ใช้ ${item}">${icons[item]}</span>`;
                        }
                    }

                    if (currentAnswer) {
                        const isCorrect = currentAnswer.isCorrect;
                        const isConfident = (currentAnswer.wasConfident === true || currentAnswer.wasConfident === 'confident');
                        const powerupUsed = currentAnswer.powerupUsed;
                        if (powerupUsed === 'wagerMultiplier') {
                            bgClass = isCorrect ? 'bg-yellow-300 text-yellow-900 font-bold' : 'bg-red-700 text-white font-bold';
                        } else if (isConfident) {
                            bgClass = isCorrect ? 'bg-[#4ADE80] text-green-900 font-bold' : 'bg-[#EF4444] text-white font-bold';
                        } else if (isCorrect) {
                            bgClass = 'bg-[#DCFCE7] text-green-900';
                        } else {
                            bgClass = 'bg-red-100 text-red-900';
                        }
                    } else {
                        // [เพิ่ม] ถ้าไม่ได้ตอบ (หมดเวลา) ให้พื้นหลังเป็นสีแดง (ผิด)
                        bgClass = 'bg-red-100 text-red-900';
                    }
                    
                    let punishmentHTML = '';
                    if (currentAnswer && currentAnswer.powerupUsed === 'wagerMultiplier' && !currentAnswer.isCorrect) {
                        punishmentHTML = `
                            <div class="mt-2 p-2 bg-red-600 text-white rounded-lg text-center animate-bounce">
                                <i class="fas fa-hand-holding-usd fa-2x mb-1"></i>
                                <p class="text-sm font-bold">เดิมพันผิด!</p>
                                <p class="text-lg font-extrabold text-yellow-300">💸 เงินถูกยึดเข้ากองกลาง!</p>
                            </div>
                        `;
                    }

                    const pointsDisplay = player.totalPoints >= 0 
                        ? `(+${player.totalPoints.toLocaleString()})` 
                        : `(${player.totalPoints.toLocaleString()})`;

                    let statusIconHTML = '';
                    const totalAnswersSoFar = player.answers.length;
                    const totalQuestionsAsked = limitIndex + 1;

                    if (totalAnswersSoFar > 0) {
                        if (isMarketMode) {
                            if (player.totalPoints === maxPoints && maxPoints > 0) statusIconHTML += '<span class="text-yellow-500 ml-1 text-2xl drop-shadow-md">👑</span>';
                            if (player.realScore === maxRawScore && maxRawScore > 0) statusIconHTML += '<span class="text-blue-500 ml-1 text-2xl drop-shadow-md">🎓</span>';
                        } else {
                            if (player.realScore === totalQuestionsAsked) statusIconHTML += '<span class="text-yellow-400 ml-1 text-xl drop-shadow-md">⭐</span>';
                        }
                        
                        const hasGoodIcon = statusIconHTML.includes('👑') || statusIconHTML.includes('🎓') || statusIconHTML.includes('⭐');
                        if (!hasGoodIcon && player.totalPoints < 0) statusIconHTML += '<span class="text-red-500 ml-1 text-xl">⚠️</span>';
                    }
                    
                    let fireIconHTML = '';
                    const turnUsedBuyTime = currentAnswer && currentAnswer.usedBuyTime;
                    const turnUsedItem = currentAnswer && currentAnswer.powerupUsed && currentAnswer.powerupUsed !== 'wagerMultiplier';

                    if (!turnUsedBuyTime && !turnUsedItem) {
                        // --- [ใช้ค่าที่คำนวณใหม่] ---
                        const pStreak = player.correctStreak || 0;
                        if (pStreak >= 3) {
                            fireIconHTML = `<span class="ml-2 text-orange-500 animate-pulse font-bold">🔥 x${pStreak}</span>`;
                        }
                    }

                    return `
                    <div class="${bgClass} p-3 rounded-lg flex flex-col gap-2 border-2 border-black/10 shadow-sm transition-all">
                        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
                            
                            <div class="flex items-center gap-3 w-full sm:w-auto">
                                <div class="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-black/10 font-bold text-lg">
                                    ${player.displayRank}
                                </div>
                                <div class="flex flex-wrap items-center gap-1 min-w-0">
                                    <span class="font-bold text-lg truncate break-words max-w-[180px] sm:max-w-xs leading-tight">
                                        ${player.name}
                                    </span>
                                    ${turnStatusIconsHTML} ${statusIconHTML} ${fireIconHTML}
                                </div>
                            </div>

                            <div class="flex items-center justify-between sm:justify-end w-full sm:w-auto pl-11 sm:pl-0">
                                <span class="text-sm opacity-70 sm:hidden">คะแนนรวม:</span>
                                <div class="text-right whitespace-nowrap">
                                    <span class="font-bold text-xl">${player.realScore}</span>
                                    <span class="text-sm opacity-80 ml-1 font-medium">${pointsDisplay}</span>
                                    ${potBonusHTML}
                                </div>
                            </div>

                        </div>
                        ${punishmentHTML}
                    </div>
                `}).join('')}
            </div>
            ${footerMessageHTML} 
        </div>
    `;
    liveGameView.innerHTML = resultsHTML;
}

function renderStudentAnonymousResultsView(gameData, questionIndexToShow) {
    let players = [];
    if (gameData.publicLeaderboard) {
        players = gameData.publicLeaderboard;
    } else {
        players = Object.values(gameData.players || {});
    }

    const variant = gameData.gameVariant || 'classic';
    const isRevealAtEndMode = (variant === 'reveal_at_end' || variant === 'anonymous_reveal_end');
    const isRevealed = (gameData.isAnonymousRevealed === true);
    const questions = gameData.shuffledQuiz.questions;
    const limitIndex = (isRevealAtEndMode && gameData.reviewQuestionIndex !== undefined) ? gameData.reviewQuestionIndex : questionIndexToShow;

    const playersWithScores = players.map(p => {
        const answersToConsider = (p.answers || []).filter(ans => ans.questionIndex <= limitIndex);
        let realScore = 0, points = 0;
        if (isRevealAtEndMode) {
            realScore = answersToConsider.filter(a => a.isCorrect).length;
            points = answersToConsider.reduce((sum, a) => sum + (a.pointsAwarded || 0), 0);
        } else {
            realScore = p.score || 0;
            points = p.totalPoints || 0;
        }
        
        // --- [FIX LOGIC START] คำนวณ Streak แบบเข้มงวดสำหรับโหมด Anonymous ---
        let dynamicStreak = 0;
        
        // วนลูปตั้งแต่ข้อแรกจนถึงข้อปัจจุบัน เพื่อหาจุดที่ "ไม่ได้ตอบ"
        for (let i = 0; i <= limitIndex; i++) {
             const ans = answersToConsider.find(a => a.questionIndex === i);
             
             if (ans) {
                // มีคำตอบ: เช็คว่าถูกไหม และใช้ไอเทมตัดคอมโบหรือไม่
                const isComboBreaker = (ans.powerupUsed && ans.powerupUsed !== 'wagerMultiplier') || ans.usedBuyTime;
                if (ans.isCorrect) {
                     dynamicStreak = isComboBreaker ? 0 : dynamicStreak + 1;
                } else {
                    dynamicStreak = 0; // ตอบผิด = รีเซ็ต
                }
             } else {
                 // ไม่มีคำตอบในข้อนี้ (หมดเวลา) = รีเซ็ตทันที
                 dynamicStreak = 0;
             }
        }
        // --- [FIX LOGIC END] ---

        return { ...p, realScore, totalPoints: points, answers: answersToConsider, correctStreak: dynamicStreak };
    });

    const maxPoints = Math.max(...playersWithScores.map(p => p.totalPoints), -Infinity);
    const maxRawScore = Math.max(...playersWithScores.map(p => p.realScore), -Infinity);
    const isMarketMode = gameData.isBlackMarketEnabled === true;

    const sortedPlayers = [...playersWithScores].sort((a, b) => {
        if (isMarketMode) {
            if (b.totalPoints !== a.totalPoints) return b.totalPoints - a.totalPoints;
            if (b.realScore !== a.realScore) return b.realScore - a.realScore;
        } else {
            if (b.totalPoints !== a.totalPoints) return b.totalPoints - a.totalPoints;
            if (b.realScore !== a.realScore) return b.realScore - a.realScore;
        }
        return (a.name || '').localeCompare(b.name || '', 'th');
    });

    // คำนวณอันดับ
    let currentRank = 1;
    for (let i = 0; i < sortedPlayers.length; i++) {
        if (i > 0) {
            const prev = sortedPlayers[i - 1];
            const curr = sortedPlayers[i];
            let isTied = (curr.totalPoints === prev.totalPoints) && (curr.realScore === prev.realScore);
            if (!isTied) {
                currentRank = i + 1;
            }
        }
        sortedPlayers[i].displayRank = currentRank;
    }

    let viewerPlayer = null;
    const localPlayerData = playersWithScores.filter(p => localTeamPlayers.includes(p.name));
    viewerPlayer = localPlayerData.length > 0 ? localPlayerData.sort((a, b) => b.totalPoints - a.totalPoints)[0] : null;
    
    if (!viewerPlayer) { 
        liveGameView.innerHTML = `<div class="bg-indigo-700 text-white rounded-lg p-8 text-center flex flex-col items-center justify-center h-full"><h2>กำลังรอข้อมูลผู้เล่น...</h2></div>`;
        return;
    }
    const viewerPrimaryScore = isMarketMode ? viewerPlayer.totalPoints : viewerPlayer.totalPoints;
    const totalQuestionsAskedSoFar = limitIndex + 1;
    
    const scoresHtml = sortedPlayers.map((p, index) => {
        const realScoreSoFar = p.realScore;
        const pointsValue = p.totalPoints;
        
        const currentTurnAnswer = (p.answers || []).find(ans => ans.questionIndex === limitIndex); 

        let potBonusHTML = '';
        if (currentTurnAnswer && currentTurnAnswer.potBonus > 0) {
            potBonusHTML = `<span class="text-xs bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded-full font-bold ml-1 shadow-sm border border-yellow-300" title="ส่วนแบ่งจากคนตอบผิด">+${currentTurnAnswer.potBonus} Pot</span>`;
        }

        let turnStatusIconsHTML = '';
        if (currentTurnAnswer) {
            if (currentTurnAnswer.wasForced) turnStatusIconsHTML += '<span title="โดนบังคับ">👻</span>';
            if (currentTurnAnswer.wasJinxed) turnStatusIconsHTML += '<span title="โดนคำสาป">😈</span>';
            if (currentTurnAnswer.usedBuyTime) turnStatusIconsHTML += '<span title="ใช้เวลา">⏳</span>';
            const powerupUsed = currentTurnAnswer.powerupUsed;
            if (powerupUsed) {
                const icons = { 'poll': '📊', 'cutOne': '✂️', 'insurance': '🛡️', 'fiftyFifty': '🌗', 'wagerMultiplier': '💰', 'secondChance': '🔁', 'buyTime': '⏳', 'revealOptions': '👁️' };
                if (icons[powerupUsed]) turnStatusIconsHTML += `<span title="ใช้ ${powerupUsed}">${icons[powerupUsed]}</span>`;
            }
        }
        
        let statusIconHTML = ''; 
        if (totalQuestionsAskedSoFar > 0) {
            if (isMarketMode) {
                if (pointsValue === maxPoints && maxPoints > 0) statusIconHTML += '<span class="text-yellow-300 ml-1 text-2xl drop-shadow-md">👑</span>';
                if (realScoreSoFar === maxRawScore && maxRawScore > 0) statusIconHTML += '<span class="text-blue-300 ml-1 text-2xl drop-shadow-md">🎓</span>';
            } else {
                const isPerfectRealScore = (p.realScore === totalQuestionsAskedSoFar && totalQuestionsAskedSoFar > 0);
                if (isPerfectRealScore) statusIconHTML = '<span class="text-yellow-300 ml-1">⭐</span>';
            }
            if (statusIconHTML === '' && pointsValue < 0) statusIconHTML = '<span class="text-red-400 ml-1">⚠️</span>';
        }
        
        let fireIconHTML = '';
        const turnUsedBuyTime = currentTurnAnswer && currentTurnAnswer.usedBuyTime;
        const turnUsedItem = currentTurnAnswer && currentTurnAnswer.powerupUsed && currentTurnAnswer.powerupUsed !== 'wagerMultiplier';

        // ใช้ correctStreak ที่คำนวณใหม่แล้ว
        if (!turnUsedBuyTime && !turnUsedItem) {
            const pStreak = p.correctStreak || 0;
            if (pStreak >= 3) {
                fireIconHTML = `<span class="ml-1 text-orange-500 animate-pulse font-bold text-sm">🔥 x${pStreak}</span>`;
            }
        }

        let highlightClass = 'bg-black/20'; 
        let isWagerWin = false;
        if (currentTurnAnswer) { 
            const isCorrect = currentTurnAnswer.isCorrect;
            const isConfident = (currentTurnAnswer.wasConfident === true || currentTurnAnswer.wasConfident === 'confident');
            const powerupUsed = currentTurnAnswer.powerupUsed; 
            if (powerupUsed === 'wagerMultiplier') {
                if (isCorrect) { highlightClass = 'bg-yellow-300 text-yellow-900 font-bold'; isWagerWin = true; } 
                else { highlightClass = 'bg-red-700 text-white font-bold'; }
            } else if (isConfident) {
                highlightClass = isCorrect ? 'bg-[#4ADE80] text-green-900 font-bold' : 'bg-[#EF4444] text-white font-bold';
            } else if (isCorrect) {
                highlightClass = 'bg-[#DCFCE7] text-green-900';
            }
        }
        
        let displayName = '';
        const realName = p.name;
        const nickname = gameData.playerNicknames[p.name] || '???';
        const isSelf = localTeamPlayers.includes(realName); 
        const nicknameColorClass = isWagerWin ? 'text-yellow-800' : 'text-gray-300';
        
        const targetPrimaryScore = isMarketMode ? p.totalPoints : p.totalPoints;
        const canSeeRealName = isRevealed || isSelf || (viewerPrimaryScore > targetPrimaryScore);

        if (canSeeRealName) {
             displayName = `
                <div class="flex flex-col">
                    <span class="font-bold">${realName}</span>
                    <span class="text-sm ${nicknameColorClass}">(${nickname})</span>
                </div>`;
        } else { 
             displayName = `<span class="font-bold">${nickname}</span>`;
        }
        
        if (isSelf) {
            displayName = `<div class="flex items-center gap-2"><div>${displayName}</div><span class="text-xs bg-white/20 px-2 py-0.5 rounded-full whitespace-nowrap">คุณ</span></div>`;
        }
        
        const allIcons = `<div class="flex flex-wrap gap-1">${turnStatusIconsHTML} ${statusIconHTML} ${fireIconHTML}</div>`;
        const pointsDisplay = pointsValue >= 0 ? `(+${(pointsValue).toLocaleString()})` : `(${(pointsValue).toLocaleString()})`;

        return `
            <div class="flex justify-between items-start p-3 rounded-lg transition-all duration-300 ${highlightClass} gap-2">
                 <div class="flex flex-col sm:flex-row sm:items-center w-full gap-2">
                    
                    <div class="flex items-start sm:items-center gap-3 flex-grow min-w-0">
                         <div class="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-black/10 font-bold text-lg mt-1 sm:mt-0">
                            ${p.displayRank}
                        </div>
                        <div class="flex flex-col sm:flex-row sm:items-center gap-1 sm:gap-3 min-w-0">
                            ${displayName}
                            ${allIcons}
                        </div>
                    </div>

                    <div class="flex items-center justify-between sm:justify-end w-full sm:w-auto pl-11 sm:pl-0 mt-1 sm:mt-0">
                         <span class="text-sm opacity-70 sm:hidden">คะแนนรวม:</span>
                         <div class="text-right whitespace-nowrap">
                            <span class="font-bold text-xl">${realScoreSoFar}</span>
                            <span class="text-sm opacity-80 ml-1 font-medium">${pointsDisplay}</span>
                            ${potBonusHTML} </div>
                    </div>

                 </div>
            </div>`;
    }).join('');

    let footerMessageHTML = '';
    const isLastQuestion = (isRevealAtEndMode) ? (limitIndex >= questions.length - 1) : (gameData.currentQuestionIndex >= questions.length - 1);
    
    if (gameData.status === 'podium') {
        footerMessageHTML = ''; 
    } else if (isLastQuestion) {
        footerMessageHTML = `<p class="mt-8 text-xl font-bold text-yellow-300 animate-pulse">เตรียมพบกับผลสรุปสุดท้าย!</p>`;
    } else {
        footerMessageHTML = `<p class="mt-8 text-lg text-indigo-200">รอผู้ควบคุมไปข้อต่อไป...</p>`;
    }

    const potHTML = getCentralPotHTML(gameData);

    const dashboardHtml = `
        <div class="bg-indigo-700 text-white rounded-lg p-6 flex flex-col h-full items-center justify-center">
            
            <div class="mb-4 scale-110">${potHTML}</div>

            <h2 class="text-3xl font-bold mb-6 text-center">สรุปอันดับ (รายบุคคล)</h2>
            <div class="w-full max-w-lg space-y-2">${scoresHtml}</div>
            ${footerMessageHTML}
        </div>
    `;
    liveGameView.innerHTML = dashboardHtml;
}

function renderStudentCompetitionResultsView(gameData, questionIndexToShow) {
    const players = Object.values(gameData.players || {});
    const currentQuestionIndex = questionIndexToShow; 
    const variant = gameData.gameVariant || 'classic';
    const questions = gameData.shuffledQuiz.questions;

    const playersWithScores = players.map(p => {
        const realScore = p.score || 0; 
        const points = p.totalPoints || 0; 
        const answersToConsider = (p.answers || []).filter(ans => (variant === 'reveal_at_end') ? ans.questionIndex <= currentQuestionIndex : true);
        return { ...p, realScore: realScore, totalPoints: points, answers: answersToConsider };
    });

    const isMarketMode = gameData.isBlackMarketEnabled === true;

    const sortedPlayers = [...playersWithScores].sort((a, b) => {
        if (isMarketMode) {
            const scoreDiff = b.realScore - a.realScore;
            if (scoreDiff !== 0) return scoreDiff;
            const pointsDiff = b.totalPoints - a.totalPoints;
            if (pointsDiff !== 0) return pointsDiff;
            return (a.name || '').localeCompare(b.name || '', 'th');
        } else {
            const pointsDiff = b.totalPoints - a.totalPoints;
            if (pointsDiff !== 0) return pointsDiff;
            const scoreDiff = b.realScore - a.realScore;
            if (scoreDiff !== 0) return scoreDiff;
            return (a.name || '').localeCompare(b.name || '', 'th');
        }
    });

    // ▼▼▼ [START] คำนวณอันดับแบบ 1, 1, 3 ▼▼▼
    let currentRank = 1;
    for (let i = 0; i < sortedPlayers.length; i++) {
        if (i > 0) {
            const prev = sortedPlayers[i - 1];
            const curr = sortedPlayers[i];
            // ใช้ตรรกะเดียวกับตอน Sort
            let isTied = false;
            if (isMarketMode) {
                isTied = (curr.realScore === prev.realScore) && (curr.totalPoints === prev.totalPoints);
            } else {
                isTied = (curr.totalPoints === prev.totalPoints) && (curr.realScore === prev.realScore);
            }

            if (!isTied) {
                currentRank = i + 1;
            }
        }
        sortedPlayers[i].displayRank = currentRank;
    }
    // ▲▲▲ [END] คำนวณอันดับเสร็จสิ้น ▲▲▲
    
    // สร้าง HTML
    const scoresHtml = sortedPlayers.map((p, index) => {
        const perfectScoreSymbol = ''; 
        let highlightClass = 'bg-black/20'; 
        const realName = p.name;
        const divStyle = "line-height: 1.3; min-width: 0;"; 
        const spanStyle = "word-break: break-all;"; 
        const displayName = `<div style="${divStyle}" title="${realName}"><span style="${spanStyle}">${realName}</span>${perfectScoreSymbol}</div>`;
        const scoreHTML = ''; 

        // ▼▼▼ [แก้ไข HTML] ใช้ displayRank แทน index+1 ▼▼▼
        return `
            <div class="flex justify-between items-start p-3 rounded-lg transition-all duration-300 ${highlightClass} gap-2">
                <span class="font-semibold text-left" style="flex-shrink: 0; min-width: 2.5rem;">${p.displayRank}.</span>
                <div class="flex-grow">${displayName}</div>
                ${scoreHTML}
            </div>`;
        // ▲▲▲ [สิ้นสุดส่วนที่แก้ไข] ▲▲▲
    }).join('');

    let footerMessageHTML = '';
    const isLastQuestion = (variant === 'reveal_at_end') ? (gameData.reviewQuestionIndex >= questions.length - 1) : (gameData.currentQuestionIndex >= questions.length - 1);
    if (isLastQuestion) {
        footerMessageHTML = `<p class="mt-8 text-xl font-bold text-yellow-300 animate-pulse">เตรียมพบกับผลสรุปสุดท้าย!</p>`;
    } else {
        footerMessageHTML = `<p class="mt-8 text-lg text-indigo-200">รอผู้ควบคุมไปข้อต่อไป...</p>`;
    }

    const dashboardHtml = `
        <div class="bg-indigo-700 text-white rounded-lg p-6 flex flex-col h-full items-center justify-center">
            <h2 class="text-3xl font-bold mb-6">สรุปอันดับ (รายบุคคล)</h2>
            
            <div class="w-full max-w-lg space-y-2">
                ${scoresHtml}
            </div>

            ${footerMessageHTML}
        </div>
    `;
    liveGameView.innerHTML = dashboardHtml;
}

function renderStudentSyncQuestionView(gameData) {
    // 1. หาผู้เล่นปัจจุบันในเครื่องนี้
    while(localPlayerTurnIndex < localTeamPlayers.length && gameData.players[localTeamPlayers[localPlayerTurnIndex]]?.answered === true) {
        localPlayerTurnIndex++;
    }
    
    if (localPlayerTurnIndex >= localTeamPlayers.length) {
        localPlayerTurnIndex = localTeamPlayers.findIndex(name => gameData.players[name]?.answered !== true);
    }

    const currentPlayerOnDevice = localTeamPlayers[localPlayerTurnIndex];
    if (!currentPlayerOnDevice) return; 

    const playerData = gameData.players[currentPlayerOnDevice];
    const qIndex = gameData.currentQuestionIndex;
    const totalQuestions = gameData.shuffledQuiz.questions.length;
    const q = gameData.shuffledQuiz.questions[qIndex];
    const questionType = q.questionType || gameData.shuffledQuiz.quizType;
    
    let optionsHTML = '';
    let hasSubmitButton = false;

    // 2. ตรวจสอบสถานะไอเทมและ Flag
    const powerupFlagName = `powerupUsed_q${qIndex}_p${currentPlayerOnDevice}`;
    const activePowerup = sessionStorage.getItem(powerupFlagName);
    const isRevealed = (activePowerup === 'revealOptions'); 

    const hiddenFlagName = `hiddenOptions_q${qIndex}_p${currentPlayerOnDevice}`;
    const hiddenIndices = (JSON.parse(sessionStorage.getItem(hiddenFlagName) || '[]')).map(String);

    // --- [ส่วนการแสดงผลตัวเลือก] ---
    if ((questionType === 'short_answer' || questionType === 'fill_in_no_choices') && isRevealed && q.options && q.options.length > 0) {
        optionsHTML = q.options.map((opt, i) => {
            if (hiddenIndices.includes(String(i))) return '';
            return `<button data-value="${opt}" data-index="${i}" class="live-answer-btn p-4 rounded-lg text-xl text-center bg-white text-gray-800 hover:bg-indigo-100 border-2 border-purple-300 shadow-md transform transition-transform hover:scale-105">${opt}</button>`;
        }).join('');
    } 
    else if (questionType === 'short_answer' || questionType === 'fill_in_no_choices') {
        hasSubmitButton = true;
        const isNumericAnswer = q.idealAnswer && /^-?[\d.,]+$/.test(String(q.idealAnswer).trim());
        let inputFieldHTML = isNumericAnswer 
            ? `<input type="text" id="sync-short-answer-input" inputmode="decimal" class="w-full max-w-lg p-4 border-2 border-gray-300 rounded-lg text-gray-800 text-3xl text-center font-bold focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 outline-none" placeholder="0" autocomplete="off">`
            : `<textarea id="sync-short-answer-input" class="w-full max-w-lg p-3 border rounded-lg text-gray-800 text-lg" rows="3" placeholder="พิมพ์คำตอบของคุณ..."></textarea>`;

        optionsHTML = `<div class="w-full md:col-span-2 flex flex-col items-center gap-4">${inputFieldHTML}<button id="sync-submit-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-xl"><i class="fas fa-paper-plane mr-2"></i>ส่งคำตอบ</button></div>`;
    }
    else {
        switch(questionType) {
            case 'true_false':
                const btnYes = hiddenIndices.includes('0') ? '' : `<button data-value="0" data-index="0" class="live-answer-btn p-4 rounded-lg text-xl text-center bg-white text-gray-800 hover:bg-indigo-100">ใช่ / ถูก</button>`;
                const btnNo = hiddenIndices.includes('1') ? '' : `<button data-value="1" data-index="1" class="live-answer-btn p-4 rounded-lg text-xl text-center bg-white text-gray-800 hover:bg-indigo-100">ไม่ใช่ / ผิด</button>`;
                optionsHTML = btnYes + btnNo;
                break;

            // ▼▼▼ [ส่วนที่แก้ไข: ใช้ data-value เพื่อรักษา Backslash] ▼▼▼
            case 'matching_item':
                hasSubmitButton = true;
                
                const dropdownItems = (q.allResponses || []).map(opt => {
                    // แปลง " เป็น HTML entity เพื่อไม่ให้ Attribute พัง
                    const safeValue = opt.replace(/"/g, '&quot;');
                    return `
                    <div class="p-3 border-b border-gray-100 hover:bg-indigo-50 cursor-pointer transition-colors text-lg text-gray-800"
                         data-value="${safeValue}"
                         onclick="window.selectSyncOption(this.getAttribute('data-value'))">
                        ${opt}
                    </div>`;
                }).join('');

                optionsHTML = `
                <div class="w-full md:col-span-2 flex flex-col items-center gap-4 sync-custom-dropdown relative">
                    <input type="hidden" id="sync-matching-input" value="">

                    <button onclick="window.toggleSyncDropdown()" 
                            class="w-full max-w-lg p-4 border-2 border-gray-300 rounded-lg bg-white text-left flex justify-between items-center hover:border-indigo-500 focus:ring-2 focus:ring-indigo-200 transition-all shadow-sm">
                        <span id="sync-dropdown-display" class="text-gray-400 text-lg">-- เลือกคำตอบที่คู่กัน --</span>
                        <i class="fas fa-chevron-down text-gray-400"></i>
                    </button>

                    <div id="sync-dropdown-list" class="hidden absolute top-20 w-full max-w-lg bg-white border border-gray-300 rounded-lg shadow-xl max-h-60 overflow-y-auto z-50">
                        ${dropdownItems}
                    </div>

                    <button id="sync-submit-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-xl mt-2">
                        <i class="fas fa-paper-plane mr-2"></i>ส่งคำตอบ
                    </button>
                </div>`;
                break;
            // ▲▲▲ [สิ้นสุดส่วนที่แก้ไข] ▲▲▲

            case 'multiple_choice':
            default:
                optionsHTML = (q.options || []).map((opt, i) => {
                    if (hiddenIndices.includes(String(i))) return '';
                    return `<button data-value="${i}" data-index="${i}" class="live-answer-btn p-4 rounded-lg text-xl text-center bg-white text-gray-800 hover:bg-indigo-100">${opt}</button>`;
                }).join('');
                break;
        }
    }

    // --- [ส่วน Timer] ---
    let timerHTML = '';
    if (gameData.timerMode === 'per_question') {
        timerHTML = `<div class="my-4"><div id="sync-timer-bar-container" class="w-full bg-gray-200/50 rounded-full h-2.5"><div id="sync-timer-bar" class="bg-yellow-400 h-2.5 rounded-full" style="width: 100%; transition: width 0.5s linear 0s;"></div></div><p class="text-center text-sm text-yellow-300 mt-1">เหลือเวลา <span id="sync-timer-countdown" class="font-bold">${gameData.timerDuration}</span> วินาที</p></div>`;
    }
    
    // --- [Market & Inventory Logic] ---
    let marketAndInventoryHTML = '';
    const variant = gameData.gameVariant || 'classic';
    const isSecretScoreMode = ['reveal_at_end', 'anonymous_reveal_end', 'competition'].includes(variant);

    if (gameData.isBlackMarketEnabled === true) {
        if (isSecretScoreMode) {
            if (!activePowerup) {
                 marketAndInventoryHTML = `<div class="flex justify-center my-4"><button id="use-powerup-wagerMultiplier-instant" class="bg-gradient-to-r from-red-500 to-pink-600 text-white shadow-lg border-4 border-white/20 active:scale-95 animate-pulse py-3 px-6 rounded-full font-bold transition-all flex flex-col items-center gap-1"><div class="flex items-center gap-2"><i class="fas fa-rocket"></i> <span>เดิมพันหมดหน้าตัก! (วัดดวง)</span></div><span class="text-[10px] opacity-90 font-normal">(ผิด=โดดตบ 10 ครั้ง!)</span></button></div>`;
            }
        } else {
            const playerPoints = playerData.totalPoints || 0;
            const playerPowerups = playerData.powerups || {};
             const inventoryButtons = [
                playerPowerups.buyTime > 0 ? `<button id="use-powerup-buyTime" class="powerup-btn bg-green-500 text-white py-1 px-3 rounded-full text-xs">⏳ ซื้อเวลา (${playerPowerups.buyTime})</button>` : '',
                playerPowerups.revealOptions > 0 ? `<button id="use-powerup-revealOptions" class="powerup-btn bg-purple-500 text-white py-1 px-3 rounded-full text-xs font-bold border-2 border-yellow-300 shadow-sm">👁️ เผยตัวเลือก (${playerPowerups.revealOptions})</button>` : '', 
                playerPowerups.cutOne > 0 ? `<button id="use-powerup-cutOne" class="powerup-btn bg-green-500 text-white py-1 px-3 rounded-full text-xs">✂️ ตัด 1 (${playerPowerups.cutOne})</button>` : '',
                playerPowerups.insurance > 0 ? `<button id="use-powerup-insurance" class="powerup-btn bg-green-500 text-white py-1 px-3 rounded-full text-xs">🛡️ ประกันภัย (${playerPowerups.insurance})</button>` : '',
                playerPowerups.fiftyFifty > 0 ? `<button id="use-powerup-fiftyFifty" class="powerup-btn bg-green-500 text-white py-1 px-3 rounded-full text-xs">🌗 50:50 (${playerPowerups.fiftyFifty})</button>` : '',
                playerPowerups.secondChance > 0 ? `<button id="use-powerup-secondChance" class="powerup-btn bg-green-500 text-white py-1 px-3 rounded-full text-xs">🔁 แก้ตัว (${playerPowerups.secondChance})</button>` : '',
            ].filter(Boolean).join(' ');
            
            const flagNameMarket = 'freeMarketEntryUsed_q' + qIndex + '_p' + currentPlayerOnDevice;
            const freeEntryUsed = sessionStorage.getItem(flagNameMarket) === 'true';
            const canEnterMarket = (playerPoints > 0) && (!freeEntryUsed || playerPoints >= 1);
            const marketBtnText = playerPoints === 0 ? `ตลาดมืด (0 P)` : (freeEntryUsed ? `ตลาดมืด (-1 P)` : `ตลาดมืด (${playerPoints} P)`);
            const marketBtnClass = canEnterMarket ? "bg-purple-600 text-white hover:bg-purple-700 shadow-md" : "bg-gray-400 text-gray-200 cursor-not-allowed opacity-70";
            const marketBtnDisabled = canEnterMarket ? "" : "disabled";

            let mainActionButtons = `<button id="open-market-btn" class="${marketBtnClass} py-2 px-4 rounded-lg font-semibold text-sm flex items-center min-h-[54px]" ${marketBtnDisabled}><i class="fas fa-store mr-2"></i> ${marketBtnText}</button>`;

            if (!activePowerup) {
                 const canWager = playerPoints > 0;
                 const wagerBtnClass = canWager ? "bg-yellow-400 text-yellow-900 hover:bg-yellow-500 shadow-md border-b-4 border-yellow-600 active:border-b-0 active:translate-y-1" : "bg-gray-400 text-gray-600 cursor-not-allowed border-b-4 border-gray-500 opacity-70";
                 const instantWagerBtnClass = canWager ? "bg-gradient-to-r from-red-500 to-pink-600 text-white shadow-md border-b-4 border-red-800 active:border-b-0 active:translate-y-1" : "bg-gray-400 text-gray-200 cursor-not-allowed border-b-4 border-gray-500 opacity-70";
                 const wagerDisabledAttr = canWager ? "" : "disabled";
                 
                 mainActionButtons += `<button id="use-powerup-wagerMultiplier" class="${wagerBtnClass} py-1 px-3 rounded-lg font-bold transition-all flex flex-col items-center justify-center min-h-[54px]" ${wagerDisabledAttr}><span class="text-sm flex items-center gap-1">💰 เดิมพันเลือกเอง</span></button><button id="use-powerup-wagerMultiplier-instant" class="${instantWagerBtnClass} py-1 px-3 rounded-lg font-bold transition-all flex flex-col items-center justify-center min-h-[54px]" ${wagerDisabledAttr}><span class="text-sm flex items-center gap-1"><i class="fas fa-rocket"></i> เดิมพันทุ่มหมด</span></button>`;
            }
            marketAndInventoryHTML = `<div class="flex flex-col items-center gap-2 my-4 p-2 bg-black/20 rounded-lg"><div class="flex flex-wrap justify-center items-stretch gap-2 w-full">${mainActionButtons}</div><div class="flex flex-wrap gap-1 items-center justify-center mt-1">${inventoryButtons || ''}</div></div>`;
        }
    }
    
    // --- [Status Banners] ---
    let activePowerupHTML = '';
    if (playerData.isJinxed) activePowerupHTML += `<div class="w-full bg-gradient-to-r from-red-700 to-red-900 text-white text-center py-2 px-4 rounded-lg mb-3 shadow-lg animate-pulse border-2 border-red-400"><div class="text-xl font-bold flex items-center justify-center gap-2"><i class="fas fa-skull-crossbones"></i> <span>คุณโดนคำสาป!</span></div><p class="text-xs opacity-80">คะแนนติดลบ x2 ถ้าตอบผิด</p></div>`;
    if (playerData.isForcedConfident) activePowerupHTML += `<div class="w-full bg-gradient-to-r from-gray-700 to-gray-900 text-white text-center py-2 px-4 rounded-lg mb-3 shadow-lg animate-pulse border-2 border-gray-500"><div class="text-xl font-bold flex items-center justify-center gap-2"><i class="fas fa-ghost"></i> <span>ถูกบังคับมั่นใจ!</span></div><p class="text-xs opacity-80">ต้องเดิมพันด้วยความมั่นใจสูงสุด</p></div>`;
    if ((playerData.timeBonusThisQuestion || 0) > 0) activePowerupHTML += `<div class="w-full bg-gradient-to-r from-yellow-400 to-orange-500 text-white text-center py-2 px-4 rounded-lg mb-3 shadow-lg animate-pulse border-2 border-white/30"><div class="text-xl font-bold flex items-center justify-center gap-2"><i class="fas fa-clock fa-lg"></i><span>เวลาโบนัสทำงาน!</span></div><p class="text-sm opacity-90">+25% เวลาคิดเพิ่มพิเศษ</p></div>`;
    if (activePowerup) {
        if (activePowerup === 'wagerMultiplier') {
             const wagerText = isSecretScoreMode ? '🚀 คุณเดิมพันหมดหน้าตัก!' : '💰 โหมดเดิมพันทำงานอยู่!';
             activePowerupHTML += `<div class="w-full text-center py-3 px-4 rounded-lg bg-gradient-to-r from-yellow-400 to-yellow-600 text-black font-extrabold mb-3 animate-pulse border-4 border-yellow-200 shadow-lg text-xl transform scale-105">${wagerText} <span class="block text-sm mt-1 font-normal text-red-900">(ตอบถูก x2 / ตอบผิดเสียเงินเข้ากองกลาง!)</span></div>`;
        } else if (activePowerup === 'cutOne') { activePowerupHTML += `<div class="w-full bg-gradient-to-r from-green-400 to-emerald-600 text-white text-center py-2 px-4 rounded-lg mb-3 shadow-lg animate-pulse border-2 border-white/30"><div class="text-xl font-bold flex items-center justify-center gap-2"><i class="fas fa-cut fa-lg"></i> <span>ตัดตัวเลือกทำงาน!</span></div><p class="text-sm opacity-90">ตัวเลือกที่ผิด 1 ข้อถูกตัดออกแล้ว</p></div>`;
        } else if (activePowerup === 'fiftyFifty') { activePowerupHTML += `<div class="w-full bg-gradient-to-r from-purple-500 to-indigo-600 text-white text-center py-2 px-4 rounded-lg mb-3 shadow-lg animate-pulse border-2 border-white/30"><div class="text-xl font-bold flex items-center justify-center gap-2"><i class="fas fa-adjust fa-lg"></i> <span>50:50 ทำงาน!</span></div><p class="text-sm opacity-90">ตัดตัวเลือกผิดออก 2 ข้อ</p></div>`;
        } else if (activePowerup === 'secondChance') { activePowerupHTML += `<div class="w-full bg-gradient-to-r from-blue-400 to-cyan-500 text-white text-center py-2 px-4 rounded-lg mb-3 shadow-lg animate-pulse border-2 border-white/30"><div class="text-xl font-bold flex items-center justify-center gap-2"><i class="fas fa-undo-alt fa-lg"></i> <span>โอกาสครั้งที่สอง!</span></div><p class="text-sm opacity-90">ตอบผิดได้ 1 ครั้งโดยไม่เสียคะแนน</p></div>`;
        } else if (activePowerup === 'revealOptions') { activePowerupHTML += `<div class="w-full bg-gradient-to-r from-pink-500 to-rose-600 text-white text-center py-2 px-4 rounded-lg mb-3 shadow-lg animate-pulse border-2 border-white/30"><div class="text-xl font-bold flex items-center justify-center gap-2"><i class="fas fa-eye fa-lg"></i> <span>เผยตัวเลือก!</span></div><p class="text-sm opacity-90">แสดงตัวเลือกที่ซ่อนอยู่เรียบร้อย</p></div>`;
        } else if (activePowerup === 'insurance') { activePowerupHTML += `<div class="w-full bg-gradient-to-r from-gray-500 to-slate-600 text-white text-center py-2 px-4 rounded-lg mb-3 shadow-lg animate-pulse border-2 border-white/30"><div class="text-xl font-bold flex items-center justify-center gap-2"><i class="fas fa-shield-alt fa-lg"></i> <span>ประกันภัยทำงาน!</span></div><p class="text-sm opacity-90">ป้องกันการเสียคะแนนหากตอบผิด</p></div>`;
        } else { activePowerupHTML += `<div class="w-full text-center py-2 px-3 rounded-lg bg-yellow-500 text-black font-bold mb-3 animate-pulse shadow-md">${activePowerup} ทำงานอยู่!</div>`; }
    }

    let fireBannerHTML = '';
    if (!isSecretScoreMode) {
        const currentStreak = playerData.correctStreak || 0;
        if (currentStreak >= 3) {
            fireBannerHTML = `<div class="w-full bg-gradient-to-r from-orange-500 to-red-600 text-white text-center py-2 px-4 rounded-lg mb-4 shadow-lg animate-pulse border-2 border-yellow-300"><div class="text-lg font-extrabold flex items-center justify-center gap-2"><i class="fas fa-fire text-yellow-200 text-2xl"></i><span>ON FIRE! คะแนน x2</span><i class="fas fa-fire text-yellow-200 text-2xl"></i></div></div>`;
        } else if (currentStreak > 0) {
            fireBannerHTML = `<div class="w-full text-center mb-4"><span class="text-xs font-bold text-orange-400 bg-black/20 px-2 py-1 rounded-full">🔥 Combo: ${currentStreak}/3</span></div>`;
        }
    }

    const potHTML = getCentralPotHTML(gameData);

    // --- [ปุ่มเปลี่ยนคนตอบ] ---
    let changeResponderBtnHTML = '';
    const pendingPlayers = localTeamPlayers.filter(name => gameData.players[name]?.answered !== true);
    if (localTeamPlayers.length > 1 && pendingPlayers.length > 1) {
        changeResponderBtnHTML = `
            <button id="switch-responder-btn" class="bg-white/20 hover:bg-white/30 text-white text-sm font-semibold px-3 py-2 rounded-lg flex items-center gap-2 transition-all border border-white/30 shadow-sm">
                <i class="fas fa-users"></i> เปลี่ยน
            </button>
        `;
    }

    // --- [Render HTML หลัก] ---
    liveGameView.innerHTML = `
        <div class="bg-indigo-700 text-white rounded-lg p-8 flex flex-col h-full">
            
            <div class="grid grid-cols-3 items-center mb-4 relative z-20">
                
                <div class="flex justify-start">
                    ${changeResponderBtnHTML}
                </div>

                <div class="flex justify-center">
                    <div class="bg-indigo-900/50 px-4 py-1.5 rounded-full border border-indigo-400/30 backdrop-blur-sm shadow-lg">
                        <span class="text-lg font-bold text-white whitespace-nowrap">
                            ข้อที่ <span class="text-yellow-300">${qIndex + 1}</span> / ${totalQuestions}
                        </span>
                    </div>
                </div>

                <div class="flex justify-end transform scale-90 origin-right">
                    ${potHTML}
                </div>
            </div>

            <p class="text-2xl font-bold text-center text-yellow-300 my-2 drop-shadow-md">ตาของ: ${currentPlayerOnDevice}</p>
            
            ${fireBannerHTML} 
            ${timerHTML} 
            ${marketAndInventoryHTML} 
            
            <div class="flex-grow flex flex-col items-center justify-center">
                ${activePowerupHTML}
                <h2 class="text-3xl font-bold mb-8 text-center leading-tight">${q.questionText || q.stem}</h2>
                <div class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-4">${optionsHTML}</div>
            </div>
        </div>
    `;
    
    if (window.MathJax) MathJax.typesetPromise();

    // --- [Function ส่งคำตอบ] ---
    function triggerSubmission(answerValue, question, gameData, playerName) {
        const confidenceEnabled = gameData.isConfidenceScoringEnabled === true;
        const qIndex = gameData.currentQuestionIndex;
        const flagName = `powerupUsed_q${qIndex}_p${playerName}`;
        const activePowerup = sessionStorage.getItem(flagName);
        const isWagerMode = activePowerup === 'wagerMultiplier';
        const playerData = gameData.players[playerName];

        if (isWagerMode) {
            const isInstantWager = sessionStorage.getItem('instantWager') === 'true';
            if (isSecretScoreMode || isInstantWager) {
                const currentPoints = playerData.totalPoints || 0;
                sessionStorage.removeItem('instantWager'); 
                handleSyncAnswerSubmit(answerValue, question, gameData, playerName, false, currentPoints);
            } else {
                const wagerModal = document.getElementById('wager-modal');
                const slider = document.getElementById('wager-slider');
                const display = document.getElementById('wager-amount-display');
                const maxPointsEl = document.getElementById('wager-max-points');
                const currentPoints = playerData.totalPoints || 0;
                slider.max = currentPoints; slider.value = currentPoints; display.textContent = currentPoints;
                maxPointsEl.textContent = currentPoints;
                slider.oninput = () => { display.textContent = slider.value; }; 
                const hiddenInput = document.getElementById('selected-answer-index-hidden-wager');
                hiddenInput.dataset.answerValue = answerValue;
                hiddenInput.dataset.question = JSON.stringify(question);
                hiddenInput.dataset.gameData = JSON.stringify(gameData);
                hiddenInput.dataset.playerName = playerName;
                wagerModal.classList.remove('hidden'); 
            }
        } else if (confidenceEnabled) { 
            document.getElementById('confidence-modal').dataset.currentMode = 'sync';
            const hiddenInput = document.getElementById('selected-answer-index-hidden');
            hiddenInput.dataset.answerValue = answerValue;
            hiddenInput.dataset.question = JSON.stringify(question);
            hiddenInput.dataset.gameData = JSON.stringify(gameData);
            hiddenInput.dataset.playerName = playerName;
            document.getElementById('confidence-modal').classList.remove('hidden');
        } else {
            handleSyncAnswerSubmit(answerValue, question, gameData, playerName, false, 0); 
        }
    }

    if (hasSubmitButton) {
        document.getElementById('sync-submit-btn').addEventListener('click', () => {
            const input = document.getElementById('sync-short-answer-input') || document.getElementById('sync-matching-select');
            
            // --- [ส่วนแก้ไข] ตรวจสอบค่าจาก input ทั้งสองแบบ ---
            let answerValue = '';
            if (input) {
                answerValue = input.value.trim();
            } else {
                const matchingInput = document.getElementById('sync-matching-input');
                if (matchingInput) answerValue = matchingInput.value;
            }

            if (answerValue === '') { showMessage("กรุณาเลือกหรือพิมพ์คำตอบก่อนครับ"); return; }
            triggerSubmission(answerValue, q, gameData, currentPlayerOnDevice);
        });
    } else {
        document.querySelectorAll('.live-answer-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                triggerSubmission(btn.dataset.value, q, gameData, currentPlayerOnDevice);
            });
        });
    }

    const switchBtn = document.getElementById('switch-responder-btn');
    if (switchBtn) {
        switchBtn.addEventListener('click', () => {
            showResponderSelectionModal(gameData);
        });
    }

    // --- Market Listeners ---
    if (gameData.isBlackMarketEnabled === true && !isSecretScoreMode) {
        const marketBtn = document.getElementById('open-market-btn');
        if (marketBtn) {
            marketBtn.addEventListener('click', () => {
                 const flagName = 'freeMarketEntryUsed_q' + qIndex + '_p' + currentPlayerOnDevice;
                 const freeEntryUsed = sessionStorage.getItem(flagName) === 'true';
                 if (!freeEntryUsed) {
                     openBlackMarket(gameData, playerData);
                     sessionStorage.setItem(flagName, 'true');
                     renderStudentSyncQuestionView(gameData);
                 } else {
                     if (playerData.totalPoints < 1) { showMessage("คุณมี Points ไม่พอ (ต้องใช้ 1P)"); return; }
                     showConfirmation("เข้าตลาดมืดครั้งต่อไปเสียค่าธรรมเนียม 1 Point ยืนยัน?", () => {
                         handlePayForMarketEntry(currentPlayerOnDevice, gameData, playerData);
                     });
                 }
            });
        }
        document.getElementById('use-powerup-buyTime')?.addEventListener('click', (e) => { e.target.disabled = true; handleUsePowerup(currentPlayerOnDevice, 'buyTime', q, gameData, playerData); });
        document.getElementById('use-powerup-cutOne')?.addEventListener('click', (e) => { e.target.disabled = true; handleUsePowerup(currentPlayerOnDevice, 'cutOne', q, gameData, playerData); });
        document.getElementById('use-powerup-insurance')?.addEventListener('click', (e) => { e.target.disabled = true; handleUsePowerup(currentPlayerOnDevice, 'insurance', q, gameData, playerData); });
        document.getElementById('use-powerup-fiftyFifty')?.addEventListener('click', (e) => { e.target.disabled = true; handleUsePowerup(currentPlayerOnDevice, 'fiftyFifty', q, gameData, playerData); });
        document.getElementById('use-powerup-secondChance')?.addEventListener('click', (e) => { e.target.disabled = true; handleUsePowerup(currentPlayerOnDevice, 'secondChance', q, gameData, playerData); });
        document.getElementById('use-powerup-revealOptions')?.addEventListener('click', (e) => { e.target.disabled = true; handleUsePowerup(currentPlayerOnDevice, 'revealOptions', q, gameData, playerData); });
        document.getElementById('use-powerup-wagerMultiplier')?.addEventListener('click', (e) => { e.target.disabled = true; sessionStorage.setItem('instantWager', 'false'); handleUsePowerup(currentPlayerOnDevice, 'wagerMultiplier', q, gameData, playerData); });
    }
    if (gameData.isBlackMarketEnabled === true) {
        document.getElementById('use-powerup-wagerMultiplier-instant')?.addEventListener('click', (e) => { e.target.disabled = true; sessionStorage.setItem('instantWager', 'true'); handleUsePowerup(currentPlayerOnDevice, 'wagerMultiplier', q, gameData, playerData); });
    }
}

// --- ฟังก์ชันสำหรับ Custom Dropdown ใน Sync Mode ---
window.toggleSyncDropdown = function() {
    const list = document.getElementById('sync-dropdown-list');
    if (list) list.classList.toggle('hidden');
};

window.selectSyncOption = function(value) {
    // 1. อัปเดตค่าลงใน Hidden Input
    const input = document.getElementById('sync-matching-input');
    if (input) input.value = value;

    // 2. อัปเดตข้อความบนปุ่มแสดงผล
    const display = document.getElementById('sync-dropdown-display');
    if (display) {
        display.innerHTML = value;
        display.classList.remove('text-gray-400');
        display.classList.add('text-gray-800', 'font-bold');
        // 3. สั่ง MathJax แปลงสูตรทันที
        if (window.MathJax) MathJax.typesetPromise([display]);
    }

    // 4. ปิด Dropdown
    document.getElementById('sync-dropdown-list').classList.add('hidden');
};

// ปิด Dropdown เมื่อคลิกที่อื่น
document.addEventListener('click', (e) => {
    if (!e.target.closest('.sync-custom-dropdown')) {
        const list = document.getElementById('sync-dropdown-list');
        if (list) list.classList.add('hidden');
    }
});

function showResponderSelectionModal(gameData) {
    const qIndex = gameData.currentQuestionIndex;
    const totalQuestions = gameData.shuffledQuiz.questions.length;
    
    // หาผู้เล่นในเครื่องที่ยังไม่ได้ตอบ
    const pendingPlayers = localTeamPlayers.filter(name => gameData.players[name]?.answered !== true);

    const listHTML = pendingPlayers.map(name => `
        <button class="w-full bg-white text-indigo-700 font-bold py-4 px-6 rounded-xl shadow-md hover:shadow-lg transition-all transform hover:scale-105 flex justify-between items-center group select-responder-btn" data-name="${name}">
            <span class="text-xl">${name}</span>
            <i class="fas fa-play-circle text-3xl text-indigo-400 group-hover:text-indigo-600 transition-colors"></i>
        </button>
    `).join('');

    const modalHTML = `
        <div id="responder-selection-overlay" class="fixed inset-0 bg-indigo-700 z-[999] flex flex-col items-center justify-center p-6 fade-in">
            
            <div class="bg-white/20 px-4 py-1 rounded-full mb-6">
                <span class="text-white text-sm">ข้อที่ ${qIndex + 1} / ${totalQuestions}</span>
            </div>

            <h2 class="text-4xl font-bold text-white mb-8 drop-shadow-md">ใครพร้อมตอบ?</h2>
            
            <div class="w-full max-w-md space-y-4">
                ${listHTML}
            </div>

            <button id="close-responder-overlay" class="mt-12 text-indigo-200 hover:text-white underline text-sm transition-colors">
                กลับไปตามลำดับปกติ
            </button>
        </div>
    `;

    // แทรก HTML เข้าไปใน body (เพื่อให้ทับทุกอย่าง)
    document.body.insertAdjacentHTML('beforeend', modalHTML);

    // Event Listeners
    document.querySelectorAll('.select-responder-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const selectedName = btn.dataset.name;
            switchPlayerOnDevice(selectedName, gameData);
            document.getElementById('responder-selection-overlay').remove();
        });
    });

    document.getElementById('close-responder-overlay').addEventListener('click', () => {
        document.getElementById('responder-selection-overlay').remove();
    });
}

/**
 * [ใหม่] สลับ Index ของผู้เล่นในเครื่อง และสั่ง Render ใหม่
 */
function switchPlayerOnDevice(selectedName, gameData) {
    const newIndex = localTeamPlayers.indexOf(selectedName);
    if (newIndex !== -1) {
        localPlayerTurnIndex = newIndex;
        // เรียก render ใหม่ทันที
        renderStudentSyncQuestionView(gameData);
    }
}

async function handleSyncAnswerSubmit(answerValue, question, gameData, playerName, isConfident, wagerAmount = 0) {
    document.querySelectorAll('.live-answer-btn, #sync-submit-btn').forEach(b => b.disabled = true);

    const qIndex = gameData.currentQuestionIndex;
    const playerData = gameData.players[playerName] || {}; 
    const isOnetMode = gameData.isOnetMode === true;

    const questionType = question.questionType || gameData.shuffledQuiz.quizType;
    let isCorrect = false;
    let answerText = answerValue;

    // ตรวจคำตอบ (เหมือนเดิม)
    switch(questionType) {
        case 'true_false':
            const answerIndexTF = parseInt(answerValue); 
            const correctBool = (question.correctAnswer === true || String(question.correctAnswer).toLowerCase() === 'true');
            isCorrect = (answerIndexTF === 0 && correctBool) || (answerIndexTF === 1 && !correctBool);
            answerText = (answerIndexTF === 0) ? 'ใช่ / ถูก' : 'ไม่ใช่ / ผิด';
            break;
        case 'short_answer':
        case 'fill_in_no_choices':
            isCorrect = await gradeShortAnswer(answerValue, question);
            break;
        case 'matching_item':
            isCorrect = (answerValue === question.correctResponse);
            break;
        case 'multiple_choice':
        default:
            const answerIndexMC = parseInt(answerValue);
            isCorrect = (answerIndexMC === question.correctAnswerIndex);
            if (question.options && question.options[answerIndexMC]) answerText = question.options[answerIndexMC];
            break;
    }

    // --- [LOGIC การให้คะแนนใหม่] ---
    let pointsForThisQuestion = 0;
    let baseStreak = playerData.correctStreak || 0;
    let newStreak = 0;

    // 1. หาน้ำหนักคะแนนของข้อนี้
    const weight = getQuestionWeight(gameData.shuffledQuiz, questionType);

    // 2. ตรวจสอบสถานะต่างๆ (Powerups, Wager, etc.)
    // O-NET Mode จะไม่มี Powerups แต่มี Wager/Confidence ได้
    const flagName = `powerupUsed_q${qIndex}_p${playerName}`;
    const activePowerup = isOnetMode ? null : sessionStorage.getItem(flagName); // O-NET ไม่มี item
    const isWagerMode = activePowerup === 'wagerMultiplier' || (isOnetMode && parseInt(wagerAmount) > 0); // O-NET เดิมพันได้
    
    // Logic ทั่วไป
    const isInsurance = !isOnetMode && activePowerup === 'insurance';
    const isPoll = !isOnetMode && sessionStorage.getItem('pollUsedThisTurn') === 'true';
    const isJinxed = !isOnetMode && (playerData.isJinxed === true);
    const isForced = !isOnetMode && (playerData.isForcedConfident === true);

    if (activePowerup && activePowerup !== 'wagerMultiplier') baseStreak = 0;
    const isFireActive = baseStreak >= 3; 

    // --- คำนวณ Points (ใช้ Logic เดียวกับโหมดปกติ) ---
    if (isWagerMode) {
        const betAmount = parseInt(wagerAmount, 10) || 0;
        // เดิมพัน: ถูกได้เพิ่ม 2 เท่าของเงิน, ผิดเสียเงินเดิมพัน
        pointsForThisQuestion = isCorrect ? (betAmount * 2) : -betAmount;
    
    } else if (isPoll && !isCorrect) {
        pointsForThisQuestion = (isConfident || isForced) ? -(weight * 4) : -(weight * 2); // ปรับ penalty ตามน้ำหนัก
    
    } else if (isForced) {
        pointsForThisQuestion = isCorrect ? (weight * 2) : -weight;
    
    } else if (gameData.isConfidenceScoringEnabled) {
        // ใช้สูตร Ratio:
        // ถูก+มั่นใจ = น้ำหนัก * 2
        // ถูก+ไม่มั่นใจ = น้ำหนัก * 1
        // ผิด+มั่นใจ = น้ำหนัก * -1
        // ผิด+ไม่มั่นใจ = 0
        if (isCorrect) {
            pointsForThisQuestion = isConfident ? (weight * 2) : weight;
        } else {
            pointsForThisQuestion = isConfident ? -weight : 0;
        }
    } else {
        // โหมดธรรมดา (ไม่เปิดความมั่นใจ)
        pointsForThisQuestion = isCorrect ? weight : 0;
    }

    // Effect พิเศษ (ปิดใน O-NET)
    if (!isOnetMode) {
        if (isFireActive && pointsForThisQuestion > 0) pointsForThisQuestion *= 2; 
        if (isJinxed && !isCorrect && pointsForThisQuestion < 0) pointsForThisQuestion *= 2; 
        if (!isCorrect && isInsurance) pointsForThisQuestion = 0;
    }

    const isComboBreaker = activePowerup && activePowerup !== 'wagerMultiplier';
    if (isCorrect) newStreak = isComboBreaker ? 0 : (baseStreak + 1);

    // สร้าง Object บันทึก
    const answerRecord = {
        questionIndex: qIndex,
        questionId: question.id,
        answer: answerValue, 
        answerText: answerText,
        isCorrect: isCorrect,
        originalQuestionText: question.questionText || question.stem,
        wasConfident: isConfident || false,
        pointsAwarded: pointsForThisQuestion,
        powerupUsed: activePowerup,
        wagerAmount: parseInt(wagerAmount, 10) || 0,
        
        wasJinxed: isJinxed,
        wasForced: isForced,
        usedPoll: isPoll,
        usedBuyTime: !isOnetMode && ((playerData.timeBonusThisQuestion || 0) > 0),
        streakActive: !isOnetMode && (baseStreak >= 3)
    };

    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, playerName);
    const existingAnswers = playerData.answers || [];
    const otherAnswers = existingAnswers.filter(ans => ans.questionIndex !== qIndex);
    const newAnswersArray = [...otherAnswers, answerRecord];
    
    // คำนวณคะแนนดิบรวมใหม่ (Raw Score = Sum of Weights of correct answers)
    let newRawScore = 0;
    newAnswersArray.forEach(ans => {
        if (ans.isCorrect) {
            // ต้องหาคำถามของ ans นั้นๆ เพื่อรู้น้ำหนัก
            const qObj = gameData.shuffledQuiz.questions[ans.questionIndex];
            if (qObj) {
                const w = getQuestionWeight(gameData.shuffledQuiz, qObj.questionType || gameData.shuffledQuiz.quizType);
                newRawScore += w;
            } else {
                newRawScore += 1; // Fallback
            }
        }
    });

    const updatePayload = {
        answers: newAnswersArray,
        score: newRawScore, // บันทึกเป็นคะแนนตามน้ำหนัก
        totalPoints: increment(pointsForThisQuestion),
        answered: true,
        lastAnswerIndex: (questionType === 'multiple_choice' || questionType === 'true_false') ? parseInt(answerValue) : null,
        lastAnswerValue: answerText,
        isJinxed: false, isForcedConfident: false, timeBonusThisQuestion: 0,
        correctStreak: newStreak
    };

    if (!isOnetMode && sessionStorage.getItem('onSecondChance') === 'true') {
        sessionStorage.removeItem('onSecondChance');
    }
    
    try {
        await updateDoc(playerRef, updatePayload);
    } catch (error) {
        console.error("Error submitting answer:", error);
        showMessage("ส่งคำตอบไม่สำเร็จ กรุณาลองใหม่");
        document.querySelectorAll('.live-answer-btn, #sync-submit-btn').forEach(b => b.disabled = false);
    }
}
	
	const allMarketItems = [
    // --- Tier 1: Utilities (ไอเท็มพื้นฐาน) ---
    { id: 'buyTime', name: '⏳ ซื้อเวลา', price: 1, desc: 'เพิ่มเวลา +25% ของเวลาเริ่มต้นในข้อนี้ (สำหรับคุณ)' },
    { id: 'cutOne', name: '✂️ ตัด 1 ตัวเลือก', price: 2, desc: 'ตัดตัวเลือกที่ "ผิด" ออก 1 ข้อ' },

    // --- Tier 2: Strategic (ไอเท็มเชิงกลยุทธ์) ---
    { id: 'fiftyFifty', name: '🌗 50:50', price: 5, desc: 'ตัดตัวเลือกที่ "ผิด" ออก 2 ข้อ (เหลือ 1 ถูก 1 ผิด)' },

    // --- Tier 3: Game Changers (ไอเท็มเปลี่ยนเกม) ---
    { id: 'secondChance', name: '🔁 โอกาสครั้งที่สอง', price: 7, desc: 'ถ้าคุณตอบข้อนี้ผิด คุณจะได้เลือกตอบอีก 1 ครั้ง' },
	
    // [เพิ่มใหม่]
	{ id: 'revealOptions', name: '👁️ เผยตัวเลือก', price: 12, desc: 'เปลี่ยนโจทย์เติมคำ ให้กลายเป็นแบบเลือกตอบ (เฉพาะข้อที่มีตัวเลือกซ่อนอยู่)' }
];

function openBlackMarket(gameData, playerData) {
    let marketTimer = null;
    const modal = document.getElementById('black-market-modal');
    const listEl = document.getElementById('market-item-list');
    const pointsEl = document.getElementById('market-current-points');
    const timerBar = document.getElementById('market-timer-bar');
    
    const playerPoints = playerData.totalPoints || 0;
    pointsEl.textContent = playerPoints;
    
    // [1] ดึงข้อมูลคำถามปัจจุบันมาตรวจสอบ
    const qIndex = gameData.currentQuestionIndex;
    const currentQuestion = gameData.shuffledQuiz.questions[qIndex];
    const qType = currentQuestion.questionType || gameData.shuffledQuiz.quizType; // ดึงประเภทคำถาม
    
    // [2] ตรวจสอบว่ามีการจับเวลาหรือไม่ (สำหรับ Buy Time)
    const isTimerActive = gameData.timerMode === 'per_question';

    const itemsForSale = allMarketItems; 
    
    listEl.innerHTML = itemsForSale.map(item => {
        const hasEnoughPoints = playerPoints >= item.price;
        
        // === 1. Logic สำหรับการซื้อเวลา (Buy Time) ===
        if (item.id === 'buyTime') {
            const maxBuyable = hasEnoughPoints ? Math.floor(playerPoints / item.price) : 0;
            const canBuyAtAll = hasEnoughPoints && isTimerActive;
            
            let btnText = `ซื้อ (${item.price}P/อัน)`;
            let btnClass = canBuyAtAll ? 'bg-indigo-600 hover:bg-indigo-700' : 'bg-gray-400';
            
            if (!isTimerActive) {
                btnText = '<i class="fas fa-ban"></i> ไม่ได้จับเวลา';
                btnClass = 'bg-gray-300 text-gray-500 cursor-not-allowed border border-gray-300'; 
            }

            return `
            <div class="flex items-center justify-between p-3 border rounded-lg ${!canBuyAtAll ? 'bg-gray-100 opacity-70' : 'bg-white'}">
                <div>
                    <p class="font-semibold text-gray-800">${item.name}</p>
                    <p class="text-xs text-gray-500">${item.desc}</p>
                </div>
                <div class="flex items-center gap-2 shrink-0">
                    <input type="number" id="buy-time-quantity-input" 
                           class="w-16 p-2 border border-gray-300 rounded-lg text-sm text-center" 
                           value="1" min="1" max="${maxBuyable}" ${!canBuyAtAll ? 'disabled' : ''}>
                    <button 
                        class="buy-time-confirm-btn text-white font-semibold py-2 px-4 rounded-lg text-sm ${btnClass}"
                        data-item-id="${item.id}"
                        data-price="${item.price}"
                        ${!canBuyAtAll ? 'disabled' : ''}>
                        ${btnText}
                    </button>
                </div>
            </div>
            `;
        } 
        // === 2. Logic สำหรับไอเทมทั่วไป ===
        else {
            let isDisabled = !hasEnoughPoints;
            let btnClass = hasEnoughPoints ? 'bg-indigo-600 hover:bg-indigo-700' : 'bg-gray-400';
            let btnText = `ซื้อ (${item.price}P)`;

            // ▼▼▼ Logic: แช่แข็ง "เผยตัวเลือก" (ถ้าไม่มีตัวเลือกให้เผย) ▼▼▼
            if (item.id === 'revealOptions') {
                const hasHiddenOptions = currentQuestion.options && currentQuestion.options.length > 0;
                const isFillInType = (qType === 'short_answer' || qType === 'fill_in_no_choices');
                
                if (!hasHiddenOptions || !isFillInType) {
                    isDisabled = true;
                    btnClass = 'bg-gray-300 text-gray-500 cursor-not-allowed border border-gray-300';
                    btnText = '<i class="fas fa-ban"></i> ใช้ไม่ได้';
                }
            }

            // ▼▼▼ Logic: แช่แข็ง "ตัดตัวเลือก" และ "50:50" (ถ้าเป็นโจทย์เติมคำ) ▼▼▼
            if (item.id === 'cutOne' || item.id === 'fiftyFifty') {
                // ถ้าเป็นโจทย์พิมพ์ตอบ หรือ ไม่มีตัวเลือกในข้อมูล -> ห้ามตัด
                const isShortAnswer = (qType === 'short_answer' || qType === 'fill_in_no_choices');
                const hasOptions = currentQuestion.options && currentQuestion.options.length > 0;

                if (isShortAnswer || !hasOptions) {
                    isDisabled = true;
                    btnClass = 'bg-gray-300 text-gray-500 cursor-not-allowed border border-gray-300';
                    btnText = '<i class="fas fa-ban"></i> ไม่มีตัวเลือก';
                }
            }
            
            return `
            <div class="flex items-center justify-between p-3 border rounded-lg ${isDisabled ? 'bg-gray-100 opacity-70' : 'bg-white'}">
                <div>
                    <p class="font-semibold text-gray-800">${item.name}</p>
                    <p class="text-xs text-gray-500">${item.desc}</p>
                </div>
                <button 
                    class="buy-item-btn text-white font-semibold py-2 px-4 rounded-lg text-sm shrink-0 ${btnClass}"
                    data-item-id="${item.id}"
                    data-price="${item.price}"
                    ${isDisabled ? 'disabled' : ''}>
                    ${btnText}
                </button>
            </div>
            `;
        }
    }).join('');

    modal.classList.remove('hidden');

    timerBar.style.transition = 'none';
    timerBar.style.width = '100%';
    setTimeout(() => {
        timerBar.style.transition = 'width 60s linear'; 
        timerBar.style.width = '0%';
    }, 50); 
    
    marketTimer = setTimeout(() => {
        modal.classList.add('hidden');
    }, 60000); 

    document.getElementById('close-market-btn').onclick = () => {
        clearTimeout(marketTimer);
        modal.classList.add('hidden');
    };
    
    listEl.querySelectorAll('.buy-item-btn').forEach(btn => {
        btn.onclick = (e) => {
            const itemId = e.target.dataset.itemId;
            const price = parseInt(e.target.dataset.price, 10);
            clearTimeout(marketTimer);
            modal.classList.add('hidden');
            handleBuyItem(playerData.name, itemId, price, 1); 
        };
    });
    
    listEl.querySelectorAll('.buy-time-confirm-btn').forEach(btn => {
        btn.onclick = (e) => {
            const itemId = e.target.dataset.itemId;
            const price = parseInt(e.target.dataset.price, 10);
            const quantityInput = document.getElementById('buy-time-quantity-input');
            const quantity = parseInt(quantityInput.value, 10);
            const maxBuyable = parseInt(quantityInput.max, 10);

            if (!quantity || quantity < 1) {
                showMessage("กรุณาระบุจำนวนที่ถูกต้อง (อย่างน้อย 1 ชิ้น)");
                return;
            }
            if (quantity > maxBuyable) {
                showMessage(`คุณมี Points ไม่พอ (ซื้อได้สูงสุด ${maxBuyable} ชิ้น)`);
                return;
            }
            
            clearTimeout(marketTimer);
            modal.classList.add('hidden');
            handleBuyItem(playerData.name, itemId, price, quantity); 
        };
    });
}

async function handleBuyItem(playerName, itemId, price, quantity = 1) {
    // [แก้ไข] เปลี่ยนเป้าหมายเป็น Player Subcollection
    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, playerName);
    
    try {
        await runTransaction(db, async (transaction) => {
            const playerDoc = await transaction.get(playerRef);
            if (!playerDoc.exists()) throw "ไม่พบข้อมูลผู้เล่น";
            
            const currentPoints = playerDoc.data().totalPoints || 0;
            const totalCost = price * quantity;
            
            if (currentPoints < totalCost) {
                throw "มี Points ไม่เพียงพอ";
            }
            
            const updatePayload = {};
            // [แก้ไข] ตัด prefix 'players.name' ออก
            updatePayload[`totalPoints`] = increment(-totalCost); 
            updatePayload[`powerups.${itemId}`] = increment(quantity); 
            
            transaction.update(playerRef, updatePayload);
        });
        
        showMessage(`ซื้อ "${itemId}" x${quantity} สำเร็จ!`);
        
    } catch (error) {
        console.error("Buy Item failed: ", error);
        showMessage(typeof error === 'string' ? error : "เกิดข้อผิดพลาดในการซื้อ");
    }
}

async function handlePayForMarketEntry(playerName, gameData, playerData) {
    // [แก้ไข] เปลี่ยนเป้าหมายเป็น Player Subcollection
    const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, playerName);
    
    try {
        await runTransaction(db, async (transaction) => {
            const playerDoc = await transaction.get(playerRef);
            if (!playerDoc.exists()) throw "ไม่พบข้อมูลผู้เล่น";
            
            const currentPoints = playerDoc.data().totalPoints || 0;
            
            if (currentPoints < 1) throw "มี Points ไม่เพียงพอ (ต้องใช้ 1P)";
            
            const updatePayload = {};
            // [แก้ไข] ตัด prefix 'players.name' ออก
            updatePayload[`totalPoints`] = increment(-1); 
            transaction.update(playerRef, updatePayload);
        });
        
        const updatedPlayerData = { ...playerData, totalPoints: (playerData.totalPoints || 0) - 1 };
        openBlackMarket(gameData, updatedPlayerData); 
        
    } catch (error) {
        console.error("Market entry payment failed:", error);
        showMessage(typeof error === 'string' ? error : "เกิดข้อผิดพลาดในการเข้าตลาดมืด");
    }
}

// --- ระบบเสียง (Sound Effects) แบบไม่ต้องใช้ไฟล์ ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSystemSound(type) {
    // ต้องสั่ง resume เพราะบาง Browser บล็อกเสียงอัตโนมัติ
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    
    if (type === 'correct') {
        // เสียงติ๊ง! (สูงใส)
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        gain.gain.setValueAtTime(0.1, now); // ลดความดังลงหน่อย (0.1)
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
    } else if (type === 'incorrect') {
        // เสียงแอ๊ด... (ต่ำทุ้ม)
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'powerup') {
        // เสียงวิ้งๆ (ใช้ไอเทม)
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    }
}

async function handleEmergencyAnswerFix(newCorrectValue, gameData) {
    if (!currentLiveGameId) return;

    const currentQ = gameData.shuffledQuiz.questions[gameData.currentQuestionIndex];
    const qType = currentQ.questionType || gameData.shuffledQuiz.quizType;
    const isShortAnswer = (qType === 'short_answer' || qType === 'fill_in_no_choices');

    // ตรวจสอบว่าซ้ำกับของเดิมไหม
    if (isShortAnswer) {
        if (currentQ.idealAnswer === newCorrectValue) { alert("คำตอบนี้เป็นเฉลยปัจจุบันอยู่แล้วครับ"); return; }
    } else {
        if (currentQ.correctAnswerIndex === newCorrectValue) { alert("คำตอบนี้เป็นเฉลยปัจจุบันอยู่แล้วครับ"); return; }
    }

    showMessage("กำลังคำนวณใหม่... (ปรับคะแนนดิบและ Points) กรุณารอสักครู่");

    try {
        const gameRef = doc(db, `artifacts/${appId}/public/data/syncGames`, currentLiveGameId);
        const batch = writeBatch(db);

        // 1. อัปเดตเฉลยใน Quiz หลัก
        const updatedQuiz = JSON.parse(JSON.stringify(gameData.shuffledQuiz));
        if (isShortAnswer) {
            updatedQuiz.questions[gameData.currentQuestionIndex].idealAnswer = newCorrectValue;
        } else {
            updatedQuiz.questions[gameData.currentQuestionIndex].correctAnswerIndex = newCorrectValue;
        }
        
        let netPotChange = 0;

        // --- [A] ดึงน้ำหนักคะแนน (Weight) ---
        const typeScoring = gameData.shuffledQuiz.settings?.typeScoring || { mcq: 1, sa: 1, tf: 1 };
        let maxScore = 1;
        if (qType === 'short_answer' || qType === 'fill_in_no_choices') maxScore = typeScoring.sa;
        else if (qType === 'true_false') maxScore = typeScoring.tf;
        else maxScore = typeScoring.mcq;

        // 2. ดึงข้อมูลผู้เล่น
        const playersRef = collection(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`);
        const playersSnap = await getDocs(playersRef);

        for (const docSnap of playersSnap.docs) {
            const player = docSnap.data();
            const playerRef = doc(db, `artifacts/${appId}/public/data/syncGames/${currentLiveGameId}/players`, player.name);
            
            const currentAnsIndex = player.answers.findIndex(a => a.questionIndex === gameData.currentQuestionIndex);
            
            if (currentAnsIndex !== -1) {
                const ansData = player.answers[currentAnsIndex];
                
                // ตรวจสอบคำตอบ
                let matchesNewAnswer = false;
                if (isShortAnswer) {
                    const mockQuestion = { ...currentQ, idealAnswer: newCorrectValue };
                    matchesNewAnswer = await gradeShortAnswer(ansData.answerText || ansData.answer, mockQuestion);
                } else {
                    matchesNewAnswer = (parseInt(ansData.answer) === newCorrectValue);
                }

                const isGroupA = !ansData.isCorrect && matchesNewAnswer; // ผิด -> ถูก
                const isGroupC = ansData.isCorrect && !matchesNewAnswer; // ถูก -> ผิด

                let shouldUpdate = false;
                let pointAdjustment = 0;     // สำหรับ Game Points
                let onetAdjustment = 0;      // สำหรับ O-NET & Raw Score
                let newStreak = player.correctStreak;
                let newIsCorrect = ansData.isCorrect;

                // --- กรณีที่ 1: เปลี่ยนจาก ผิด เป็น ถูก ---
                if (isGroupA) {
                    shouldUpdate = true;
                    newIsCorrect = true;

                    // Streak
                    let restoredStreak = 0;
                    for (let i = player.answers.length - 1; i >= 0; i--) {
                        const a = player.answers[i];
                        if (a.questionIndex === gameData.currentQuestionIndex) continue;
                        if (a.isCorrect) restoredStreak++;
                        else break; 
                    }
                    const isFireActive = restoredStreak >= 3;
                    newStreak = restoredStreak + 1;

                    // Game Points (สูตร: มั่นใจ = Weight*2, ไม่มั่น = Weight*1)
                    // ต้องลบค่า Penalty เดิมออกด้วย (ถ้ามี)
                    const wager = ansData.wagerAmount || 0;
                    const wasConfident = ansData.wasConfident === true || ansData.wasConfident === 'confident';

                    if (ansData.powerupUsed === 'wagerMultiplier') {
                        let profit = (wager * 2);
                        if (isFireActive) profit *= 2;
                        pointAdjustment = wager + profit;
                        netPotChange -= wager; 
                    } else if (gameData.isConfidenceScoringEnabled || gameData.isWeightedMode) {
                        // คำนวณรางวัลใหม่
                        let baseReward = wasConfident ? (maxScore * 2) : maxScore;
                        if (isFireActive) baseReward *= 2;

                        // คำนวณโทษเดิมที่เคยโดนหัก
                        let previousPenalty = wasConfident ? -maxScore : 0;
                        if (ansData.wasJinxed) previousPenalty *= 2;

                        // ส่วนต่าง = รางวัลใหม่ - (โทษเดิม)
                        pointAdjustment = baseReward - previousPenalty;
                    } else {
                        let baseReward = maxScore;
                        if (isFireActive) baseReward *= 2;
                        pointAdjustment = baseReward;
                    }

                    // O-NET & Raw Score (บวกน้ำหนักเต็ม)
                    onetAdjustment = maxScore;
                } 
                
                // --- กรณีที่ 2: เปลี่ยนจาก ถูก เป็น ผิด ---
                else if (isGroupC) {
                    shouldUpdate = true;
                    newIsCorrect = false;
                    newStreak = 0;

                    const oldPointsAwarded = ansData.pointsAwarded || 0;
                    const wager = ansData.wagerAmount || 0;
                    const wasConfident = ansData.wasConfident === true || ansData.wasConfident === 'confident';

                    pointAdjustment = -oldPointsAwarded; // ยึดรางวัลคืนก่อน

                    if (ansData.powerupUsed === 'wagerMultiplier') {
                        pointAdjustment -= wager; 
                        netPotChange += wager;
                    } else if (gameData.isConfidenceScoringEnabled || gameData.isWeightedMode) {
                        // ถ้ามั่นใจผิด ต้องโดนหักเพิ่มตามน้ำหนัก
                        if (wasConfident) {
                            pointAdjustment -= maxScore;
                        }
                    } else {
                        pointAdjustment -= 0;
                    }

                    // ยึด O-NET & Raw Score คืน
                    onetAdjustment = -maxScore;
                }

                if (shouldUpdate) {
                    const newAnswers = [...player.answers];
                    newAnswers[currentAnsIndex] = {
                        ...ansData,
                        isCorrect: newIsCorrect,
                        pointsAwarded: (ansData.pointsAwarded || 0) + pointAdjustment,
                        onetPointsAwarded: (ansData.onetPointsAwarded || 0) + onetAdjustment
                    };

                    batch.update(playerRef, {
                        // [แก้ไขตรงนี้] ใช้ onetAdjustment (4.75) แทน 1
                        score: increment(onetAdjustment), 
                        
                        totalPoints: increment(pointAdjustment),
                        totalOnetScore: increment(onetAdjustment),
                        correctStreak: newStreak,
                        answers: newAnswers,
                        pointsLastRound: (player.pointsLastRound || 0) + pointAdjustment
                    });
                }
            }
        }

        // 3. อัปเดต Game Doc
        const gameUpdatePayload = { shuffledQuiz: updatedQuiz };
        if (netPotChange !== 0) {
            gameUpdatePayload.centralPot = increment(netPotChange);
        }
        batch.update(gameRef, gameUpdatePayload);

        await batch.commit();
        showMessage(`✅ แก้ไขเฉลยสมบูรณ์! (คะแนนดิบปรับแก้ ${maxScore} แต้ม)`);

    } catch (error) {
        console.error("Emergency fix failed:", error);
        showMessage("❌ เกิดข้อผิดพลาด: " + error.message);
    }
}

// ==========================================
    // 🎲 ระบบสุ่มชื่อ V.Pro (Online Firebase V.Complete)
    // ==========================================

    // ------------------------------------------
    // ส่วนที่ 1: สร้างหน้าต่างและปุ่ม (UI)
    // ------------------------------------------
    const proPickerHTML = `
    <div id="proPickerBtn" class="fixed top-0 right-0 p-4 z-50">
        <button onclick="window.toggleProPicker()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-5 py-2 rounded-full shadow-lg transition font-bold border-2 border-white flex items-center gap-2 transform hover:scale-105">
            <i class="fas fa-gamepad"></i> สุ่มรายชื่อ (Online)
        </button>
    </div>

    <div id="proPickerOverlay" class="hidden fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 backdrop-blur-sm">
        <div class="bg-white rounded-2xl w-full max-w-xl relative shadow-2xl border-4 border-indigo-200 overflow-hidden">
            
            <button onclick="window.toggleProPicker()" class="absolute top-2 right-4 text-gray-400 text-3xl hover:text-red-500 z-20">&times;</button>

            <div id="viewGame" class="p-8 text-center transition-all duration-300">
                <h2 class="text-2xl font-bold text-indigo-700 mb-6">🎲 สุ่มผู้โชคดี (Online Mode)</h2>
                
                <div class="mb-6 text-left">
                    <label class="text-xs text-gray-500 font-bold ml-1">เลือกห้องเรียน / โปรเจค:</label>
                    <div class="flex gap-2">
                        <select id="classSelector" onchange="window.loadClassForGame()" class="flex-1 bg-gray-50 border border-indigo-300 text-gray-900 text-lg rounded-xl p-3 focus:ring-2 focus:ring-indigo-500 outline-none">
                            <option value="">-- กำลังโหลดข้อมูล... --</option>
                        </select>
                        <button onclick="window.switchView('setup')" class="bg-gray-200 hover:bg-gray-300 text-gray-600 px-4 rounded-xl transition" title="จัดการรายชื่อ">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                </div>

                <div id="proResultBox" class="w-full h-32 bg-indigo-50 rounded-2xl border-4 border-dashed border-indigo-200 flex items-center justify-center mb-6 relative overflow-hidden">
                    <span id="proResultText" class="text-4xl font-bold text-gray-300">???</span>
                </div>

                <div class="text-sm text-gray-500 mb-4">
                    สมาชิกในห้อง: <span id="memberCount" class="font-bold text-indigo-600">0</span> คน
                </div>

                <button id="btnProRandom" onclick="window.runProRandom()" disabled class="w-full bg-gray-300 text-white text-2xl py-4 rounded-xl shadow-lg font-bold cursor-not-allowed transition transform active:scale-95">
                    กดเพื่อสุ่ม! 🚀
                </button>
            </div>

            <div id="viewSetup" class="hidden p-6 bg-gray-50 h-full">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-700"><i class="fas fa-edit"></i> จัดการห้องเรียน (Cloud)</h3>
                    <button onclick="window.switchView('game')" class="text-sm text-indigo-600 font-bold hover:underline">
                        <i class="fas fa-arrow-left"></i> กลับไปสุ่ม
                    </button>
                </div>

                <div class="space-y-4">
                    <div>
                        <label class="block text-xs font-bold text-gray-500 mb-1">ชื่อห้อง / โปรเจค (เช่น ป.6/1)</label>
                        <input type="text" id="inputClassName" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" placeholder="ตั้งชื่อห้อง...">
                    </div>
                    
                    <div>
                        <label class="block text-xs font-bold text-gray-500 mb-1">รายชื่อ (คนละบรรทัด)</label>
                        <textarea id="inputStudentList" class="w-full h-32 p-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500" placeholder="นาย A\nนางสาว B\nเด็กชาย C"></textarea>
                    </div>

                    <div class="flex gap-2 pt-2">
                        <button onclick="window.saveCurrentClass()" class="flex-1 bg-green-500 hover:bg-green-600 text-white py-2 rounded-lg font-bold shadow">
                            <i class="fas fa-save"></i> บันทึกขึ้น Cloud
                        </button>
                        <button onclick="window.deleteCurrentClass()" class="px-4 bg-red-100 text-red-500 hover:bg-red-200 rounded-lg font-bold">
                            <i class="fas fa-trash"></i> ลบ
                        </button>
                    </div>
                    
                    <div id="setupStatus" class="text-center text-xs h-4 font-bold text-green-600"></div>
                </div>
            </div>
        </div>
    </div>`;

    // ลบปุ่มเดิมออกก่อน (ถ้ามี) แล้วใส่ปุ่มใหม่เข้าไป
    const oldProBtn = document.getElementById('proPickerBtn');
    if(oldProBtn) oldProBtn.remove();
    const dashboardPage = document.getElementById('project-dashboard-view');

    if (dashboardPage) {
        // ลบปุ่มเดิมออกก่อน (ถ้ามีค้างอยู่)
        const oldProBtn = document.getElementById('proPickerBtn');
        if (oldProBtn) oldProBtn.remove();

        // 2. นำ HTML ของปุ่มไปใส่ในหน้า Dashboard เท่านั้น
        // (เมื่อหน้า Dashboard ถูกซ่อน ปุ่มนี้ก็จะซ่อนตามไปด้วยทันที)
        dashboardPage.insertAdjacentHTML('beforeend', proPickerHTML);

    } else {
        console.error("หาหน้า Dashboard ไม่เจอ (เช็ค ID: project-dashboard-view)");
    }


    // ------------------------------------------
    // ส่วนที่ 2: ระบบ Logic (เชื่อมต่อ Firebase)
    // ------------------------------------------
    let allClassData = {}; 
    let currentPlayingList = [];
    let unsubscribeClassListener = null;

    // เริ่มต้นระบบ: รอจนกว่า db จะพร้อม แล้วค่อยดึงข้อมูล
    window.initClassSystem = function() {
        if (typeof db === 'undefined' || !db) {
            console.log("Database ยังไม่พร้อม... รอสักครู่...");
            setTimeout(window.initClassSystem, 1000);
            return;
        }

        console.log("🔥 เชื่อมต่อระบบรายชื่อ Online...");
        const publicClassRef = doc(db, 'global_settings', 'public_class_v_pro'); 

        // ยกเลิกการฟังข้อมูลเก่าก่อน (ถ้ามี)
        if (unsubscribeClassListener) unsubscribeClassListener();

        // ฟังการเปลี่ยนแปลงข้อมูลแบบ Realtime
        unsubscribeClassListener = onSnapshot(publicClassRef, (docSnap) => {
            if (docSnap.exists()) {
                allClassData = docSnap.data();
            } else {
                allClassData = {}; 
            }
            
            window.updateDropdown();
            
            // ถ้าเลือกห้องค้างไว้ ให้โหลดข้อมูลใหม่ทันที
            const currentSelect = document.getElementById('classSelector') ? document.getElementById('classSelector').value : '';
            if (currentSelect && allClassData[currentSelect]) {
                window.loadClassForGame();
            }
        }, (error) => {
            console.error("Error listening to classes:", error);
        });
    }

    // อัปเดตรายการใน Dropdown
    window.updateDropdown = function() {
        const select = document.getElementById('classSelector');
        if (!select) return;

        const oldVal = select.value;
        const keys = Object.keys(allClassData);
        
        if (keys.length === 0) {
             select.innerHTML = '<option value="">-- ยังไม่มีข้อมูล (กดปุ่มเฟืองเพื่อเพิ่ม) --</option>';
        } else {
             select.innerHTML = '<option value="">-- กรุณาเลือกห้อง --</option>';
             keys.forEach(className => {
                select.innerHTML += `<option value="${className}">${className}</option>`;
            });
        }

        if (allClassData[oldVal]) {
            select.value = oldVal;
        }
    }

    // สลับหน้าจอ (เล่นเกม <-> ตั้งค่า)
    window.switchView = function(mode) {
        const viewGame = document.getElementById('viewGame');
        const viewSetup = document.getElementById('viewSetup');
        
        if (mode === 'setup') {
            viewGame.classList.add('hidden');
            viewSetup.classList.remove('hidden');
            
            const currentSelect = document.getElementById('classSelector').value;
            if (currentSelect && allClassData[currentSelect]) {
                document.getElementById('inputClassName').value = currentSelect;
                document.getElementById('inputStudentList').value = allClassData[currentSelect].join('\n');
            } else {
                document.getElementById('inputClassName').value = "";
                document.getElementById('inputStudentList').value = "";
            }

        } else {
            viewSetup.classList.add('hidden');
            viewGame.classList.remove('hidden');
            window.updateDropdown();
            window.loadClassForGame();
        }
    }

    // บันทึกข้อมูล (Save to Firestore)
    window.saveCurrentClass = async function() {
        if (!db) return;
        
        const name = document.getElementById('inputClassName').value.trim();
        const rawList = document.getElementById('inputStudentList').value;
        const list = rawList.split('\n').map(s => s.trim()).filter(s => s !== "");

        if (!name) { alert("กรุณาตั้งชื่อห้องด้วยครับ"); return; }
        if (list.length === 0) { alert("กรุณาใส่รายชื่ออย่างน้อย 1 คน"); return; }

        const status = document.getElementById('setupStatus');
        status.innerText = "⏳ กำลังบันทึกขึ้น Cloud...";

        try {
            const publicClassRef = doc(db, 'global_settings', 'public_class_v_pro'); 
            await setDoc(publicClassRef, {
                [name]: list
            }, { merge: true });

            status.innerText = `✅ บันทึกห้อง "${name}" เรียบร้อย!`;
            setTimeout(() => status.innerText = "", 2000);

        } catch (error) {
            console.error(error);
            alert("บันทึกไม่สำเร็จ: " + error.message);
            status.innerText = "❌ ผิดพลาด";
        }
    }

    // ลบข้อมูล (Delete from Firestore)
    window.deleteCurrentClass = async function() {
        if (!db) return;
        const name = document.getElementById('inputClassName').value.trim();
        if (!allClassData[name]) return;

        if (confirm(`ยืนยันที่จะลบห้อง "${name}" ทิ้งถาวร?`)) {
            try {
                const publicClassRef = doc(db, 'global_settings', 'public_class_v_pro'); 
                await updateDoc(publicClassRef, {
                    [name]: deleteField()
                });
                
                document.getElementById('inputClassName').value = "";
                document.getElementById('inputStudentList').value = "";
                document.getElementById('setupStatus').innerText = "🗑️ ลบเรียบร้อย";
            } catch (error) {
                console.error(error);
                alert("ลบไม่สำเร็จ: " + error.message);
            }
        }
    }

    // เตรียมข้อมูลก่อนเล่นเกม
    window.loadClassForGame = function() {
        const select = document.getElementById('classSelector');
        if(!select) return;
        
        const selectedName = select.value;
        const btn = document.getElementById('btnProRandom');
        const countSpan = document.getElementById('memberCount');
        const resultText = document.getElementById('proResultText');

        resultText.innerText = "???";
        resultText.className = "text-4xl font-bold text-gray-300";

        if (selectedName && allClassData[selectedName]) {
            currentPlayingList = allClassData[selectedName];
            countSpan.innerText = currentPlayingList.length;
            
            btn.disabled = false;
            btn.className = "w-full bg-indigo-600 hover:bg-indigo-700 text-white text-2xl py-4 rounded-xl shadow-lg font-bold cursor-pointer transition transform hover:scale-105";
        } else {
            currentPlayingList = [];
            countSpan.innerText = "0";
            btn.disabled = true;
            btn.className = "w-full bg-gray-300 text-white text-2xl py-4 rounded-xl shadow-lg font-bold cursor-not-allowed";
        }
    }

    // เอฟเฟกต์สุ่มตัวเลข
    window.runProRandom = function() {
        if (currentPlayingList.length === 0) return;
        
        const btn = document.getElementById('btnProRandom');
        const resultText = document.getElementById('proResultText');
        const box = document.getElementById('proResultBox');
        
        btn.disabled = true;
        let count = 0;

        box.classList.remove('bg-yellow-100', 'border-yellow-400');
        box.classList.add('bg-indigo-50', 'border-indigo-200');

        const interval = setInterval(() => {
            const rand = Math.floor(Math.random() * currentPlayingList.length);
            resultText.innerText = currentPlayingList[rand];
            resultText.className = "text-4xl font-bold text-gray-400";
            count++;

            if (count > 30) {
                clearInterval(interval);
                resultText.innerText = "🎉 " + currentPlayingList[rand] + " 🎉";
                resultText.className = "text-5xl font-bold text-indigo-700 animate-bounce";
                
                box.classList.remove('bg-indigo-50', 'border-indigo-200');
                box.classList.add('bg-yellow-100', 'border-yellow-400');
                
                btn.disabled = false;
            }
        }, 50);
    }

    // เปิด/ปิด Popup
    window.toggleProPicker = function() {
        const overlay = document.getElementById('proPickerOverlay');
        if (overlay.classList.contains('hidden')) {
            overlay.classList.remove('hidden');
            window.updateDropdown();
        } else {
            overlay.classList.add('hidden');
        }
    }

    // เริ่มทำงาน
    window.initClassSystem();
		
        initialize();
